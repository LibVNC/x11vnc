[![Build Status](https://travis-ci.org/LibVNC/x11vnc.svg?branch=master)](https://travis-ci.org/LibVNC/x11vnc)

Copyright (C) 2002-2010 Karl J. Runge <runge@karlrunge.com>
All rights reserved.

x11vnc README file                         Date: Sat Apr 29 16:15:34 CET 2017

The following information is taken from these URLs:

	http://www.karlrunge.com/x11vnc/index.html
	http://www.karlrunge.com/x11vnc/x11vnc_opts.html
	...

they contain the most up to date info. They are converted to markdown using https://domchristie.github.io/to-markdown/ [source code](https://github.com/domchristie/to-markdown)

----	
http://www.karlrunge.com/x11vnc/index.html:

* * *

## x11vnc: a VNC server for real X displays
                <font size="-1">(to [FAQ](faq.html#faq))    (to [Downloads](#downloading))    (to [Building](#building))    (to [Beta Test](#beta-test))    (to [Donations](faq.html#faq-thanks)) [![[PayPal]](x-click-but04.gif)](faq.html#faq-thanks)</font>

**x11vnc** allows one to view remotely and interact with real X displays (i.e. a display corresponding to a physical monitor, keyboard, and mouse) with any VNC viewer. In this way it plays the role for Unix/X11 that WinVNC plays for Windows.

It has built-in [SSL/TLS](faq.html#faq-ssl-tunnel-int) encryption and 2048 bit RSA authentication, including VeNCrypt support; UNIX [account and password](faq.html#faq-userlogin) login support; server-side [scaling](faq.html#faq-scaling); [single port](faq.html#faq-ssl-tunnel-viewers) HTTPS/HTTP+VNC; [Zeroconf](faq.html#faq-avahi) service advertising; and TightVNC and UltraVNC [file-transfer](faq.html#faq-filexfer). It has also been extended to work with non-X devices: natively on [Mac OS X Aqua/Quartz](faq.html#faq-macosx), [webcams and TV tuner](faq.html#faq-video) capture devices, and [embedded Linux systems](faq.html#faq-qt-embedded) such as Qtopia Core. Full IPv6 support is provided. More features are described [here](#beta-test).

It also provides an encrypted [Terminal Services](faq.html#infaq_findcreatedisplay) mode ([`-create`](x11vnc_opts.html#opt-create), [`-svc`](x11vnc_opts.html#opt-svc), or [`-xdmsvc`](x11vnc_opts.html#opt-xdmsvc) options) based on Unix usernames and Unix passwords where the user does not need to memorize his VNC display/port number. Normally a virtual X session (**Xvfb**) is created for each user, but it also works with X sessions on physical hardware. See the [`tsvnc`](ssvnc.html#tsvnc) terminal services mode of the SSVNC viewer for one way to take advantage of this mode.

I wrote **x11vnc** back in 2002 because **x0rfbserver** was basically impossible to build on Solaris and had poor performance. The primary **x0rfbserver** build problems centered around esoteric `C++` toolkits. **x11vnc** is written in plain `C` and needs only standard libraries and so should work on nearly all Unixes, even very old ones. I also created enhancements to improve the interactive response, added many features, and etc.

This page including the [FAQ](faq.html#faq) contains much information [[*]](disclaimer.html); solutions to many problems; and interesting applications, but nevertheless please feel free to [contact me](#contact) if you have problems or questions (and if I save you time or expense by giving you some of my time, please consider a [PayPal Donation](faq.html#faq-thanks).) Do check the [FAQ](faq.html#faq) and this page first; I realize the pages are massive, but you can often use your browser's find-in-page search action using a keyword to find the answer to your problem or question.

**SSVNC:**  An **x11vnc** side-project provides an [Enhanced TightVNC Viewer package (SSVNC)](ssvnc.html) for Unix, Windows, and Mac OS X with automatic SSL and/or SSH tunnelling support, SSL Certificate creation, Saved connection profiles, Zeroconf, VeNCrypt, and built-in Proxy support. Added features for the TightVNC Unix viewer: NewFBSize, ZRLE encoding, Viewer-side Scaling, cursor alphablending, low color modes, and enhanced popup menu; UltraVNC extensions support for: File Transfer, Text Chat, Single Window, Server Input, and 1/n Scaling extensions, and UltraVNC DSM encryption. The SSVNC bundle could be placed on, say, a USB memory stick for SSL/SSH VNC viewing from nearly any networked computer.

* * *

<a name="announcements"></a>

#### Announcements:

**<font color="bisque4">Important:</font>** If you created any permanent SSL certificates (e.g. via "[`x11vnc -ssl SAVE ...`](x11vnc_opts.html#opt-ssl)") on a Debian or Ubuntu system from Sept. 2006 through May 2008, then those keys are likely extremely weak and can be easily cracked. The certificate files should be deleted and recreated on a non-Debian system or an updated one. See [http://www.debian.org/security/2008/dsa-1571](http://www.debian.org/security/2008/dsa-1571) for details. The same applies to SSH keys (not used by **x11vnc** directly, but many people use [SSH tunnels](#tunnelling) for VNC access.)

**FAQ moved:** The huge [FAQ](faq.html#faq) has finally been moved to its own page. If you are trying to follow someone's link to an FAQ once on this page it is now a broken link. Try inserting the string "`faq.html`", e.g.:

<pre>from:   http://www.karlrunge.com/x11vnc/#faq-singleclick
to:     http://www.karlrunge.com/x11vnc/faq.html#faq-singleclick
</pre>

Apologies for the inconvenience, unfortunately it is not possible to automatically redirect to the new page since the '`#`' anchor is not sent to the webserver.

* * *

<a name="background"></a>

#### Background:

VNC (Virtual Network Computing) is a very useful network graphics protocol (applications running on one computer but displaying their windows on another) in the spirit of X, however, unlike X, the viewing-end is very simple and maintains no state. It is a remote framebuffer (RFB) protocol.

Some VNC links:

*   [http://www.realvnc.com](http://www.realvnc.com/)
*   [http://www.tightvnc.com](http://www.tightvnc.com/)
*   [http://www.ultravnc.com/](http://www.ultravnc.com/)
*   [http://www.testplant.com/products/vine_server/OS_X](http://www.testplant.com/products/vine_server/OS_X)

For Unix, the traditional VNC implementation includes a "virtual" X11 server **Xvnc** (usually launched via the **vncserver** command) that is not associated with a physical display, but provides a "fake" one X11 clients (`xterm`, `firefox`, _etc._) can attach to. A remote user then connects to **Xvnc** via the VNC client **vncviewer** from anywhere on the network to view and interact with the whole virtual X11 desktop.

The VNC protocol is in most cases better suited for remote connections with low bandwidth and high latency than is the X11 protocol because it involves far fewer "roundtrips" (an exception is the [cached pixmap data](faq.html#faq-client-caching) on the viewing-end provided by X.) Also, with no state maintained the viewing-end can crash, be rebooted, or relocated and the applications and desktop continue running. Not so with X11.

So the standard **Xvnc/vncserver** program is very useful, I use it for things like:

*   Desktop conferencing with other users (_e.g._ code reviews.)
*   Long running apps/tasks I want to be able to view from many places (e.g. from home and work.)
*   Motif, GNOME, and similar applications that would yield very poor performance over a high latency link.

**_<font color="bisque4">However</font>_**, sometimes one wants to connect to a **real** X11 display (_i.e._ one attached to a physical monitor, keyboard, and mouse: a Workstation or a SunRay session) from far away. Maybe you want to close down an application cleanly rather than using `kill`, or want to work a bit in an already running application, or would like to help a distant colleague solve a problem with their desktop, or would just like to work out on the deck for a while. This is where **x11vnc** is useful.

* * *

<a name="running"></a>

#### How to use x11vnc:

In this basic example let's assume the remote machine with the **X** display you wish to view is "`far-away.east:0`" and the workstation you are presently working at is "`sitting-here.west`".

**Step 0.** Download **x11vnc** ([see below](#downloading)) and have it available to run on `far-away.east` (on some linux distros it is as easy as "`apt-get install x11vnc`", "`emerge x11vnc`", etc.) Similarly, have a VNC viewer (_e.g._ **vncviewer**) ready to run on `sitting-here.west`. We recommend [TightVNC Viewers](http://www.tightvnc.com/download.html) (see also [our SSVNC viewer](ssvnc.html).)

**Step 1.** By some means log in to `far-away.east` and get a command shell running there. You can use `ssh`, or even `rlogin`, `telnet`, or any other method to do this. We do this because the **x11vnc** process needs to be run on the same machine the **X** server process is running on (otherwise things would be extremely slow.)

**Step 2.** In that `far-away.east` shell (with command prompt "`far-away>`" in this example) run **x11vnc** directed at the `far-away.east` X session display:

<pre>  far-away> x11vnc -display :0
</pre>

You could have also set the environment variable `DISPLAY=:0` instead of using "`-display :0`". This step attaches **x11vnc** to the `far-away.east:0` X display (i.e. no viewer clients yet.)

_**Common Gotcha:**_ To get X11 permissions right, you may also need to set the `XAUTHORITY` environment variable (or use the [`-auth`](x11vnc_opts.html#opt-auth) option) to point to the correct MIT-MAGIC-COOKIE file (e.g. `/home/joe/.Xauthority`.) If **x11vnc** does not have the authority to connect to the display it exits immediately. More on how to fix this [below](faq.html#faq-xperms).

If you suspect an X11 permissions problem do this simple test: while sitting at the _physical_ X display open a terminal window (gnome-terminal, xterm, etc.) You should be able to run **x11vnc** successfully in that terminal _without any need for command line options_. If that works OK then you know X11 permissions are the only thing preventing it from working when you try to start **x11vnc** via a remote shell. Then fix this with the tips [below](faq.html#faq-xperms).

Note as of Feb/2007 you can also try the [`-find`](x11vnc_opts.html#opt-find) option instead of "`-display ...`" and see if that finds your display and Xauthority. Note as of Dec/2009 the [`-findauth`](x11vnc_opts.html#opt-findauth) and "[`-auth guess`](x11vnc_opts.html#opt-auth)" options may be helpful as well.
(End of _Common Gotcha_)

When **x11vnc** starts up there will then be much chatter printed out (use "`-q`" to quiet it), until it finally says something like:

<pre>  .
  .
  13/05/2004 14:59:54 Autoprobing selected port 5900
  13/05/2004 14:59:54 screen setup finished.
  13/05/2004 14:59:54
  13/05/2004 14:59:54 The VNC desktop is far-away:0
  PORT=5900
</pre>

which means all is OK, and we are ready for the final step.

**Step 3.** At the place where you are sitting (`sitting-here.west` in this example) you now want to run a VNC viewer program. There are VNC viewers for Unix, Windows, MacOS, Java-enabled web browsers, and even for PDA's like the Palm Pilot and Cell Phones! You can use any of them to connect to **x11vnc** (see the above VNC links under "Background:" on how to obtain a viewer for your platform or see [this FAQ](faq.html#faq-viewer-download). For Solaris, **vncviewer** is available in the [Companion CD](http://www.sun.com/software/solaris/freeware/) package `SFWvnc`.)

In this example we'll use the Unix **vncviewer** program on `sitting-here` by typing the following command in a second terminal window:

<pre>  sitting-here> vncviewer far-away.east:0
</pre>

That should pop up a viewer window on `sitting-here.west` showing and allowing interaction with the `far-away.east:0`  X11 desktop. Pretty nifty! When finished, exit the viewer: the remote **x11vnc** process will shutdown automatically (or you can use the [`-forever`](x11vnc_opts.html#opt-forever) option to have it wait for additional viewer connections.)

_**Common Gotcha:**_ Nowadays there will likely be a host-level [firewall](#firewalls) on the **x11vnc** side that is blocking remote access to the VNC port (e.g. 5900.) You will either have to open up that port (or a range of ports) in your firewall administration tool, or try the [SSH tunnelling](#tunnelling) method below (even still the firewall must allow in the SSH port, 22.)

**_<font color="bisque4">Shortcut:</font>_** Of course if you left **x11vnc** running on `far-away.east:0` in a terminal window with the [`-forever`](x11vnc_opts.html#opt-forever) option or as a [service](faq.html#faq-service), you'd only have to do Step 3 as you moved around. Be sure to use a VNC [Password](faq.html#faq-passwd) or [other measures](#vnc_password_file) if you do that.

**_<font color="bisque4">Super Shortcut:</font>_** Here is a potentially _**very**_ easy way to get all of it working.

*   Have **x11vnc** (0.9.3 or later) available to run on the remote host (i.e. in $PATH.)
*   Download and unpack a [SSVNC](ssvnc.html#download) bundle (1.0.19 or later, e.g. [`ssvnc_no_windows-1.0.28.tar.gz`](http://downloads.sourceforge.net/ssvnc/ssvnc_no_windows-1.0.28.tar.gz?use_mirror)) on the Viewer-side machine.
*   Start the SSVNC Terminal Services mode GUI: `./ssvnc/bin/tsvnc`
*   Enter your remote `username@hostname` (e.g. `fred@far-away.east`) in the "VNC Terminal Server" entry.
*   Click "Connect".

That will do an SSH to `username@hostname` and start up **x11vnc** and then connect a VNC Viewer through the SSH [encrypted tunnel](#tunnelling).

There are a number of things assumed here, first that you are able to SSH into the remote host; i.e. that you have a Unix account there and the SSH server is running. On Unix and MacOS X it is assumed that the `ssh` client command is available on the local machine (on Windows a plink binary is included in the SSVNC bundle.) Finally, it is assumed that you are already logged into an X session on the remote machine, e.g. your workstation (otherwise, a virtual X server, e.g. **Xvfb**, will be [started for you](ssvnc.html#tsvnc).)

In some cases the remote SSH server will not run commands with the same $PATH that you normally have in your shell there. In this case click on Options -> Advanced -> X11VNC Options, and type in the location of the **x11vnc** binary under "Full Path". (End of _Super Shortcut_)

**_Desktop Sharing:_** The above more or less assumed nobody was sitting at the workstation display "`far-away.east:0`". This is often the case: a user wants to access her workstation remotely. Another usage pattern has the user sitting at "`far-away.east:0`" and invites one or more other people to view and interact with his desktop. Perhaps the user gives a demo or presentation this way (using the telephone for vocal communication.) A "Remote Help Desk" mode would be similar: a technician connects remotely to the user's desktop to interactively solve a problem the user is having.

For these cases it should be obvious how it is done. The above steps will work, but more easily the user sitting at `far-away.east:0` simply starts up **x11vnc** from a terminal window, after which the guests would start their VNC viewers. For this usage mode the "[`-connect host1,host2`](x11vnc_opts.html#opt-connect)" option may be of use to automatically connect to the vncviewers in "`-listen`" mode on the list of hosts.

* * *

<a name="tunnelling"></a>

#### Tunnelling x11vnc via SSH:

The above example had no security or privacy at all. When logging into remote machines (certainly when going over the internet) it is best to use `ssh`, or use a VPN (for a VPN, Virtual Private Network, the above example should be pretty safe.)

For **x11vnc** one can tunnel the VNC protocol through an encrypted `ssh` channel. It would look something like running the following commands:

<pre>  sitting-here> ssh -t -L 5900:localhost:5900 far-away.east 'x11vnc -localhost -display :0'
</pre>

(you will likely have to provide passwords/passphrases to login from `sitting-here` into your `far-away.east` Unix account; we assume you have a login account on `far-away.east` and it is running the SSH server)

And then in another terminal window on `sitting-here` run the command:

<pre>  sitting-here> vncviewer -encodings "copyrect tight zrle hextile" localhost:0
</pre>

**_<font color="bisque4">Note:</font>_** The `-encodings` option is **_very_** important: **vncviewer** will often default to "raw" encoding if it thinks the connection is to the local machine, and so **vncviewer** gets tricked this way by the ssh redirection. "raw" encoding will be _extremely_ slow over a networked link, so you need to force the issue with `-encodings "copyrect tight ..."`. Nowadays, not all viewers use the `-encodings` option, try "`-PreferredEncoding=ZRLE`" (although the newer viewers seem to autodetect well when to use raw or not.)

Note that "`x11vnc -localhost ...`" limits incoming vncviewer connections to only those from the same machine. This is very natural for `ssh` tunnelling (the redirection appears to come from the same machine.) Use of a [VNC password](#vnc_password_file) is also strongly recommended.

Note also the `-t` we used above (force allocate pseudoterminal), it actually seems to improve interactive typing response via VNC!

You may want to add the `-C` option to `ssh` to enable compression. The VNC compression is not perfect, and so this may help a bit. However, over a fast LAN you probably don't want to enable SSH compression because it can slow things down. Try both and see which is faster.

If your username is different on the remote machine use something like: "`fred@far-away.east`" in the above `ssh` command line.

Some VNC viewers will do the `ssh` tunnelling for you automatically, the TightVNC Unix `vncviewer` does this when the "`-via far-away.east`" option is supplied to it (this requires **x11vnc** to be already running on `far-away.east` or having it started by [`inetd(8)`](faq.html#faq-inetd).) See the 3rd script example [below](#tightvnc_via) for more info.

_**SSVNC:**_  You may also want to look at the [Enhanced TightVNC Viewer (ssvnc)](ssvnc.html) bundles because they contain scripts and GUIs to automatically set up SSH tunnels (e.g. the GUI, "`ssvnc`", does it automatically and so does this command: "`ssvnc_cmd -ssh user@far-away.east:0`") and can even start up **x11vnc** as well.

The [Terminal Services](ssvnc.html#tsvnc) mode of SSVNC is perhaps the easiest way to use **x11vnc**. You just need to have **x11vnc** available in $PATH on the remote side (and can SSH to the host), and then on the viewer-side you type something like:

<pre>  tsvnc fred@far-away.east
</pre>

everything else is done automatically for you. Normally this will start a virtual Terminal Services X session (RAM-only), but if you already have a real X session up on the physical hardware it will find that one for you.

_**Gateways:**_  If the machine you SSH into is not the same machine with the X display you wish to view (e.g. your company provides incoming SSH access to a gateway machine), then you need to change the above to, e.g.: "`-L 5900:OtherHost:5900`":

<pre>  sitting-here> ssh -t -L 5900:OtherHost:5900 gateway.east
</pre>

Where `gateway.east` is the internet hostname (or IP) of the gateway machine (SSH server.) 'OtherHost' might be, e.g., `freds-pc` or `192.168.2.33` (it is OK for these to be private hostnames or private IP addresses, the host in `-L` is relative to the remote server side.)

Once logged in, you'll need to do a second login (`ssh`, `rsh`, etc.) to the workstation machine 'OtherHost' and then start up **x11vnc** on it (if it isn't already running.) (The "[`-connect gateway:59xx`](x11vnc_opts.html#opt-connect)" option may be another alternative here with the viewer already in `-listen` mode.) For an automatic way to use a gateway and have all the network traffic encrypted (including inside the firewall) see [Chaining SSH's](chainingssh.html).

These gateway access modes also can be done automatically for you via the "Proxy/Gateway" setting in [SSVNC](ssvnc.html) (including the Chaining SSH's case, "Double Proxy".)

<a name="firewalls"></a>_**Firewalls/Routers:**_ 

A lot of people have inexpensive devices for home or office that act as a Firewall and Router to the machines inside on a private LAN. One can usually configure the Firewall/Router from inside the LAN via a web browser.

Often having a Firewall/Router sitting between the vncviewer and **x11vnc** will make it impossible for the viewer to connect to **x11vnc**.

One thing that can be done is to redirect a port on the Firewall/Router to, say, the SSH port (22) on an inside machine (how to do this depends on your particular Firewall/Router, often the router config URL is `http://192.168.100.1` See [www.portforward.com](http://www.portforward.com/routers.htm) for more info.) This way you reach these computers from anywhere on the Internet and use **x11vnc** to view X sessions running on them.

Suppose you configured the Firewall/Router to redirect these ports to two internal machines:

<pre>  Port 12300 -> 192.168.1.3, Port 22 (SSH)
  Port 12301 -> 192.168.1.4, Port 22 (SSH)
</pre>

(where `192.168.1.3` is "jills-pc" and `192.168.1.4` is "freds-pc".) Then the ssh's would look something like:

<pre>  sitting-here> ssh -t -p 12300 -L 5900:localhost:5900 jill@far-away.east 'x11vnc -localhost -display :0'
  sitting-here> ssh -t -p 12301 -L 5900:localhost:5900 fred@far-away.east 'x11vnc -localhost -display :0'
</pre>

Where `far-away.east` means the hostname (or IP) that the Router/Firewall is using (for home setups this is usually the IP gotten from your ISP via DHCP, the site [http://www.whatismyip.com/](http://www.whatismyip.com/) is a convenient way to determine what it is.)

It is a good idea to add some obscurity to accessing your system via SSH by using some high random port (e.g. 12300 in the above example.) If you can't remember it, or are otherwise not worried about port scanners detecting the presence of your SSH server and there is just one internal PC involved you could map 22:

<pre>  Port 22 -> 192.168.1.3, Port 22 (SSH)
</pre>

Again, this SSH gateway access can be done automatically for you via the "Proxy/Gateway" setting in [SSVNC](ssvnc.html). And under the "Remote SSH Command" setting you can enter the `x11vnc -localhost -display :0`.

_Host-Level-Firewalls:_ even with the hardware Firewall/Router problem solved via a port redirection, most PC systems have their own Host level "firewalls" enabled to protect users from themselves. I.e. the system itself blocks all incoming connections. So you will need to see what is needed to configure it to allow in the port (e.g. 22) that you desire. E.g. Yast, Firestarter, `iptables(1)`, etc..

_VNC Ports and Firewalls:_ The above discussion was for configuring the Firewall/Router to let in port 22 (SSH), but the same thing can be done for the default VNC port 5900:

<pre>  Port 5900 -> 192.168.1.3, Port 5900 (VNC)
  Port 5901 -> 192.168.1.4, Port 5900 (VNC)
</pre>

(where `192.168.1.3` is "jills-pc" and `192.168.1.4` is "freds-pc".) This could be used for normal, unencrypted connections and also for [SSL encrypted ones](#ssl-tunnel).

The VNC displays to enter in the VNC viewer would be, say, "`far-away.east:0`" to reach jills-pc and "`far-away.east:1`" to reach freds-pc. We assume above that **x11vnc** is using port 5900 (and any Host-Level-firewalls on jills-pc has been configured to let that port in.) Use the "[`-rfbport`](x11vnc_opts.html#opt-rfbport)" option to tell which port x11vnc should listen on.

For a home system one likely does not have a hostname and would have to use the IP address, say, "`24.56.78.93:0`". E.g.:

<pre>  vncviewer 24.56.78.93:0
</pre>

You may want to choose a more obscure port on the router side, e.g. 5944, to avoid a lot of port scans finding your VNC server. For 5944 you would tell the viewer to use:

<pre>  vncviewer 24.56.78.93:44
</pre>

The IP address would need to be communicated to the person running the VNC Viewer. The site [http://www.whatismyip.com/](http://www.whatismyip.com/) can help here.

* * *

**_Scripts to automate ssh tunneling:_** As discussed below, there may be some problems with port 5900 being available. If that happens, the above port and display numbers may change a bit (e.g. -> 5901 and :1). However, if you "know" port 5900 will be free on the local and remote machines, you can easily automate the above two steps by using the **x11vnc** option [`-bg`](x11vnc_opts.html#opt-bg) (forks into background after connection to the display is set up) or using the `-f` option of `ssh`. Some example scripts are shown below. Feel free to try the ssh `-C` to enable its compression and see if that speeds things up noticeably.

* * *

**#1.** A simple example script, assuming no problems with port 5900 being taken on the local or remote sides, looks like:

<pre>#!/bin/sh
# usage: x11vnc_ssh <host>:<xdisplay>
#  e.g.: x11vnc_ssh snoopy.peanuts.com:0
#  (user@host:N also works)

host=`echo $1 | awk -F: '{print $1}'`
disp=`echo $1 | awk -F: '{print $2}'`
if [ "x$disp" = "x" ]; then disp=0; fi

cmd="x11vnc -display :$disp -localhost -rfbauth .vnc/passwd"
enc="copyrect tight zrle hextile zlib corre rre raw"

ssh -f -t -L 5900:localhost:5900 $host "$cmd"

for i in 1 2 3
do
        sleep 2
        if vncviewer -encodings "$enc" :0; then break; fi
done
</pre>

See also **rx11vnc.pl** below.

* * *

**#2.** Another method is to start the VNC viewer in listen mode "`vncviewer -listen`" and have **x11vnc** initiate a _reverse_ connection using the [`-connect`](x11vnc_opts.html#opt-connect) option:

<pre>#!/bin/sh
# usage: x11vnc_ssh <host>:<xdisplay>
#  e.g.: x11vnc_ssh snoopy.peanuts.com:0
#  (user@host:N also works)

host=`echo $1 | awk -F: '{print $1}'`
disp=`echo $1 | awk -F: '{print $2}'`
if [ "x$disp" = "x" ]; then disp=0; fi

cmd="x11vnc -display :$disp -localhost -connect localhost"   # <== note new option
enc="copyrect tight zrle hextile zlib corre rre raw"

vncviewer -encodings "$enc" -listen &
pid=$!
ssh -t -R 5500:localhost:5500 $host "$cmd"
kill $pid
</pre>

Note the use of the `ssh` option "`-R`" instead of "`-L`" to set up a remote port redirection.

<a name="tightvnc_via"></a>

* * *

**#3.** A third way is specific to the TightVNC `vncviewer` special option `-via` for gateways. The only tricky part is we need to start up **x11vnc** and give it some time (5 seconds in this example) to start listening for connections (so we cannot use the TightVNC default setting for `VNC_VIA_CMD`):

<pre>#!/bin/sh
# usage: x11vnc_ssh <host>:<xdisplay>
#  e.g.: x11vnc_ssh snoopy.peanuts.com:0

host=`echo $1 | awk -F: '{print $1}'`
disp=`echo $1 | awk -F: '{print $2}'`
if [ "x$disp" = "x" ]; then disp=0; fi

VNC_VIA_CMD="ssh -f -t -L %L:%H:%R %G x11vnc -localhost -rfbport 5900 -display :$disp; sleep 5" 
export VNC_VIA_CMD

vncviewer -via $host localhost:0      # must be TightVNC vncviewer.
</pre>

Of course if you already have the **x11vnc** running waiting for connections (or have it started out of [`inetd(8)`](faq.html#faq-inetd)), you can simply use the TightVNC "`vncviewer -via gateway host:port`" in its default mode to provide secure `ssh` tunnelling.

* * *

<a name="vnc_password_file"></a>**_VNC password file:_** Also note in the **#1.** example script that the [option](x11vnc_opts.html#opt-rfbauth) "`-rfbauth .vnc/passwd`" provides additional protection by requiring a VNC password for every VNC viewer that connects. The `vncpasswd` or `storepasswd` programs, or the **x11vnc** [`-storepasswd` option](faq.html#faq-passwd) can be used to create the password file. **x11vnc** also has the slightly less secure [`-passwdfile`](faq.html#faq-passwdfile) and "`-passwd XXXXX`" [options](x11vnc_opts.html#opt-passwdfile) to specify passwords.

**_<font color="red">Very Important:</font>_** It is up to _**YOU**_ to tell **x11vnc** to use password protection (`-rfbauth` or `-passwdfile`), it will NOT do it for you automatically or force you to (use [`-usepw`](x11vnc_opts.html#opt-usepw) if you want to be forced to.) The same goes for encrypting the channel between the viewer and **x11vnc**: it is up to you to use `ssh`, `stunnel`, [`-ssl`](x11vnc_opts.html#opt-ssl) mode, a VPN, etc. (use the [Enhanced TightVNC Viewer (SSVNC)](ssvnc.html) GUI if you want to be forced to use SSL or SSH.) For additional safety, also look into the `-allow` and `-localhost` [options](faq.html#faq-allow-opt) and building **x11vnc** with [tcp_wrappers support](faq.html#faq-tcp_wrappers) to limit host access.

* * *

<a name="ssl-tunnel"></a>

#### Tunnelling x11vnc via SSL/TLS:

One can also encrypt the VNC traffic using an SSL/TLS tunnel such as [stunnel.mirt.net](http://stunnel.mirt.net) (also [stunnel.org](http://www.stunnel.org)) or using the built-in (Mar/2006) [`-ssl`](x11vnc_opts.html#opt-ssl) openssl mode. A SSL-enabled Java applet VNC Viewer is also provided in the **x11vnc** package (and https can be used to download it.)

Although not as ubiquitous as `ssh`, SSL tunnelling still provides a useful alternative. See [this FAQ on -ssl and -stunnel modes](faq.html#faq-ssl-tunnel-int) for details and examples.

The [Enhanced TightVNC Viewer (SSVNC)](ssvnc.html) bundles contain some convenient utilities to automatically set up an SSL tunnel from the viewer-side (i.e. to connect to "`x11vnc -ssl ...`".) And many other enhancements too.

* * *

<a name="downloading"></a>

#### Downloading x11vnc:

**x11vnc** is a contributed program to the [LibVNCServer project](http://sourceforge.net/projects/libvncserver/) at SourceForge.net. I use `libvncserver` for all of the VNC aspects; I couldn't have done without it. The full source code may be found and downloaded (either file-release tarball or GIT tree) from the above link. As of Sep 2011, the [x11vnc-0.9.13.tar.gz source package is released (_recommended download_)](http://sourceforge.net/projects/libvncserver/files/x11vnc/0.9.13/). The [x11vnc 0.9.13 release notes](http://sourceforge.net/projects/libvncserver/files/x11vnc/0.9.13/README.txt/view).

The `x11vnc` package is the subset of the `libvncserver` package needed to build the **x11vnc** program. Also, you can get a copy of my latest, bleeding edge [`x11vnc-0.9.14-dev.tar.gz` tarball](http://x11vnc.sourceforge.net/dev/x11vnc-0.9.14-dev.tar.gz) to build the most up to date one.

**_Precompiled Binaries/Packages:_**  See the [FAQ below](faq.html#faq-binaries) for information about where you might obtain a precompiled **x11vnc** binary from 3rd parties and some ones I create.

**_VNC Viewers:_**  To obtain VNC viewers for the viewing side (Windows, Mac OS, or Unix) try these links:

*   [http://www.tightvnc.com/download.html](http://www.tightvnc.com/download.html)
*   [http://www.realvnc.com/download-free.html](http://www.realvnc.com/products/free/4.1/download.html)
*   [http://sourceforge.net/projects/cotvnc/](http://sourceforge.net/projects/cotvnc/)
*   [http://www.ultravnc.com/](http://www.ultravnc.com/)
*   [Our Enhanced TightVNC Viewer (SSVNC)](ssvnc.html)

    ![](ssvnc.gif)

**_More tools_**: Here is a `ssh/rsh` wrapper script **rx11vnc** that attempts to automatically do the above Steps 1-3 for you (provided you have `ssh/rsh` login permission on the machine **x11vnc** is to be run on.) The above example would be: "`rx11vnc far-away.east:0`" typed into a shell on `sitting-here.west`. Also included is an experimental script **rx11vnc.pl** that attempts to tunnel the vnc traffic through an ssh port redirection (and does not assume port 5900 is free.) Have a look at them to see what they do and customize as needed:

*   [rx11vnc wrapper script](rx11vnc)
*   [rx11vnc.pl wrapper script to tunnel traffic thru ssh](rx11vnc.pl)

* * *

<a name="building"></a>

#### Building x11vnc:

Make sure you have all the needed [build/compile/development](faq.html#faq-build) packages installed (e.g. Linux distributions foolishly don't install them by default.) See this [build FAQ](faq.html#faq-build) for more details.

If your OS has `libjpeg.so` and `libz.so` in standard locations you can build as follows (example given for the `0.9.13` release of **x11vnc**: replace with the version you downloaded):

<pre>(un-tar the x11vnc+libvncserver tarball)
# gzip -dc x11vnc-0.9.13.tar.gz | tar -xvf -

(cd to the source directory)
# cd x11vnc-0.9.13

(run configure and then run make)
# ./configure
# make

(if all went OK, copy x11vnc to the desired destination, e.g. $HOME/bin)
# cp ./x11vnc/x11vnc $HOME/bin
</pre>

Or do `make install`, it will probably install to `/usr/local/bin` (run `./configure --help` for information on customizing your configuration, e.g. `--prefix=/my/place`.) You can now run it via typing "`x11vnc`", "`x11vnc -help | more`", "`x11vnc -forever -shared -display :0`", etc.

**_<font color="bisque4">Note:</font>_** Currently gcc is recommended to build `libvncserver`. In some cases it will build with non-gcc compilers, but the resulting binary sometimes fails to run properly. For Solaris pre-built `gcc` binaries are at [http://www.sunfreeware.com/](http://www.sunfreeware.com/). Some Solaris pre-built `x11vnc` binaries are [here](bins).

However, one user reports it does work fine when built with Sun Studio 10, so YMMV. In fact, here is a little build script to do this on Solaris 10:

<pre>#!/bin/sh
PATH=/usr/ccs/bin:/opt/SUNWspro/bin:$PATH; export PATH

CC='cc' \
CFLAGS='-xO4' \
LDFLAGS='-L/usr/sfw/lib -L/usr/X11/lib -R/usr/sfw/lib -R/usr/X11/lib' \
CPPFLAGS='-I /usr/sfw/include -I/usr/X11/include' \
./configure

MAKE="make -e"
AM_CFLAGS=""
export MAKE AM_CFLAGS
$MAKE
</pre>

In general you can use the "`make -e`" trick if you don't like libvncserver's choice of `AM_CFLAGS`. See the [build scripts](#solarisbuilding) below for more ideas. Scripts similar to the above have been shown to work with vendor C compilers on HP-UX (ccom: HP92453-01) and Tru64 (Compaq C V6.5-011.)

You can find information on [Misc. Build problems here](miscbuild.html).

* * *

<a name="solarisbuilding"></a>**Building on Solaris, FreeBSD, etc:**   Depending on your version of Solaris or other Unix OS the jpeg and/or zlib libraries may be in non-standard places (_e.g._ `/usr/local`, `/usr/sfw`, `/opt/sfw`, etc.)

**_<font color="bisque4">Note:</font>_** If `configure` cannot find these two libraries then TightVNC and ZRLE encoding support will be disabled, and you don't want that!!! The TightVNC encoding gives very good compression and performance, it even makes a noticeable difference over a fast LAN.

<a name="solaris10-build"></a>**_<font color="bisque4">Shortcuts:</font>_** On _Solaris 10_ you can pick up almost everything just by insuring that your `PATH` has `/usr/sfw/bin` (for gcc) and `/usr/ccs/bin` (for other build tools), e.g.:

<pre>  env PATH=/usr/sfw/bin:/usr/ccs/bin:$PATH sh -c './configure; make'
</pre>

(The only thing this misses is `/usr/X11/lib/libXrandr.so.2`, which is for the little used `-xrandr` option, see the script below to pick it up as well.)

<a name="solaris9-build"></a>`libjpeg` is included in Solaris 9 and later (`/usr/sfw/include` and `/usr/sfw/lib`), and `zlib` in Solaris 8 and later (`/usr/include` and `/usr/lib`.) So on _Solaris 9_ you can pick up everything with something like this:

<pre>  env PATH=/usr/local/bin:/usr/ccs/bin:$PATH sh -c './configure --with-jpeg=/usr/sfw; make'
</pre>

assuming your `gcc` is in `/usr/local/bin` and **x11vnc** 0.7.1 or later. These are getting pretty long, see those assignments split up in the build script below.

If your system does not have these libraries at all you can get the source for the libraries to build them: `libjpeg` is available at [ftp://ftp.uu.net/graphics/jpeg/](ftp://ftp.uu.net/graphics/jpeg/) and `zlib` at [http://www.gzip.org/zlib/](http://www.gzip.org/zlib/). See also [http://www.sunfreeware.com/](http://www.sunfreeware.com/) for Solaris binary packages of these libraries as well as for `gcc`. Normally they will install into `/usr/local` but you can install them anywhere with the `--prefix=/path/to/anywhere`, etc.

Here is a build script that indicates one way to pass the library locations information to the `libvncserver` configuration via the `CPPFLAGS` and `LDFLAGS` environment variables.

<pre>---8<---8<---8<---8<---8<---8<---8<---8<---8<---8<---8<---8<---8<---8<---8<---8<---
#!/bin/sh

# Build script for Solaris, etc, with gcc, libjpeg and libz in
# non-standard locations.

# set to get your gcc, etc:
#
PATH=/path/to/gcc/bin:/usr/ccs/bin:/usr/sfw/bin:$PATH

JPEG=/path/to/jpeg	# set to maybe "/usr/local", "/usr/sfw", or "/opt/sfw"
ZLIB=/path/to/zlib	# set to maybe "/usr/local", "/usr/sfw", or "/opt/sfw"

# Below we assume headers in $JPEG/include and $ZLIB/include and the
# shared libraries are in $JPEG/lib and $ZLIB/lib.  If your situation
# is different change the locations in the two lines below.
#
CPPFLAGS="-I $JPEG/include -I $ZLIB/include" 
LDFLAGS="-L$JPEG/lib -R $JPEG/lib -L$ZLIB/lib -R $ZLIB/lib" 

# These two lines may not be needed on more recent Solaris releases:
#
CPPFLAGS="$CPPFLAGS -I /usr/openwin/include"
LDFLAGS="$LDFLAGS -L/usr/openwin/lib -R /usr/openwin/lib"

# These are for libXrandr.so on Solaris 10:
#
CPPFLAGS="$CPPFLAGS -I /usr/X11/include"
LDFLAGS="$LDFLAGS -L/usr/X11/lib -R /usr/X11/lib"

# Everything needs to built with _REENTRANT for thread safe errno:
#
CPPFLAGS="$CPPFLAGS -D_REENTRANT"

export PATH CPPFLAGS LDFLAGS

./configure
make

ls -l ./x11vnc/x11vnc

---8<---8<---8<---8<---8<---8<---8<---8<---8<---8<---8<---8<---8<---8<---8<---8<---
</pre>

Then do `make install` or copy the `x11vnc` binary to your desired destination.

BTW, To run a shell script, just cut-and-paste the above into a file, say "`myscript`", then modify the "`/path/to/...`" items to correspond to your system/environment, and then type: "`sh myscript`" to run it.

Note that on Solaris `make` is `/usr/ccs/bin/make`, so that is why the above puts `/usr/ccs/bin` in `PATH`. Other important build utilities are there too: `ld`, `ar`, etc. Also, it is probably a bad idea to have `/usr/ucb` in your `PATH` while building.

Starting with the 0.7.1 **x11vnc** release the "`configure --with-jpeg=DIR --with-zlib=DIR`" options are handy if you want to avoid making a script.

If you need to link OpenSSL `libssl.a` on Solaris see this [method](#build-openssl).

If you need to build on Solaris 2.5.1 or earlier or other older Unix OS's, see [this workaround FAQ](faq.html#faq-solaris251build).

**Building on FreeBSD, OpenBSD, ...:**   The jpeg libraries seem to be in `/usr/local` or `/usr/pkg` on these OS's. You won't need the openwin stuff in the above script (but you may need `/usr/X11R6/...`.) Also starting with the 0.7.1 **x11vnc** release, this usually works:

<pre>  ./configure --with-jpeg=/usr/local
  make
</pre>

**Building on HP-UX:**   For jpeg and zlib you will need to do the same sort of thing as described above for Solaris. You set `CPPFLAGS` and `LDFLAGS` to find them (see below for an example.) You do not need to do any of the above `/usr/openwin` stuff. Also, HP-UX does not seem to support `-R`, so get rid of the `-R` items in `LDFLAGS`. Because of this, at runtime you may need to set `LD_LIBRARY_PATH` or `SHLIB_PATH` to indicate the directory paths so the libraries can be found. It is a good idea to have static archives, e.g. `libz.a` and `libjpeg.a` for the nonstandard libraries so that they get bolted into the `x11vnc` binary (and so won't get "lost".)

Here is what we recently did to build **x11vnc** 0.7.2 on HP-UX 11.11

<pre>./configure --with-jpeg=$HOME/hpux/jpeg --with-zlib=$HOME/hpux/zlib
make
</pre>

Where we had static archives (libjpeg.a, libz.a) only and header files in the $HOME/hpux/... directories as discussed for the build script.

On HP-UX 11.23 and 11.31 we have had problems compiling with gcc. "`/usr/include/rpc/auth.h:87: error: field 'syncaddr' has incomplete type`". As a workaround for **x11vnc** 0.9.4 and later set your `CPPFLAGS` to include:

<pre>  CPPFLAGS="-DIGNORE_GETSPNAM"
  export CPPFLAGS
</pre>

This disables a very rare usage mode for `-unixpw_nis` by not trying `getspnam(3)`.

Using HP-UX's C compiler on 11.23 and 11.31 we have some severe compiler errors that have not been worked around yet. If you need to do this, contact me and I will give you a drastic recipe that will produce a working binary.

**Building on AIX:**   AIX: one user had to add the "X11.adt" package to AIX 4.3.3 and 5.2 to get build header files like `XShm.h`, etc. You may also want to make sure that `/usr/lpp/X11/include`, etc is being picked up by the configure and make.

For a recent build on AIX 5.3 we needed to add these `CFLAGS` to be able to build with gcc:

<pre>  env CFLAGS='-maix64 -Xlinker -bbigtoc' ./configure ...
</pre>

we also built our own libjpeg and libz using `-maix64`.

BTW, one way to run an Xvfb-like virtual X server for testing on AIX is something like "`/usr/bin/X11/X -force -vfb -ac :1`".

**Building on Mac OS X:**   There is now [native Mac OS X](faq.html#faq-macosx) support for **x11vnc** by using the raw framebuffer feature. This mode does not use or need X11 at all. To build you may need to disable X11:

<pre>./configure --without-x ...
make
</pre>

However, if your system has the Mac OS X build package for X11 apps you will not need to supply the "`--without-x`" option (in this case the resulting **x11vnc** would be able to export both the native Mac OS X display and windows displayed in the XDarwin X server.) Be sure to include the `./configure` option to find `libjpeg` on your system.

<a name="build-openssl"></a>**OpenSSL:**   Starting with version 0.8.3 **x11vnc** can now be built with [SSL/TLS support](faq.html#faq-ssl-tunnel-int). For this to be enabled the `libssl.so` library needs to be available at build time. So you may need to have additional `CPPFLAGS` and `LDFLAGS` items if your `libssl.so` is in a non-standard place. As of **x11vnc** 0.9.4 there is also the `--with-ssl=DIR` configure option.

On Solaris using static archives `libssl.a` and `libcrypto.a` instead of .so shared libraries (e.g. from www.sunfreeware.com), we found we needed to also set `LDFLAGS` as follows to get the configure to work:

<pre>env LDFLAGS='-lsocket -ldl' ./configure --with-ssl=/path/to/openssl ...
make
</pre>

* * *

<a name="beta-test"></a>

#### Beta Testing:

I don't have any formal beta-testers for the releases of **x11vnc**, so I'd appreciate any additional testing very much.

Thanks to those who suggested features and helped beta test **x11vnc** 0.9.13 released in Sep 2011!

Please help test and debug the 0.9.14 version for release sometime in Winter 2011.

The version 0.9.14 beta tarball is kept here:    [x11vnc-0.9.14-dev.tar.gz](http://x11vnc.sourceforge.net/dev/x11vnc-0.9.14-dev.tar.gz)

There are also some Linux, Solaris, Mac OS X, and other OS test binaries [here](bins). Please kick the tires and report bugs, performance regressions, undesired behavior, etc. to me.

To aid testing of the [built-in SSL/TLS support](faq.html#faq-ssl-tunnel-int) for **x11vnc**, a number of VNC Viewer packages for Unix, Mac OS X, and Windows have been created that provide SSL Support for the TightVNC Viewer (this is done by [wrapper scripts](faq.html#infaq_ss_vncviewer) and a GUI that starts [STUNNEL](faq.html#faq-ssl-tunnel-ext).) It should be pretty convenient for automatic SSL and SSH connections. It is described in detail at and can be downloaded from the [Enhanced TightVNC Viewer (SSVNC)](ssvnc.html) page. The SSVNC Unix viewer also supports x11vnc's symmetric key [encryption ciphers](x11vnc_opts.html#opt-enc) (see the 'UltraVNC DSM Encryption Plugin' settings panel.)

Here are some features that will appear in the 0.9.14 release:

*   Apple removed OpenGL screen capture in Mac OS X Lion. We plan to find a workaround in this x11vnc release. As of Nov/2011 we believe we have: please try out the 'MACOSX_10.6_OR_LATER' test binaries in our download area. If it works for you on macosx Lion, please let me know (I don't have access to a macosx lion machine.) Also: one can set '`-env X11VNC_DEBUG_OPENGL=1`' to get some debugging info printed out for OpenGL on macosx.
*   One can set '`-env X11VNC_NO_IDENT_USERNAME=1`' to have x11vnc skip trying to use the identd service (port 113) to get a name for the user at the vncviewer. This can speed up connections, especially when starting many viewer connections at once (e.g. classroom broadcast.)
*   There is a bug in the Xorg server introduced in 2009 for multiscreen displays that make it so x11vnc cannot send pointer motion events properly via `XTestFakeMotionEvent` to a screen that does not have the current focus. x11vnc now tries to automatically work around this bug by detecting multiple screens and enabling `[-xwarppointer](x11vnc_opts.html#opt-xwarppointer)`.
*   Some additional checks are taken in `[-inetd](x11vnc_opts.html#opt-inetd)` mode to see if the connection is over IPV6.
*   `-env X11VNC_ALLOW_FULLMATCH=1` now works for localhost including IPV6 '::1'
*   One can set `-env X11VNC_DEBUG_SEND_CLIENT_INFO=1` to debug the client info communication channel with the gui. A bug has been fixed for this channel for many simultaneous viewers.

Here are some features that appeared in the 0.9.13 release (Sep/2011):

*   Improved support for non-X11 touchscreen devices (e.g. handheld or cell phone) via Linux uinput input injection. Additional tuning parameters are added. TSLIB touchscreen calibration is supported. Tested on Qtmoko Neo Freerunner. A tool, misc/uinput.pl, is provided to diagnose uinput behavior on new devices. The env. vars. X11VNC_UINPUT_BUS and X11VNC_UINPUT_VERSION are available if leaving them unset does not work.
*   The Linux uinput non-X11 input injection can now be bypassed: events can be directly written to the /dev/input/event devices specified by the user (direct_abs=..., etc.) A `[-pipeinput](x11vnc_opts.html#opt-pipeinput)` input injection helper script, misc/qt_tslib_inject.pl is provided as a tweakable non-builtin direct input injection method.
*   The list of new uinput parameters for the above two features is: pressure, tslib_cal, touch_always, dragskip, btn_touch; direct_rel, direct_abs, direct_btn, direct_key.
*   The MacOSX native server can now use OpenGL for the screen capture (glReadPixels().) In nearly all cases this is faster than the raw framebuffer capture method. Sadly, it appears that MacOSX 10.7 (Lion) has broken or removed OpenGL screen capture support. Set X11VNC_DEBUG_OPENGL=n to print out more debugging info. There are build and run time flags, X11VNC_MACOSX_NO_DEPRECATED, etc. to disable use of deprecated input injection and screen access interfaces. Cursor shape now works for 64bit binaries.
*   The `[-unixsock](x11vnc_opts.html#opt-unixsock)` and `[-unixsockonly](x11vnc_opts.html#opt-unixsockonly)` options enable listening on a unix socket instead of TCP. This can enable interesting tunnelling modes.
*   The `[-inetd](x11vnc_opts.html#opt-inetd)` option can now work directly with raw stdio as long as the file descriptor is opened O_RDWR; if it is not then x11vnc's internal helper '-enc none' is used.
*   The libvncserver bundled with x11vnc can now handle non AF_INET sockets passed to it, and even non socket file descriptors in some cases.
*   The included SSL enabled Java VNC Viewers now handle Mouse Wheel events.
*   **miscellaneous new features and changes:**
*   In `[-reflect](x11vnc_opts.html#opt-reflect)` mode, the libvncclient connection can now have the pixel format modified via the environment variables X11VNC_REFLECT_bitsPerSample, X11VNC_REFLECT_samplesPerPixel, and X11VNC_REFLECT_bytesPerPixel
*   In `[-create](x11vnc_opts.html#opt-create)` mode the following environment variables are added to fine tune the behavior: FIND_DISPLAY_NO_LSOF: do not use lsof(1) to try to determine the Linux VT, FIND_DISPLAY_NO_VT_FIND: do not try to determine the Linux VT at all, X11VNC_CREATE_LC_ALL_C_OK: do not bother undoing the setting LC_ALL=C that the create_display script sets. The performance of the -create script has been improved for large installations (100's of user sessions on one machine.)
*   In `[-unixpw](x11vnc_opts.html#opt-unixpw)` mode, one can now Tab from login: to Password.
*   An environment variable, X11VNC_SB_FACTOR, allows one to scale the `[-sb](x11vnc_opts.html#opt-sb)` screenblank sleep time from the default 2 secs.
*   In -rawfb mode, a bug is fixed in setting the number of bits per pixel.
*   Documented that `[-grabkbd](x11vnc_opts.html#opt-grabkbd)` is no longer working with some/most window managers (it can prevent resizing and menu posting.)
*   The macosx deprecated interface GetMainDevice() call is removed. Compile with -DX11VNC_MACOSX_USE_GETMAINDEVICE if needed for an old macosx version...
*   -unixpw check mode '%stdin2' for two line user than passwd.
*   Fix race condition in tkx11vnc gui where the comm file may be deleted before tail opens it. TKX11VNC_SHOW_LSOF=1 for open file info. Clear some query cases.
*   Fix bug with pointer position when -clip and -scale are both specified.
*   Fix bug with mouse cursor shape in -reflect mode on 64-bit machines. X11VNC_DEBUG_REFLECT=1 env. var. Do not use CopyRect in -reflect mode with -clip active.
*   Fix bug that send CopyRect updates to non-CopyRect clients such as VNC2Go. Also correct copyrect events for clients that support copyrect but ask for partial screen updates. See also X11VNC_DEBUG_COPYRECT=1 and X11VNC_FORCE_COPYRECT=1
*   For testing and workaround with non-Copyrect clients like old VNC2Go set X11VNC_SKIP_cursor_noshape_updates_clients=1
*   For -allow modes set X11VNC_DEBUG_ACCESS=1 and also X11VNC_ALLOW_FULLMATCH=1\. Unix sockets can also be filtered via -allow.

Here are some features that appeared in the 0.9.12 release (Sep/2010):

*   One can now specify the maximum number of displays that can be created in -create mode via the env. var. X11VNC_CREATE_MAX_DISPLAYS
*   The X11VNC_NO_LIMIT_SHM env. var. is added to skip any automatic shared memory reduction.
*   The kdm display manager is now detected when trying not to get killed by the display manager.
*   A compile time bug is fixed so that configuring using --with-system-libvncserver pointing to LibVNCServer 0.9.7 works again. A bug from forced use of Xdefs.h is worked around.

Here are some features that appeared in the 0.9.11 release (Aug/2010):

*   The source tree is synchronized with the most recent `libvncclient` (this only affects `[-reflect](x11vnc_opts.html#opt-reflect)` mode.) Build is fixed for incompatibilities when using an external LibVNCServer (e.g. `./configure --with-system-libvncserver...`) Please help test these build and runtime aspects and report back what you find, thanks.
*   The SSL enabled Java VNC Viewer Makefile has been modified so that the jar files that are built are compatible back to Java 1.4.
*   In `-create/-unixpw` mode, the env. var. `FD_USERPREFS` may be set to a filename in the user's home directory that includes default `username:options` values (so the options do not need to be typed every time at the login prompt.)
*   In `[-reflect](x11vnc_opts.html#opt-reflect)` mode cursor position updates are now handled correctly.

Here are some features that appeared in the 0.9.10 release (May/2010):

*   The included SSL enabled Java applet viewer now supports Chained SSL Certificates. The `debugCerts=yes` applet parameter aids troubleshooting certificate validation. The **x11vnc** `[-ssl](x11vnc_opts.html#opt-ssl)` mode has always supported [chained SSL certificates](ssl.html#chained-certificates) (simply put the intermediate certificates, in order, after the server certificate in the pem file.)
*   A demo CGI script [desktop.cgi](desktop.cgi.pl) shows how to create an SSL encrypted, multi-user **x11vnc** web login desktop service. The script **requires** x11vnc version 0.9.10. The user logs into a secure web site and gets his/her own virtual desktop ([Xvfb](faq.html#faq-xvfb).) **x11vnc**'s SSL enabled Java Viewer Applet is launched by the web browser for secure viewing (and so no software needs to be installed on the viewer-side.) One can use the desktop.cgi script for ideas to create their own fancier or customized web login desktop service (e.g. user-creation, PHP, SQL, specialized desktop application, etc.) More info [here.](http://www.karlrunge.com/x11vnc/faq.html#faq-web-login) There is also an optional 'port redirection' mode that allows redirection to other SSL enabled VNC servers running inside the firewall.
*   Built-in support for IPv6 (128 bit internet addresses) is now provided. See the [`-6`](x11vnc_opts.html#opt-6) and [`-connect`](x11vnc_opts.html#opt-connect) options for details. Additionally, in case there are still problems with built-in IPv6 support, a transitional tool is provided in [inet6to4](inet6to4) that allows x11vnc (or any other IPv4 application) to receive connections over [IPv6](faq.html#faq-ipv6).
*   The [`Xdummy`](Xdummy) wrapper script for Xorg's dummy driver is updated and no longer requires being run as root. New service options are provided to select `Xdummy` over `Xvfb` as the virtual X server to be created.
*   The "%" unix password verification tricks for the `[-unixpw](x11vnc_opts.html#opt-unixpw)` option are now documented. They have also been extended to run a command as the user if one sets the environment variable `UNIXPW_CMD`. The desktop.cgi demo script takes advantage of this new feature.
*   A bug has been fixed that would prevent the Java applet viewer from being downloaded successfully in single-port HTTPS/VNC inetd mode. The env. var. `X11VNC_HTTPS_DOWNLOAD_WAIT_TIME` can be used to adjust for how many seconds a `[-inetd](x11vnc_opts.html#opt-inetd)` or `[-https](x11vnc_opts.html#opt-https)` httpd download is waited for (default 15 seconds.) The applet will now autodetect x11vnc and use GET=1 for faster connecting. Many other improvements and fixes.
*   The TightVNC security type (TightVNC features enabler) now works for RFB version 3.8\.
*   The X property `X11VNC_TRAP_XRANDR` can be set on a desktop to force **x11vnc** to use the `[-xrandr](x11vnc_opts.html#opt-xrandr)` screen size change trapping code.
*   New remote control query options: `pointer_x`, `pointer_y`, `pointer_same`, `pointer_root`, and `pointer_mask`. A demo script using them `misc/panner.pl` is provided.
*   The `[-sslScripts](x11vnc_opts.html#opt-sslScripts)` option prints out the SSL certificate management scripts.

Here are some [Previous Release Notes](prevrels.html)

* * *

<a name="notes"></a>

#### Some Notes:

**Both a client and a server:**   It is sometimes confusing to people that **x11vnc** is _both_ a client and a server at the same time. It is an X client because it connects to the running X server to do the screen polls. Think of it as a rather efficient "screenshot" program running continuously. It is a server in the sense that it is a VNC server that VNC viewers on the network can connect to and view the screen framebuffer it manages.

When trying to debug problems, remember to think of _both_ roles. E.g. "how is x11vnc connecting to the X server?", "how is the vncviewer connecting to x11vnc?", "what permits/restricts the connection?". Both links may have reachability, permission, and other issues.

**Network performance:**   Whether you are using **Xvnc** or **x11vnc** it is always a good idea to have a solid background color instead of a pretty background image. _Each and every_ re-exposure of the background must be resent over the network: better to have that background be a solid color that compresses very well compared to a photo image. (This is one place where the X protocol has an advantage over the VNC protocol.) I suggest using `xsetroot`, `dtstyle` or similar utility to set a solid background while using **x11vnc**. You can turn the pretty background image back on when you are using the display directly. **Update**: As of Feb/2005 **x11vnc** has the [`-solid [color]`](x11vnc_opts.html#opt-solid) option that works on recent GNOME, KDE, and CDE and also on classic X (background image is on the root window.) **Update**: As of Oct/2007 **x11vnc** has the [`-ncache`](x11vnc_opts.html#opt-ncache) option that does a reasonable job caching the background (and other) pixmap data on the viewer side.

I also find the [TightVNC](http://www.tightvnc.com/) encoding gives the best response for my usage (Unix <-> Unix over cable modem.) One needs a tightvnc-aware vncviewer to take advantage of this encoding.

**TCP port issues:**   Notice the lines

<pre>  18/07/2003 14:36:31 Autoprobing selected port 5900
  PORT=5900
</pre>

in the output. 5900 is the default VNC listening port (just like 6000 is X11's default listening port.) Had port 5900 been taken by some other application, **x11vnc** would have next tried 5901\. That would mean the viewer command above should be changed to `vncviewer far-away.east:1`. You can force the port with the "[`-rfbport NNNN`](x11vnc_opts.html#opt-rfbport)" option where `NNNN` is the desired port number. If that port is already taken, **x11vnc** will exit immediately. The "[`-N`](x11vnc_opts.html#opt-N)" option will try to match the VNC display number to the X display.   (also see the "SunRay Gotcha" note below)

**Options:**   **x11vnc** has (far too) many features that may be activated via its [command line options](x11vnc_opts.html). Useful options are, e.g., `-scale` to do server-side scaling, and `-rfbauth passwd-file` to use VNC password protection (the `vncpasswd` or `storepasswd` programs, or the **x11vnc** [`-storepasswd`](faq.html#faq-passwd) option can be used to create the password file.)

**Algorithm:**   How does **x11vnc** do it? Rather brute-forcedly: it continuously polls the X11 framebuffer for changes using `XShmGetImage()`. When changes are discovered, it instructs `libvncserver` which rectangular regions of the framebuffer have changed, and `libvncserver` compresses the changes and sends them off to any connected VNC viewers. A number of applications do similar things, such as x0rfbserver, krfb, x0vncserver, vino. **x11vnc** uses a 32 x 32 pixel tile model (the desktop is decomposed into roughly 1000 such tiles), where changed tiles are found by pseudo-randomly polling 1 pixel tall horizontal scanlines separated vertically by 32 pixels. This is a surprisingly effective algorithm for finding changed regions. For keyboard and mouse user input the XTEST extension is used to pass the input events to the X server. To detect XBell "beeps" the XKEYBOARD extension is used. If available, the XFIXES extension is used to retrieve the current mouse cursor shape. Also, if available the X DAMAGE extension is used to receive hints from the X server where modified regions on the screen are. This greatly reduces the system load when not much is changing on the screen and also improves how quickly the screen is updated.

<a name="barbershop"></a>**Barbershop mirrors effect:**   What if **x11vnc** is started up, and **vncviewer** is then started up on _the same_ machine and displayed on _the same_ display **x11vnc** is polling? One might "accidentally" do this when first testing out the programs. You get an interesting recursive/feedback effect where **vncviewer** images keep popping up each one contained in the previous one and slightly shifted a bit by the window manager decorations. There will be an [even more interesting effect if `-scale` is used](recurse_x11vnc.jpg). Also, if the XKEYBOARD is supported and the XBell "beeps" once, you get an infinite loop of beeps going off. Although all of this is mildly exciting it is not much use: you will normally run and display the viewer on a different machine!

* * *

<a name="sunray-gotchas"></a>

#### Sun Ray Notes:

You can run **x11vnc** on your (connected or disconnected) [SunRay session](http://www.sun.com/sunray/index.html). Here are some [notes on SunRay usage](sunray.html) with **x11vnc**.

* * *

<a name="limitations"></a>

#### Limitations:

*   Due to the polling nature, some activities (opaque window moves, scrolling), can be pretty choppy/ragged and others (exposures of large areas) slow. Experiment with interacting a bit differently than you normally do to minimize the effects (_e.g._ do fullpage paging rather than line-by-line scrolling, and move windows in a single, quick motion.) Recent work has provided the [`-scrollcopyrect`](x11vnc_opts.html#opt-scrollcopyrect) and [`-wireframe`](x11vnc_opts.html#opt-wireframe) speedups using the `CopyRect` VNC encoding and other things, but they only speed up some activities, not all.

    <a name="fb_read_slow"></a>
*   A rate limiting factor for **x11vnc** performance is that graphics hardware is optimized for writing, not reading (**x11vnc** reads the video framebuffer for the screen image data.) The difference can be a factor of 10 to 1000, and so it usually takes about 0.5-1 sec to read in the whole video hardware framebuffer (e.g. 5MB for 1280x1024 at depth 24 with a read rate of 5-10MB/sec.) So whenever activity changes most of the screen (e.g. moving or iconifying a large window) there is a delay of 0.5-1 sec while **x11vnc** reads the changed regions in.

    A slow framebuffer read rate will often be the performance bottleneck on a fast LAN (whereas on slower links the reduced network bandwidth becomes the bottleneck.)

    Note: A quick way to get a 2X speedup of this for **x11vnc** is to switch your X server from depth 24 (32bpp) to depth 16 (16bpp.) You get a 4X speedup going to 8bpp, but the lack of color cells is usually unacceptable.

    To get a sense of the read and write speeds of your video card, you can run benchmarks like: "`x11perf -getimage500`",  "`x11perf -putimage500`",  "`x11perf -shmput500`" and for XFree86 displays with direct graphics access the "`dga`" command (press "b" to run the benchmark and then after a few seconds press "q" to quit.) Even this "`dd if=/dev/fb0 of=/dev/null`" often gives a good estimate. **x11vnc** also prints out its estimate:

    <pre>  28/02/2009 11:11:07 Autoprobing TCP port 
      28/02/2009 11:11:07 Autoprobing selected port 5900
      28/02/2009 11:11:08 fb read rate: 10 MB/sec
      28/02/2009 11:11:08 screen setup finished.
    </pre>

    We have seen a few cases where the hardware fb read speed is greater than 65 MB/sec: on high end graphics workstations from SGI and Sun, and also from a Linux user using nvidia proprietary drivers for his nvidia video card. _**Update 2008:**_ thankfully, these sped up drivers are becoming more common on Linux and *BSD systems and that makes **x11vnc** run somewhat more quickly. Sometimes they have a read rate of over 400 MB/sec.

    On XFree86/Xorg it is actually possible to increase the framebuffer read speed considerably (10-100 times) by using the Shadow Framebuffer (a copy of the framebuffer is kept in main memory and this can be read much more quickly.) To do this one puts the line `Option "ShadowFB" "true"` in the Device section of the `/etc/X11/XF86Config` or `/etc/X11/xorg.conf` file. Note that this _disables 2D acceleration_ at the physical display and so that might be unacceptable if one plays games, etc. on the machine's local display. Nevertheless this could be handy in some circumstances, e.g. if the slower speed while sitting at the physical display was acceptable (this seems to be true for most video cards these days.) Unfortunately it does not seem shadowfb can be turned on and off dynamically...

    Another amusing thing one can do is use `Xvfb` as the X server, e.g. "`xinit $HOME/.xinitrc -- /usr/X11R6/bin/Xvfb :1 -screen 0 1024x768x16`" **x11vnc** can poll `Xvfb` efficiently via main memory. It's not exactly clear why one would want to do this instead of using `vncserver/Xvnc`, (perhaps to take advantage of an **x11vnc** feature, such as framebuffer scaling or built-in SSL encryption), but we mention it because it may be of use for special purpose applications. You may need to use the "`-cc 4`" option to force `Xvfb` to use a TrueColor visual instead of DirectColor. See also the description of the [-create](faq.html#infaq_findcreatedisplay) option that does all of this automatically for you (be sure to install the Xvfb package, e.g. `apt-get install xvfb`.)

    Also, a faster and more accurate way is to use the "dummy" Xorg/XFree86 device driver (or our `Xdummy` wrapper script.) See [this FAQ](faq.html#faq-xvfb) for details.

*   Somewhat surprisingly, the X11 mouse (cursor) _shape_ is write-only and cannot be queried from the X server. So traditionally in **x11vnc** the cursor shape stays fixed at an arrow. (see the "`-cursor X`" and "`-cursor some`" [options](x11vnc_opts.html#opt-cursor), however, for a partial hack for the root window, etc.) However, on Solaris using the SUN_OVL overlay extension, **x11vnc** can show the correct mouse cursor when the [`-overlay`](x11vnc_opts.html#opt-overlay) option is also supplied. A similar thing is done on IRIX as well when `-overlay` is supplied.

    More generally, as of Dec/2004 **x11vnc** supports the new XFIXES extension (in Xorg and Solaris 10) to query the X server for the exact cursor shape, this works pretty well except that cursors with transparency (alpha channel) need to approximated to solid RGB values (some cursors look worse than others.)

*   Audio from applications is of course not redirected (separate redirectors do exist, e.g. **esd**, see [the FAQ on this](faq.html#faq-sound) below.) The `XBell()` "beeps" will work if the X server supports the XKEYBOARD extension. (Note that on Solaris XKEYBOARD is disabled by default. Passing `+kb` to **Xsun** enables it.)

*   The scroll detection algorithm for the [`-scrollcopyrect`](x11vnc_opts.html#opt-scrollcopyrect) option can give choppy or bunched up transient output and occasionally painting errors.

*   Using `-threads` can expose some bugs/crashes in `libvncserver`. However most of these have been fixed over the years.


-----
http://www.karlrunge.com/x11vnc/faq.html:


<a name="faq"></a><a name="faq0"></a>
[x11vnc Home](/x11vnc/)    [Donations](#faq-thanks)

* * *

#### x11vnc FAQ:

<font size="-0">**[Building and Starting]**</font>

[**Q-1:** <font color="#007f00">I can't get **x11vnc** to start up. It says "`XOpenDisplay failed (null)`" or "`Xlib: connection to ":0.0" refused by server Xlib: No protocol specified`" and then exits. What do I need to do?</font>](#faq-xperms)

[**Q-2:** <font color="#007f00">I can't get **x11vnc** and/or **libvncserver** to compile.</font>](#faq-build)

[**Q-3:** <font color="#007f00">I just built **x11vnc** successfully, but when I use it my keystrokes and mouse button clicks are ignored  (I am able to move the mouse though.)</font>](#faq-missing-xtest)

[**Q-4:** <font color="#007f00">Help, I need to run **x11vnc** on Solaris 2.5.1 (or other old Unix/Linux) and it doesn't compile!</font>](#faq-solaris251build)

[**Q-5:** <font color="#007f00">Where can I get a precompiled **x11vnc** binary for my Operating System?</font>](#faq-binaries)

[**Q-6:** <font color="#007f00">Where can I get a VNC Viewer binary (or source code) for the Operating System I will be viewing from?</font>](#faq-viewer-download)

[**Q-7:** <font color="#007f00">How can I see all of **x11vnc**'s command line options and documentation on how to use them?</font>](#faq-cmdline-opts)

[**Q-8:** <font color="#007f00">I don't like typing arcane command line options every time I start **x11vnc**. What can I do? Is there a config file? Or a GUI?</font>](#faq-config-file)

[**Q-9:** <font color="#007f00">How can I get the GUI to run in the System Tray, or at least be a smaller, simpler icon?</font>](#faq-gui-tray)

[**Q-10:** <font color="#007f00">How can I get **x11vnc** to listen on a different port besides the default VNC port (5900)?</font>](#faq-change-port)

[**Q-11:** <font color="#007f00">Why do I get "`Failure autoprobing: Permission denied`" when **x11vnc** tries to listen on a TCP port?</font>](#faq-selinux-perms)

[**Q-12:** <font color="#007f00">My Firewall/Router doesn't allow VNC Viewers to connect to **x11vnc**.</font>](#faq-firewalls)

[**Q-13:** <font color="#007f00">Is it possible for a VNC Viewer and a VNC Server to connect to each other even though both are behind Firewalls that block all incoming connections?</font>](#faq-firewall-out)

[**Q-14:** <font color="#007f00">Can I make **x11vnc** more quiet and also go into the background after starting up?</font>](#faq-quiet-bg)

[**Q-15:** <font color="#007f00">Sometimes when a VNC viewer dies abruptly, **x11vnc** also dies with the error message like: "`Broken pipe`". I'm using the `-forever` mode and I want **x11vnc** to keep running.</font>](#faq-sigpipe)

[**Q-16:** <font color="#007f00">The Windows TightVNC 1.3.9 Viewer cannot connect to **x11vnc**.</font>](#faq-tight139)

[**Q-17:** <font color="#007f00">KDE's krdc VNC viewer cannot connect to **x11vnc**.</font>](#faq-krdcprob)

[**Q-18:** <font color="#007f00">When I start **x11vnc** on an Alpha Tru64 workstation the X server crashes!</font>](#faq-tru64-crash)

[**Q-19:** <font color="#007f00">When running **x11vnc** on an IBM AIX workstation after a few minutes the VNC connection freezes.</font>](#faq-aix-freeze)

[**Q-20:** <font color="#007f00">Are there any build-time customizations possible, e.g. change defaults, create a smaller binary, etc?</font>](#faq-build-customizations)

<font size="-0">**[Win2VNC Related]**</font>

[**Q-21:** <font color="#007f00">I have two separate machine displays in front of me, one Windows the other X11: can I use **x11vnc** in combination with Win2VNC in dual-screen mode to pass the keystrokes and mouse motions to the X11 display?</font>](#faq-win2vnc)

[**Q-22:** <font color="#007f00">I am running **Win2VNC** on my Windows machine and "`x11vnc -nofb`" on Unix to pass keyboard and mouse to the Unix monitor. Whenever I start **Win2VNC** it quickly disconnects and **x11vnc** says: `rfbProcessClientNormalMessage: read: Connection reset by peer`</font>](#faq-win2vnc-8bpp)

[**Q-23:** <font color="#007f00">Can I run "`x11vnc -nofb`" on a Mac OS X machine to redirect mouse and keyboard input to it from Windows and X11 machines via **Win2VNC** and **x2vnc**, respectively?</font>](#faq-macosx-nofb)

<font size="-0">**[Color Issues]**</font>

[**Q-24:** <font color="#007f00">The X display I run **x11vnc** on is only 8 bits per pixel (bpp) PseudoColor (i.e. only 256 distinct colors.) The **x11vnc** colors may start out OK, but after a while they are incorrect in certain windows.</font>](#faq-8bpp)

[**Q-25:** <font color="#007f00">Color problems: Why are the colors for some windows incorrect in **x11vnc**? BTW, my X display has nice overlay/multi-depth visuals of different color depths: e.g. there are both depth 8 and 24 visuals available at the same time.</font>](#faq-overlays)

[**Q-26:** <font color="#007f00">I am on a high color system (depth ≥ 24) but I seem to have colormap problems. They either flash or everything is very dark.</font>](#faq-directcolor)

[**Q-27:** <font color="#007f00">How do I figure out the window id to supply to the `-id windowid` option?</font>](#faq-windowid)

[**Q-28:** <font color="#007f00">Why don't menus or other transient windows come up when I am using the `-id windowid` option to view a single application window?</font>](#faq-transients-id)

[**Q-29:** <font color="#007f00">My X display is depth 24 at 24bpp (instead of the normal depth 24 at 32bpp.) I'm having lots of color and visual problems with **x11vnc** and/or **vncviewer**. What's up?</font>](#faq-24bpp)

<font size="-0">**[Xterminals]**</font>

[**Q-30:** <font color="#007f00">Can I use **x11vnc** to view and interact with an Xterminal (e.g. NCD) that is not running UNIX and so **x11vnc** cannot be run on it directly?</font>](#faq-noshm)

[**Q-31:** <font color="#007f00">How do I get my X permissions (MIT-MAGIC-COOKIE file) correct for a Unix/Linux machine acting as an Xterminal?</font>](#faq-xterminal-xauth)

<font size="-0">**[Sun Rays]**</font>

[**Q-32:** <font color="#007f00">I'm having trouble using **x11vnc** with my Sun Ray session.</font>](#faq-sunrays)

<font size="-0">**[Remote Control]**</font>

[**Q-33:** <font color="#007f00">How do I stop **x11vnc** once it is running in the background?</font>](#faq-stop-bg)

[**Q-34:** <font color="#007f00">Can I change settings in **x11vnc** without having to restart it? Can I remote control it?</font>](#faq-remote_control)

<font size="-0">**[Security and Permissions]**</font>

[**Q-35:** <font color="#007f00">How do I create a VNC password for use with **x11vnc**?</font>](#faq-passwd)

[**Q-36:** <font color="#007f00">Can I make it so `-storepasswd` doesn't show my password on the screen?</font>](#faq-passwd-noecho)

[**Q-37:** <font color="#007f00">Can I have two passwords for VNC viewers, one for full access and the other for view-only access to the display?</font>](#faq-passwdfile)

[**Q-38:** <font color="#007f00">Can I have as many full-access and view-only passwords as I like?</font>](#faq-multipasswd)

[**Q-39:** <font color="#007f00">Does **x11vnc** support Unix usernames and passwords? Can I further limit the set of Unix usernames who can connect to the VNC desktop?</font>](#faq-unix-passwords)

[**Q-40:** <font color="#007f00">Can I supply an external program to provide my own custom login method (e.g. Dynamic/One-time passwords or non-Unix (LDAP) usernames and passwords)?</font>](#faq-custom-passwords)

[**Q-41:** <font color="#007f00">Why does **x11vnc** exit as soon as the VNC viewer disconnects? And why doesn't it allow more than one VNC viewer to connect at the same time?</font>](#faq-forever-shared)

[**Q-42:** <font color="#007f00">Can I limit which machines incoming VNC clients can connect from?</font>](#faq-allow-opt)

[**Q-43:** <font color="#007f00">How do I build **x11vnc/libvncserver** with `libwrap` (tcp_wrappers) support?</font>](#faq-tcp_wrappers)

[**Q-44:** <font color="#007f00">Can I have **x11vnc** only listen on one network interface (e.g. internal LAN) rather than having it listen on all network interfaces and relying on `-allow` to filter unwanted connections out?</font>](#faq-listen-interface)

[**Q-45:** <font color="#007f00">Now that `-localhost` implies listening only on the loopback interface, how I can occasionally allow in a non-localhost via the `-R allowonce` remote control command?</font>](#faq-listen-localhost)

[**Q-46:** <font color="#007f00">Can I fine tune what types of user input are allowed? E.g. have some users just be able to move the mouse, but not click or type anything?</font>](#faq-input-opt)

[**Q-47:** <font color="#007f00">Can I prompt the user at the local X display whether the incoming VNC client should be accepted or not? Can I decide to make some clients view-only? How about running an arbitrary program to make the decisions?</font>](#faq-accept-opt)

[**Q-48:** <font color="#007f00">I start **x11vnc** as root because it is launched via `inetd(8)` or a display manager like `gdm(1)`. Can I have **x11vnc** later switch to a different user?</font>](#faq-users-opt)

[**Q-49:** <font color="#007f00">I use a screen-lock when I leave my workstation (e.g. xscreensaver or xlock.) When I remotely access my workstation desktop via **x11vnc** I can unlock the desktop fine, but I am worried people will see my activities on the physical monitor. What can I do to prevent this, or at least make it more difficult?</font>](#faq-blockdpy)

[**Q-50:** <font color="#007f00">Can I have **x11vnc** automatically lock the screen when I disconnect the VNC viewer?</font>](#faq-gone-lock)

<font size="-0">**[Encrypted Connections]**</font>

[**Q-51:** <font color="#007f00">How can I tunnel my connection to **x11vnc** via an encrypted SSH channel between two Unix machines?</font>](#faq-ssh-unix)

[**Q-52:** <font color="#007f00">How can I tunnel my connection to **x11vnc** via an encrypted SSH channel from Windows using an SSH client like Putty?</font>](#faq-ssh-putty)

[**Q-53:** <font color="#007f00">How can I tunnel my connection to **x11vnc** via an encrypted SSL channel using an external tool like `stunnel`?</font>](#faq-ssl-tunnel-ext)

[**Q-54:** <font color="#007f00">Does **x11vnc** have built-in SSL tunneling?</font>](#faq-ssl-tunnel-int)

[**Q-55:** <font color="#007f00">How do I use VNC Viewers with built-in SSL tunneling?</font>](#faq-ssl-tunnel-viewers)

[**Q-56:** <font color="#007f00">How do I use the Java applet VNC Viewer with built-in SSL tunneling when going through a Web Proxy?</font>](#faq-ssl-java-viewer-proxy)

[**Q-57:** <font color="#007f00">Can Apache web server act as a gateway for users to connect via SSL from the Internet with a Web browser to **x11vnc** running on their workstations behind a firewall?</font>](#faq-ssl-portal)

[**Q-58:** <font color="#007f00">Can I create and use my own SSL Certificate Authority (CA) with **x11vnc**?</font>](#faq-ssl-ca)

<font size="-0">**[Display Managers and Services]**</font>

[**Q-59:** <font color="#007f00">How can I run **x11vnc** as a "service" that is always available?</font>](#faq-service)

[**Q-60:** <font color="#007f00">How can I use **x11vnc** to connect to an X login screen like `xdm`, GNOME `gdm`, KDE `kdm`, or CDE `dtlogin`? (i.e. nobody is logged into an X session yet.)</font>](#faq-display-manager)

[**Q-61:** <font color="#007f00">Can I run **x11vnc** out of `inetd(8)`? How about `xinetd(8)`?</font>](#faq-inetd)

[**Q-62:** <font color="#007f00">Can I have **x11vnc** advertise its VNC service and port via mDNS / Zeroconf (e.g. Avahi) so VNC viewers on the local network can detect it automatically?</font>](#faq-avahi)

[**Q-63:** <font color="#007f00">Can I have **x11vnc** allow a user to log in with her UNIX username and password and then have it find her X session display on that machine and then attach to it? How about starting an X session if one cannot be found?</font>](#faq-userlogin)

[**Q-64:** <font color="#007f00">Can I have **x11vnc** restart itself after it terminates?</font>](#faq-loop)

[**Q-65:** <font color="#007f00">How do I make **x11vnc** work with the Java VNC viewer applet in a web browser?</font>](#faq-java-http)

[**Q-66:** <font color="#007f00">Are reverse connections (i.e. the VNC server connecting to the VNC viewer) using "`vncviewer -listen`" and `vncconnect(1)` supported?</font>](#faq-reverse-connect)

[**Q-67:** <font color="#007f00">Can reverse connections be made to go through a Web or SOCKS proxy or SSH?</font>](#faq-reverse-connect-proxy)

[**Q-68:** <font color="#007f00">Can **x11vnc** provide a multi-user desktop web login service as an Apache CGI or PHP script?</font>](#faq-web-login)

[**Q-69:** <font color="#007f00">Can I use **x11vnc** as a replacement for `Xvnc`? (i.e. not for a real display, but for a virtual one I keep around.)</font>](#faq-xvfb)

[**Q-70:** <font color="#007f00">How can I use **x11vnc** on "headless" machines? Why might I want to?</font>](#faq-headless)

<font size="-0">**[Resource Usage and Performance]**</font>

[**Q-71:** <font color="#007f00">I have lots of memory, but why does **x11vnc** fail with    `shmget: No space left on device`    or    `Minor opcode of failed request: 1 (X_ShmAttach)`?</font>](#faq-solshm)

[**Q-72:** <font color="#007f00">How can I make **x11vnc** use less system resources?</font>](#faq-less-resource)

[**Q-73:** <font color="#007f00">How can I make **x11vnc** use MORE system resources?</font>](#faq-more-resource)

[**Q-74:** <font color="#007f00">I use **x11vnc** over a slow link with high latency (e.g. dialup modem or broadband), is there anything I can do to speed things up?</font>](#faq-slow-link)

[**Q-75:** <font color="#007f00">Does **x11vnc** support the X DAMAGE Xserver extension to find modified regions of the screen quickly and efficiently?</font>](#faq-xdamage)

[**Q-76:** <font color="#007f00">My OpenGL application shows no screen updates unless I supply the `-noxdamage` option to **x11vnc**.</font>](#faq-xdamage-opengl)

[**Q-77:** <font color="#007f00">When I drag windows around with the mouse or scroll up and down things really bog down (unless I do the drag in a single, quick motion.) Is there anything to do to improve things?</font>](#faq-pointer-mode)

[**Q-78:** <font color="#007f00">Why not do something like wireframe animations to avoid the windows "lurching" when being moved or resized?</font>](#faq-wireframe)

[**Q-79:** <font color="#007f00">Can **x11vnc** try to apply heuristics to detect when a window is scrolling its contents and use the CopyRect encoding for a speedup?</font>](#faq-scrollcopyrect)

[**Q-80:** <font color="#007f00">Can **x11vnc** do client-side caching of pixel data? I.e. so when that pixel data is needed again it does not have to be retransmitted over the network.</font>](#faq-client-caching)

[**Q-81:** <font color="#007f00">Does **x11vnc** support TurboVNC?</font>](#faq-turbovnc)

<font size="-0">**[Mouse Cursor Shapes]**</font>

[**Q-82:** <font color="#007f00">Why isn't the mouse cursor shape (the little icon shape where the mouse pointer is) correct as I move from window to window?</font>](#faq-cursor-shape)

[**Q-83:** <font color="#007f00">When using XFIXES cursorshape mode, some of the cursors look really bad with extra black borders around the cursor and other cruft. How can I improve their appearance?</font>](#faq-xfixes-alpha)

[**Q-84:** <font color="#007f00">In XFIXES mode, are there any hacks to handle cursor transparency ("alpha channel") exactly?</font>](#faq-xfixes-alpha-hacks)

<font size="-0">**[Mouse Pointer]**</font>

[**Q-85:** <font color="#007f00">Why does the mouse arrow just stay in one corner in my vncviewer, whereas my cursor (that does move) is just a dot?</font>](#faq-cursor-arrow)

[**Q-86:** <font color="#007f00">Can I take advantage of the TightVNC extension to the VNC protocol where Cursor Positions Updates are sent back to all connected clients (i.e. passive viewers can see the mouse cursor being moved around by another viewer)?</font>](#faq-cursor-positions)

[**Q-87:** <font color="#007f00">Is it possible to swap the mouse buttons (e.g. left-handed operation), or arbitrarily remap them? How about mapping button clicks to keystrokes, e.g. to partially emulate Mouse wheel scrolling?</font>](#faq-buttonmap-opt)

<font size="-0">**[Keyboard Issues]**</font>

[**Q-88:** <font color="#007f00">How can I get my `AltGr` and `Shift` modifiers to work between keyboards for different languages?</font>](#faq-altgr)

[**Q-89:** <font color="#007f00">When I try to type a "<" (i.e. less than) instead I get ">" (i.e. greater than)! Strangely, typing ">" works OK!!</font>](#faq-greaterless)

[**Q-90:** <font color="#007f00">Extra Character Inserted, E.g.: When I try to type a "<" (i.e. less than) instead I get "<," (i.e. an extra comma.)</font>](#faq-greaterless-sloppy)

[**Q-91:** <font color="#007f00">I'm using an "international" keyboard (e.g. German "de", or Danish "dk") and the `-modtweak` mode works well if the VNC viewer is run on a Unix/Linux machine with a similar keyboard.   But if I run the VNC viewer on Unix/Linux with a different keyboard (e.g. "us") or Windows with any keyboard, I can't type some keys like:   "@", "$", "<", ">", etc. How can I fix this?</font>](#faq-xkbmodtweak)

[**Q-92:** <font color="#007f00">When typing I sometimes get double, triple, or more of my keystrokes repeated. I'm sure I only typed them once, what can I do?</font>](#faq-repeated-keys)

[**Q-93:** <font color="#007f00">The **x11vnc** `-norepeat` mode is in effect, but I _still_ get repeated keystrokes!!</font>](#faq-repeated-keys-still)

[**Q-94:** <font color="#007f00">After using **x11vnc** for a while, I find that I cannot type some (or any) characters or my mouse clicks and drags no longer have any effect, or they lead to strange effects. What happened?</font>](#faq-mod-stuck-down)

[**Q-95:** <font color="#007f00">The machine where I run **x11vnc** has an `AltGr` key, but the local machine where I run the VNC viewer does not. Is there a way I can map a local unused key to send an `AltGr`? How about a `Compose` key as well?</font>](#faq-remap-opt)

[**Q-96:** <font color="#007f00">I have a Sun machine I run **x11vnc** on. Its Sun keyboard has just one `Alt` key labelled "Alt" and two `Meta` keys labelled with little diamonds. The machine where I run the VNC viewer only has `Alt` keys. How can I send a `Meta` keypress? (e.g. emacs needs this)</font>](#faq-sun-alt-meta)

[**Q-97:** <font color="#007f00">Running **x11vnc** on HP-UX I cannot type "#" I just get a "3" instead.</font>](#faq-hpux-multi-key)

[**Q-98:** <font color="#007f00">Can I map a keystroke to a mouse button click on the remote machine?</font>](#faq-remap-button-click)

[**Q-99:** <font color="#007f00">How can I get Caps_Lock to work between my VNC viewer and **x11vnc**?</font>](#faq-remap-capslock)

<font size="-0">**[Screen Related Issues and Features]**</font>

[**Q-100:** <font color="#007f00">The remote display is larger (in number of pixels) than the local display I am running the **vncviewer** on. I don't like the **vncviewer** scrollbars, what I can do?</font>](#faq-scrollbars)

[**Q-101:** <font color="#007f00">Does **x11vnc** support server-side framebuffer scaling? (E.g. to make the desktop smaller.)</font>](#faq-scaling)

[**Q-102:** <font color="#007f00">Does **x11vnc** work with Xinerama? (i.e. multiple monitors joined together to form one big, single screen.)</font>](#faq-xinerama)

[**Q-103:** <font color="#007f00">Can I use **x11vnc** on a multi-headed display that is not Xinerama (i.e. separate screens `:0.0`, `:0.1`, ... for each monitor)?</font>](#faq-multi-screen)

[**Q-104:** <font color="#007f00">Can **x11vnc** show only a portion of the display? (E.g. for a special purpose application or a very large screen.)</font>](#faq-clip-screen)

[**Q-105:** <font color="#007f00">Does **x11vnc** support the XRANDR (X Resize, Rotate and Reflection) extension? Whenever I rotate or resize the screen **x11vnc** just seems to crash.</font>](#faq-xrandr)

[**Q-106:** <font color="#007f00">Independent of any XRANDR, can I have **x11vnc** rotate and/or reflect the screen that the VNC viewers see? (e.g. for a handheld whose screen is rotated 90 degrees.)</font>](#faq-rotate)

[**Q-107:** <font color="#007f00">Why is the view in my VNC viewer completely black? Or why is everything flashing around randomly?</font>](#faq-black-screen)

[**Q-108:** <font color="#007f00">I use Linux **Virtual Terminals** (VT's) to implement 'Fast User Switching' between users' sessions (e.g. Betty is on `Ctrl-Alt-F7`, Bobby is on `Ctrl-Alt-F8`, and Sid is on `Ctrl-Alt-F1`: they use those keystrokes to switch between their sessions.)   How come the view in a VNC viewer connecting to **x11vnc** is either completely black, doesn't update, or pixels messed up unless the X session **x11vnc** is attached to is in **the active VT**?</font>](#faq-linuxvc)

[**Q-109:** <font color="#007f00">I am using **x11vnc** where my local machine has "popup/hidden taskbars" and the remote display where **x11vnc** runs also has "popup/hidden taskbars" and they interfere and fight with each other. What can I do?</font>](#faq-hidden-taskbars)

[**Q-110:** <font color="#007f00">Help! **x11vnc** and my KDE screensaver keep switching each other on and off every few seconds.</font>](#faq-kde-screensaver)

[**Q-111:** <font color="#007f00">I am running the compiz 3D window manager (or beryl, MythTv, Google Earth, or some other OpenGL app) and I do not get screen updates in **x11vnc**.</font>](#faq-beryl)

[**Q-112:** <font color="#007f00">Can I use **x11vnc** to view my VMWare session remotely?</font>](#faq-vmware)

<font size="-0">**[Exporting non-X11 devices via VNC]**</font>

[**Q-113:** <font color="#007f00">Can non-X devices (e.g. a raw framebuffer) be viewed (and even controlled) via VNC with **x11vnc**?</font>](#faq-rawfb)

[**Q-114:** <font color="#007f00">Can I export the Linux Console (Virtual Terminals) via VNC using **x11vnc**?</font>](#faq-linux-vt)

[**Q-115:** <font color="#007f00">Can I export via VNC a Webcam or TV tuner framebuffer using **x11vnc**?</font>](#faq-video)

[**Q-116:** <font color="#007f00">Can I connect via VNC to a Qt-embedded/Qt-enhanced/Qtopia application running on my handheld, cell phone, or PC using the Linux console framebuffer (i.e. not X11)?</font>](#faq-qt-embedded)

[**Q-117:** <font color="#007f00">How do I inject touch screen input into an Qt-embedded/Qt-enhanced/Qtopia cell phone such as openmoko/qtmoko Neo Freerunner?</font>](#faq-qtmoko)

[**Q-118:** <font color="#007f00">Now that non-X11 devices can be exported via VNC using **x11vnc**, can I build it with no dependencies on X11 header files and libraries?</font>](#faq-no-x11)

[**Q-119:** <font color="#007f00">How do I cross compile **x11vnc** for a different architecture than my Linux i386 or amd64 PC?</font>](#faq-cross-compile)

[**Q-120:** <font color="#007f00">Does **x11vnc** support Mac OS X Aqua/Quartz displays natively (i.e. no X11 involved)?</font>](#faq-macosx)

[**Q-121:** <font color="#007f00">Can **x11vnc** be used as a VNC reflector/repeater to improve performance for the case of a large number of simultaneous VNC viewers (e.g. classroom broadcasting or a large demo)?</font>](#faq-reflect)

[**Q-122:** <font color="#007f00">Can **x11vnc** be used during a Linux, Solaris, etc. system Installation so the Installation can be done remotely?</font>](#faq-os-install)

<font size="-0">**[Misc: Clipboard, File Transfer/Sharing, Printing, Sound, Beeps, Thanks, etc.]**</font>

[**Q-123:** <font color="#007f00">Does the Clipboard/Selection get transferred between the vncviewer and the X display?</font>](#faq-clipboard)

[**Q-124:** <font color="#007f00">Can I use **x11vnc** to record a Shock Wave Flash (or other format) video of my desktop, e.g. to record a tutorial or demo?</font>](#faq-record-swf)

[**Q-125:** <font color="#007f00">Can I transfer files back and forth with **x11vnc**?</font>](#faq-filexfer)

[**Q-126:** <font color="#007f00">Which UltraVNC extensions are supported?</font>](#faq-ultravnc)

[**Q-127:** <font color="#007f00">Can **x11vnc** emulate UltraVNC's Single Click helpdesk mode for Unix? I.e. something very simple for a naive user to initiate a reverse vnc connection from their Unix desktop to a helpdesk operator's VNC Viewer.</font>](#faq-singleclick)

[**Q-128:** <font color="#007f00">Can I (temporarily) mount my local (viewer-side) Windows/Samba File share on the machine where **x11vnc** is running?</font>](#faq-smb-shares)

[**Q-129:** <font color="#007f00">Can I redirect CUPS print jobs from the remote desktop where **x11vnc** is running to a printer on my local (viewer-side) machine?</font>](#faq-cups)

[**Q-130:** <font color="#007f00">How can I hear the sound (audio) from the remote applications on the desktop I am viewing via **x11vnc**?</font>](#faq-sound)

[**Q-131:** <font color="#007f00">Why don't I hear the "Beeps" in my X session (e.g. when typing `tput bel` in an xterm)?</font>](#faq-beeps)

[**Q-132:** <font color="#007f00">Does **x11vnc** work with IPv6?</font>](#faq-ipv6)

[**Q-133:** <font color="#007f00">Thanks for your program or for your help! Can I make a donation?</font>](#faq-thanks)

* * *

<font size="-0">**[Building and Starting]**</font>
<a name="faq-xperms"></a><a name="FAQ-1"></a>

**Q-1:** <font color="#007f00">I can't get **x11vnc** to start up. It says "`XOpenDisplay failed (null)`" or "`Xlib: connection to ":0.0" refused by server Xlib: No protocol specified`" and then exits. What do I need to do?</font>

For the former error, you need to specify the X display to connect to (it also needs to be on the same machine the **x11vnc** process is to run on.) Set your `DISPLAY` environment variable (or use the [`-display`](x11vnc_opts.html#opt-display) option) to specify it. Nearly always the correct value will be "`:0`" (in fact, **x11vnc** will now assume `:0` if given no other information.)

For the latter error, you need to set up the X11 permissions correctly.

To make sure X11 permissions are the problem do this simple test: while sitting at the _**physical**_ X display open a terminal window (gnome-terminal, xterm, etc.) You should be able to run **x11vnc** successfully _without any need for special steps or command line options_ in that terminal (i.e. just type "`x11vnc`".) If that works OK then you know X11 permissions are the only thing preventing it from working when you try to start **x11vnc** via, say, a remote shell.

_How to Solve:_  See the `xauth(1)`, `Xsecurity(7)`, and `xhost(1)` man pages or [this Howto](http://www.tldp.org/HOWTO/Remote-X-Apps.html) for much info on X11 permissions. For example, you may need to set your `XAUTHORITY` environment variable (or use the [`-auth`](x11vnc_opts.html#opt-auth) option) to point to the correct MIT-MAGIC-COOKIE file (e.g. `/home/joe/.Xauthority` or `/var/gdm/:0.Xauth` or `/var/lib/kdm/A:0-crWk72K` or `/tmp/.gdmzndVlR`, etc, etc.), or simply be sure you run **x11vnc** as the correct user (i.e. the user who is logged into the X session you wish to view.)

**_Note:_** The MIT cookie file contains the _**secret key**_ that allows **x11vnc** to connect to the desired X display.

If, say, `sshd` has set `XAUTHORITY` to point to a random file it has created for X forwarding that will cause problems. (Under some circumstances even `su(1)` and `telnet(1)` can set `XAUTHORITY`. See also the `gdm` parameter `NeverPlaceCookiesOnNFS` that sets `XAUTHORITY` to a random filename in `/tmp` for the whole X session.)

Running **x11vnc** as root is often **_not_** enough: you need to know _where_ the MIT-MAGIC-COOKIE file for the desired X display is.

Example solution:

<pre>  x11vnc -display :0 -auth /var/gdm/:0.Xauth
</pre>

(this is for the display manager gdm and requires root permission to read the gdm cookie file, see [this faq](#faq-display-manager) for other display manager cookie file names.)

Note as of Feb/2007 you can also try the [`-find`](x11vnc_opts.html#opt-find) option instead of "`-display ...`" and see if that finds your display and Xauthority.

Less safe, but to avoid figuring out where the correct `XAUTHORITY` file is, if the person sitting at the physical X session types "`xhost +localhost`" then one should be able to attach **x11vnc** to the session (from the same machine.) The person could then type "`xhost -localhost`" after **x11vnc** has connected to go back to the default permissions. Also, for some situations the "`-users lurk=`" option may soon be of use (please read the documentation on the [`-users`](x11vnc_opts.html#opt-users) option.)

To test out your X11 permissions from a remote shell, set `DISPLAY` and possibly `XAUTHORITY` (see your shell's man page, `bash(1)`, `tcsh(1)`, on how to set environment variables) and type `xdpyinfo` in the same place you will be typing (or otherwise running) **x11vnc**. If information is printed out about the X display (screen sizes, supported extensions, color visuals info) that means the X11 permissions are set up properly: `xdpyinfo` successfully connected to `DISPLAY`! You could also type `xclock` and make sure no errors are reported (a clock should appear on the X display, press Ctrl-C to stop it.) If these work, then typing "`x11vnc`" in the same environment should also work.

**_<font color="bisque4">Important</font>_**: if you cannot get your X11 permissions so that the `xdpyinfo` or `xclock` tests work, **x11vnc** also _will not work_ (all of these X clients must be allowed to connect to the X server to function properly.)

**_Firewalls:_** Speaking of permissions, it should go without saying that the host-level [firewall](index.html#firewalls) will need to be configured to allow connections in on a port. E.g. 5900 (default VNC port) or 22 (default SSH port for tunnelling VNC.) Most systems these days have firewalls turned on by default, so you will actively have to do something to poke a hole in the firewall at the desired port number. See your system administration tool for Firewall settings (Yast, Firestarter, etc.)

<a name="faq-build"></a><a name="FAQ-2"></a>

**Q-2:** <font color="#007f00">I can't get **x11vnc** and/or **libvncserver** to compile.</font>

Make sure you have gcc (or other C compiler) and all of the required libraries **and** the corresponding `-dev/-devel` packages installed. These include `Xorg/XFree86`, `libX11`, `libjpeg`, `libz`, `libssl`, ... and don't forget the devs: `libjpeg-dev`, `libssl-dev` ...

The most common build problem that people encounter is that the necessary X11 libraries are installed on their system however it does not have the corresponding -dev/-devel packages installed. These dev packages include C header files and build-time `.so` symlink. It is a shame the current trend in distros is to not install the dev package by default when the the library runtime package is installed... (it diminishes the power of open source)

As of Nov/2006 here is a list of libraries that **x11vnc** usually likes to use:

<pre>libc.so        libX11.so       libXtst.so       libXext.so
libXfixes.so   libXdamage.so   libXinerama.so   libXrandr.so
libz.so        libjpeg.so      libpthread.so
libssl.so      libcrypto.so    libcrypt.so
</pre>

although **x11vnc** will be pretty usable with the subset: `libc.so`, `libX11.so`, `libXtst.so`, `libXext.so`, `libz.so`, and `libjpeg.so`.

After running the **libvncserver** `configure`, carefully examine the output and the messages in the `config.log` file looking for missing components. For example, if the `configure` output looks like:

<pre>  checking how to run the C preprocessor... gcc -E
  checking for X... no
  checking for XkbSelectEvents in -lX11... no
  checking for XineramaQueryScreens in -lXinerama... no
  checking for XTestFakeKeyEvent in -lXtst... no
</pre>

or even worse:

<pre>  checking for C compiler default output file name... configure: error:
  C compiler cannot create executables
  See `config.log' for more details.
</pre>

there is quite a bit wrong with the build environment. Hopefully simply adding `-dev` packages and/or `gcc` or `make` will fix it.

For Debian the list seems to be:

<pre>  gcc
  make
  libc6-dev
  libjpeg8-dev           (formerly libjpeg62-dev)
  libx11-dev
  x11proto-core-dev      (formerly x-dev)
  libxext-dev
  libxtst-dev
  libxdamage-dev
  libxfixes-dev
  libxrandr-dev
  libxinerama-dev
  libxss-dev             (formerly xlibs-static-dev)
  zlib1g-dev
  libssl-dev
  libavahi-client-dev
  linux-libc-dev         (only needed for linux console rawfb support)
</pre>

Note that depending on your OS version the above names may have been changed and/or additional packages may be needed.

For Redhat the list seems to be:

<pre>  gcc
  make
  glibc-devel
  libjpeg-devel
  libX11-devel
  xorg-x11-proto-devel
  libXdamage-devel
  libXfixes-devel
  libXrandr-devel
  zlib-devel
  openssl-devel
  avahi-devel
  kernel-headers         (only needed for linux console rawfb support)
</pre>

For other distros or OS's the package names may not be the same but will look similar. Also, distros tend to rename packages as well so the above list may be out of date. So only use the above lists as hints for the package names that are needed.

Have a look at [Misc. Build Problems](miscbuild.html) for additional fixes.

Note: there is growing trend in Linux and other distros to slice up core X11 software into more and smaller packages. So be prepared for more headaches compiling software...

<a name="faq-missing-xtest"></a><a name="FAQ-3"></a>

**Q-3:** <font color="#007f00">I just built **x11vnc** successfully, but when I use it my keystrokes and mouse button clicks are ignored  (I am able to move the mouse though.)</font>

This is most likely due to you not having a working build environment for the XTEST client library `libXtst.so`. The library is probably present on your system, but the package installing the build header file is missing.

If you were watching carefully while `configure` was running you would have seen:

<pre>  checking for XTestFakeKeyEvent in -lXtst... no
</pre>

The solution is to add the necessary build environment package (and the library package if that is missing too.) On Debian the build package is `libxtst-dev`. Other distros/OS's may have it in another package.

**x11vnc** will build without support for this library (e.g. perhaps one wants a view-only **x11vnc** on a stripped down or embedded system...) And at runtime it will also continue to run even if the X server it connects to does not support XTEST. In both cases it cannot inject keystrokes or button clicks since XTEST is needed for that (it can still move the mouse pointer using the X API `XWarpPointer()`.)

You will see a warning message something like this at run time:

<pre>  20/03/2005 22:33:09 WARNING: XTEST extension not available (either missing from
  20/03/2005 22:33:09   display or client library libXtst missing at build time.)
  20/03/2005 22:33:09   MOST user input (pointer and keyboard) will be DISCARDED.
  20/03/2005 22:33:09   If display does have XTEST, be sure to build x11vnc with
  20/03/2005 22:33:09   a working libXtst build environment (e.g. libxtst-dev,
  20/03/2005 22:33:09   or other packages.)
  20/03/2005 22:33:09 No XTEST extension, switching to -xwarppointer mode for
  20/03/2005 22:33:09   pointer motion input.
</pre>

Also, as of Nov/2006 there will be a `configure` build time warning as well:

<pre>  ...
  checking for XFixesGetCursorImage in -lXfixes... yes
  checking for XDamageQueryExtension in -lXdamage... yes
  configure: WARNING:
  ==========================================================================
  A working build environment for the XTEST extension was not found (libXtst).
  An x11vnc built this way will be only barely usable.  You will be able to
  move the mouse but not click or type.  There can also be deadlocks if an
  application grabs the X server.

  It is recommended that you install the necessary development packages
  for XTEST (perhaps it is named something like libxtst-dev) and run
  configure again.
  ==========================================================================
</pre>

<a name="faq-solaris251build"></a><a name="FAQ-4"></a>

**Q-4:** <font color="#007f00">Help, I need to run **x11vnc** on Solaris 2.5.1 (or other old Unix/Linux) and it doesn't compile!</font>

We apologize that **x11vnc** does not build cleanly on older versions of Solaris, Linux, etc.: very few users are on these old releases.

We have heard that since Dec/2004 a Solaris 2.6 built **x11vnc** will run on Solaris Solaris 2.5 and 2.5.1 (since a workaround for `XConvertCase` is provided.)

In any event, here is a workaround for Solaris 2.5.1 (and perhaps earlier and perhaps non-Solaris):

First use the environment settings (`CPPFLAGS`, `LDFLAGS`, etc.) in the above [Solaris build script](index.html#solarisbuilding) to run the `configure` command. That should succeed without failure. Then you have to hand edit the autogenerated `rfb/rfbconfig.h` file in the source tree, and just _before_ the last `#endif` at the bottom of that file insert these workaround lines:

<pre>struct timeval _tmp_usleep_tv;
#define usleep(x) \
    _tmp_usleep_tv.tv_sec  = (x) / 1000000; \
    _tmp_usleep_tv.tv_usec = (x) % 1000000; \
    select(0, NULL, NULL, NULL, &_tmp_usleep_tv); 
int gethostname(char *name, int namelen);
long random();
int srandom(unsigned int seed);
#undef LIBVNCSERVER_HAVE_LIBPTHREAD
#define SHUT_RDWR 2
typedef unsigned int in_addr_t;
#define snprintf(a, n, args...) sprintf((a), ## args) 
</pre>

Then run `make` with the Solaris build script environment, everything should compile without problems, and the resulting **x11vnc** binary should work OK. If some non-x11vnc related programs fail (e.g. test programs) and the **x11vnc** binary is not created try "`make -k`" to have it keep going. Similar sorts of kludges in `rfb/rfbconfig.h` can be done on other older OS (Solaris, Linux, ...) releases.

Here are some notes for similar steps that need to be done to build on [SunOS 4.x](x11vnc_sunos4.html)

Please let us know if you had to use the above workaround (and whether it worked or not.) If there is enough demand we will try to push clean compilations back to earlier Solaris, Linux, etc, releases.

<a name="faq-binaries"></a><a name="FAQ-5"></a>

**Q-5:** <font color="#007f00">Where can I get a precompiled **x11vnc** binary for my Operating System?</font>

Hopefully the [build steps](index.html#building) above and [FAQ](#faq-build) provide enough info for a painless compile for most environments. Please report problems with the **x11vnc** configure, make, etc. on your system (if your system is known to compile other GNU packages successfully.)

There are precompiled **x11vnc** binaries built by other groups that are available at the following locations:

<pre>    Slackware:      (.tgz)  [http://www.linuxpackages.net/](http://www.linuxpackages.net/search_view.php?by=name&name=x11vnc)
    SuSE:           (.rpm)  [http:/software.opensuse.org/](http://software.opensuse.org/search?baseproject=openSUSE%3A11.2&p=1&q=x11vnc)
    Gentoo:         (info)  [http://gentoo-wiki.com/](http://en.gentoo-wiki.com/wiki/X11VNC) and [http://gentoo-portage.com/](http://gentoo-portage.com/x11-misc/x11vnc)
    FreeBSD:        (.tbz)  [http://www.freebsd.org/](http://www.freebsd.org/cgi/ports.cgi?query=x11vnc&stype=all)
                            [http://www.freshports.org/net/x11vnc](http://www.freshports.org/net/x11vnc)
    NetBSD:         (src)   [http://pkgsrc.se/x11/x11vnc](http://pkgsrc.se/x11/x11vnc)
    OpenBSD:        (.tgz)  [http://openports.se/](http://openports.se/x11/x11vnc)
    Arch Linux:     (.tgz)  [http://www.archlinux.org/](http://www.archlinux.org/packages/search/?q=x11vnc)
    Nokia 770       (.deb)  [http://mike.saunby.googlepages.com/x11vncfornokia7702](http://mike.saunby.googlepages.com/)
    Sharp Zaurus            [http://www.focv.com/](http://www.focv.com/ipkg/)
    Debian:         (.deb)  [http://packages.debian.org/x11vnc](http://packages.debian.org/x11vnc)
    Redhat/Fedora:  (.rpm)  [http://packages.sw.be/x11vnc RPMforge](http://packages.sw.be/x11vnc/)
                            [http://dag.wieers.com/rpm/packages/x11vnc/](http://dag.wieers.com/rpm/packages/x11vnc/) (N.B.: unmaintained after 0.9.3)
    Solaris:        (pkg)   [http://www.sunfreeware.com/](http://www.sunfreeware.com/)
</pre>

If the above binaries don't work and building **x11vnc** on your OS fails (and all else fails!) you can try one of [My Collection of **x11vnc** Binaries](bins) for various OS's and **x11vnc** releases.

As a general note, the **x11vnc** program is simple enough you don't really need to install a package: the binary will in most cases work as is and from any location (as long as your system libraries are not too old, etc.) So, for Linux distributions that are not one of the above, the **x11vnc** binary from the above packages has a good chance of working. You can "install" it by just copying the **x11vnc** binary to the desired directory in your `PATH`. Tip on extracting files from a Debian package: extract the archive via a command like: "`ar x x11vnc_0.6-2_i386.deb`" and then you can find the binary in the resulting `data.tar.gz` tar file. Also, `rpm2cpio(1)` is useful in extracting files from rpm packages.

If you use a standalone binary like this and _also_ want **x11vnc** to serve up the Java VNC Viewer jar file (either SSL enabled or regular one), then you will need to extract the `classes` subdirectory from the source tarball and point **x11vnc** to it via the [`-httpdir`](x11vnc_opts.html#opt-httpdir) option. E.g.:

<pre>    x11vnc -httpdir /path/to/x11vnc-0.9.9/classes/ssl ...
</pre>

<a name="faq-viewer-download"></a><a name="FAQ-6"></a>

**Q-6:** <font color="#007f00">Where can I get a VNC Viewer binary (or source code) for the Operating System I will be viewing from?</font>

To obtain VNC viewers for the viewing side (Windows, Mac OS, or Unix) try here:

*   [http://www.tightvnc.com/download.html](http://www.tightvnc.com/download.html)
*   [http://www.realvnc.com/download-free.html](http://www.realvnc.com/products/free/4.1/download.html)
*   [http://sourceforge.net/projects/cotvnc/](http://sourceforge.net/projects/cotvnc/)
*   [http://www.ultravnc.com/](http://www.ultravnc.com/)
*   [Our Enhanced TightVNC Viewer (SSVNC)](ssvnc.html)

    ![](ssvnc.gif)

<a name="faq-cmdline-opts"></a><a name="FAQ-7"></a>

**Q-7:** <font color="#007f00">How can I see all of **x11vnc**'s command line options and documentation on how to use them?</font>

Run:  `x11vnc -opts`   to list just the option names or run:  `x11vnc -help`   for long descriptions about each option. The output is listed [here](x11vnc_opts.html) as well. Yes, **x11vnc** does have a lot of options, doesn't it...

<a name="faq-config-file"></a><a name="FAQ-8"></a>

**Q-8:** <font color="#007f00">I don't like typing arcane command line options every time I start **x11vnc**. What can I do? Is there a config file? Or a GUI?</font>

You could create a shell script that calls **x11vnc** with your options:

<pre>#!/bin/sh
#
# filename: X11vnc  (i.e. not "x11vnc")
# It resides in a directory in $PATH. "chmod 755 X11vnc" has been run on it.
#
x11vnc -wait 50 -localhost -rfbauth $HOME/.vnc/passwd -display :0 $*
</pre>

a similar thing can be done via aliases in your shell (bash, tcsh, csh, etc..)

Or as of Jun/2004 you can use the simple `$HOME/.x11vncrc` config file support. If that file exists, each line is taken as a command line option. E.g. the above would be:

<pre># this is a comment in my ~/.x11vncrc file
wait 50        # this is a comment to the end of the line.
-localhost     # note: the leading "-" is optional.
rfbauth  /home/fred/.vnc/passwd
display :0
</pre>

As of Dec/2004 there is now a simple Tcl/Tk GUI based on the remote-control functionality ("`-R`") that was added. The `/usr/bin/wish` program is needed for operation. The gui is not particularly user-friendly, it just provides a point and click mode to set all the many **x11vnc** parameters and obtain help on them. It is also very useful for testing. See the [`-gui`](x11vnc_opts.html#opt-gui) option for more info. Examples: "`x11vnc ... -gui`" and "`x11vnc ... -gui other:0`" in the latter case the gui is displayed on `other:0`, _not_ the X display **x11vnc** is polling. There is also a "[`-gui tray`](#faq-gui-tray)" system tray mode.

![](tkx11vnc.gif)

NOTE: You may need to install the "wish" or "tk" or "tk8.4" package for the gui mode to work (the package name depends on your OS/distro.) The tcl/tk "`wish`" interpreter is used. In debian (and so ubuntu too) one would run "`apt-get install tk`" or perhaps "`apt-get install tk8.4`"

<a name="faq-gui-tray"></a><a name="FAQ-9"></a>

**Q-9:** <font color="#007f00">How can I get the GUI to run in the System Tray, or at least be a smaller, simpler icon?</font>

As of Jul/2005 the gui can run in a more friendly small icon mode "[`-gui icon`](x11vnc_opts.html#opt-gui)" or in the system tray: "[`-gui tray`](x11vnc_opts.html#opt-gui)". It has balloon status, a simple menu, and a Properities dialog. The full, complicated, gui is only available under "Advanced". Other improvements were added as well. Try "Misc -> simple_gui" for a gui with fewer esoteric menu items.

If the gui fails to embed itself in the system tray, do a retry via "Window View -> icon" followed by "Window View -> tray" with the popup menu.

For inexperienced users starting up **x11vnc** and the GUI while sitting at the physical X display (not remotely), using something like "`x11vnc -display :0 -gui tray=setpass`" might be something for them that they are accustomed to in a Desktop environment (it prompts for an initial password, etc.) This is a basic "Share My Desktop" usage mode.

As of Nov/2008 in **x11vnc** 0.9.6 there is a desktop menu item (x11vnc.desktop) that runs this command:

<pre>   x11vnc -gui tray=setpass -rfbport PROMPT -logfile %HOME/.x11vnc.log.%VNCDISPLAY
</pre>

which also prompts for which VNC port to use and a couple other parameters.<a name="faq-change-port"></a><a name="FAQ-10"></a>

**Q-10:** <font color="#007f00">How can I get **x11vnc** to listen on a different port besides the default VNC port (5900)?</font>

Use something like, e.g., "`x11vnc -rfbport 5901`" to force it to use port 5901 (this is VNC display `:1`.) If something else is using that port **x11vnc** will exit immediately. If you do not supply the `-rfbport` option, it will autoprobe starting at 5900 and work its way up to 5999 looking for a free port to listen on. In that case, watch for the `PORT=59xx` line to see which port it found, then subtract 5900 from it for the VNC display number to enter into the VNC Viewer(s).

The "[`-N`](x11vnc_opts.html#opt-N)" option will try to match the VNC display number to the X display (e.g. X11 DISPLAY of :5 (port 6005) will have VNC display :5 (port 5905).)

Also see the "[`-autoport n`](x11vnc_opts.html#opt-autoport)" option to indicated at which value the auto probing should start at.

<a name="faq-selinux-perms"></a><a name="FAQ-11"></a>

**Q-11:** <font color="#007f00">Why do I get "`Failure autoprobing: Permission denied`" when **x11vnc** tries to listen on a TCP port?</font>

Perhaps your system is running SELINUX security and its default rules deny listening on the VNC port (or similar port.) We often see this on Redhat E-Linux, Fedora, and Centos systems:

<pre>30/12/2011 05:48:25 Autoprobing TCP port
30/12/2011 05:48:25 Failure autoprobing: Permission denied
30/12/2011 05:48:25
30/12/2011 05:48:25 Xinerama is present and active (e.g. multi-head).
30/12/2011 05:48:25 fb read rate: 46 MB/sec
30/12/2011 05:48:25 Error: could not obtain listening port.
</pre>

The solution is to configure your SELINUX rules to allow this. Or disable SELINUX if you don't need it.<a name="faq-firewalls"></a><a name="FAQ-12"></a>

**Q-12:** <font color="#007f00">My Firewall/Router doesn't allow VNC Viewers to connect to **x11vnc**.</font>

See the [Firewalls/Routers discussion](index.html#firewalls).

<a name="faq-firewall-out"></a><a name="FAQ-13"></a>

**Q-13:** <font color="#007f00">Is it possible for a VNC Viewer and a VNC Server to connect to each other even though both are behind Firewalls that block all incoming connections?</font>

This is very difficult or impossible to do unless a third machine, reachable by both, is used as a relay. So we assume a third machine is somehow being used as a relay.

(_Update:_ It may be possible to do "NAT-2-NAT" without a relay machine by using a UDP tunnel such as [http://samy.pl/pwnat/](http://samy.pl/pwnat/). All that is required is that both NAT firewalls allow in UDP packets from an IP address to which a UDP packet has recently been sent to. If you try it out let us know how it went.)

In the following discussion, we will suppose port 5950 is being used on the relay machine as the VNC port for the rendezvous.

A way to rendezvous is to have the VNC Server start a [reverse connection](#faq-reverse-connect) to the relay machine:

<pre>   x11vnc -connect third-machine.net:5950 ...
</pre>

and the VNC viewer forward connects as usual:

<pre>   vncviewer third-machine.net:50
</pre>

Or maybe two ports would be involved, e.g. the viewer goes to display :51 (5951.) It depends on the relay software being used.

What software to run on third-machine? A TCP relay of some sort could be used... Try a google search on "tcp relay" or "ip relay". However, note that this isn't a simple redirection because it hooks up _two incoming_ connections. You can look at our UltraVNC repeater implementation [`ultravnc_repeater.pl`](ultravnc_repeater.pl) for ideas and possibly to customize.

Also, if you are not the admin of third-machine you'd have to convince the owner to allow you to install this software (and he would likely need to open his server's firewall to allow the port through.)

It is recommended that [SSL](index.html#ssl-tunnel) is used for encryption (e.g. "[`-ssl SAVE`](x11vnc_opts.html#opt-ssl)") when going over the internet.

We have a prototype for performing a rendezvous via a Web Server acting as the relay machine. Download the [vncxfer CGI script](vncxfer) and see the instructions at the top.

Once that CGI script is set up on the website, both users go to, say, `http://somesite.com/vncxfer` (or maybe a "`/cgi-bin`" directory or "`.cgi`" suffix must be used.) Previously, both have agreed on the same session name (say by phone or email) , e.g. "5cows", and put that into the entry form on the vncxfer starting page (hopefully separated by a few seconds, so the relay helper can fully start up at the first request.)

The page returned tells them the hostname and port number and possible command to use for forward (VNC Viewer) and reverse (VNC Server, i.e. x11vnc) connections as described above.

Also since Oct/2007, **x11vnc** can connect directly (no web browser), like this:

<pre>   x11vnc ... -connect localhost:0 -proxy 'http://somesite.com/vncxfer?session=5cows&'
</pre>

Unfortunately the prototype requires that the Web server's firewall allow in the port (e.g. 5950) used for the rendezvous. Most web servers are not configured to do this, so you would need to ask the admin to do this for you. Nearly all free webspace sites, e.g. www.zendurl.com, will not allow your CGI script to be an open relay like this. (If you find one that does allow this, let me know!)

Maybe someday a clever trick will be thought up to relax the listening port requirement (e.g. use HTTP/CGI itself for the transfer... it is difficult to emulate a full-duplex TCP connection with them.)

See also the [Firewalls/Routers discussion](index.html#firewalls) and [Reverse Connection Proxy discussion](#faq-reverse-connect-proxy).

_**SSH method:**_ If both users (i.e. one on Viewer-side and the other on **x11vnc** server side) have SSH access to a common machine on the internet (or otherwise mutually reachable), then SSH plumbing can be used to solve this problem. The users create SSH tunnels going through the SSH login machine.

Instead of assuming port 5900 is free on the SSH machine, we will assume both users agreed to use 5933\. This will illustrate how to use a different port for the redir. It could be any port, what matters is that both parties refer to the same one.

Set up the Tunnel from the VNC Server side:

<pre>   ssh -t -R 5933:localhost:5900 user@third-machine.net
</pre>

Set up the Tunnel from the VNC Viewer side:

<pre>   ssh -t -L 5900:localhost:5933 user@third-machine.net
</pre>

Run Server on the VNC Server side:

<pre>   x11vnc -rfbport 5900 -localhost ...
</pre>

Run Viewer on the VNC Viewer side:

<pre>   vncviewer -encodings "copyrect tight zrle hextile" localhost:0
</pre>

(we assume the old-style `-encodings` option needs to be used. See [here](index.html#tunnelling) for details.)

If the SSH machine has been configured (see `sshd_config(5)`) with the option `GatewayPorts=yes`, then the tunnel set up by the VNC Server will be reachable directly by the VNC viewer (as long as the SSH machine's firewall does not block the port, 5933 in this example.) So in that case the Viewer side does _not_ need to run any `ssh` command, but rather only runs:

<pre>   vncviewer third-machine.net:33
</pre>

In this case we recommend [SSL](index.html#ssl-tunnel) be used for encryption.

The creation of both tunnels can be automated. As of Oct/2007 the [`-ssh`](x11vnc_opts.html#opt-ssh) x11vnc option is available and so only this command needs to be run on the VNC Server side:

<pre>   x11vnc -ssh user@third-machine.net:33 ...
</pre>

(the SSH passphrase may need to be supplied.)

To automate on the VNC Viewer side, the user can use the [Enhanced TightVNC Viewer (SSVNC)](ssvnc.html) by:

*   Clicking on 'Use SSH'
*   Entering `user@third-machine.net:33` into 'VNC Host:Display' entry box
*   Clicking on 'Connect'

As above, if the SSH `GatewayPorts=yes` setting is configured the Viewer side doesn't need to create a SSH tunnel. In SSVNC the Viewer user could instead select 'Use SSL' and then, e.g., on the Server side supply "`-ssl SAVE`" to x11vnc. Then end-to-end SSL encryption would be used (in addition to the SSH encryption on the Server-side leg.)<a name="faq-quiet-bg"></a><a name="FAQ-14"></a>

**Q-14:** <font color="#007f00">Can I make **x11vnc** more quiet and also go into the background after starting up?</font>

Use the [`-q`](x11vnc_opts.html#opt-q,) and [`-bg`](x11vnc_opts.html#opt-bg) options, respectively.  (also: `-quiet` is an alias for `-q`)

Note that under `-bg` the stderr messages will be lost unless you use the "[`-o logfile`](x11vnc_opts.html#opt-o)" option.

<a name="faq-sigpipe"></a><a name="FAQ-15"></a>

**Q-15:** <font color="#007f00">Sometimes when a VNC viewer dies abruptly, **x11vnc** also dies with the error message like: "`Broken pipe`". I'm using the `-forever` mode and I want **x11vnc** to keep running.</font>

As of Jan/2004 the `SIGPIPE` signal is ignored. So if a viewer client terminates abruptly, **libvncserver** will notice on the next I/O operation and will close the connection and continue on.

Up until of Apr/2004 the above fix only works for BSD signal systems (Linux, FreeBSD, ...) For SYSV systems there is a workaround in place since about Jun/2004.

<a name="faq-tight139"></a><a name="FAQ-16"></a>

**Q-16:** <font color="#007f00">The Windows TightVNC 1.3.9 Viewer cannot connect to **x11vnc**.</font>

This appears to be fixed in **x11vnc** version 0.9 and later. If you need to use an earlier version of **x11vnc**, try using the "`-rfbversion 3.7`" option. In general sometimes one can get a misbehaving viewer to work by supplying rfb versions 3.7 or 3.3.

<a name="faq-krdcprob"></a><a name="FAQ-17"></a>

**Q-17:** <font color="#007f00">KDE's krdc VNC viewer cannot connect to **x11vnc**.</font>

This has been fixed in **x11vnc** version 0.8.4\. More info [here](http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=389750), [here](http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=399408), and [here](http://bugs.kde.org/show_bug.cgi?id=136924).

<a name="faq-tru64-crash"></a><a name="FAQ-18"></a>

**Q-18:** <font color="#007f00">When I start **x11vnc** on an Alpha Tru64 workstation the X server crashes!</font>

This is a bug in the X server obviously; an X client should never be able to crash it.

The problem seems to be with the RECORD X extension and so a workaround is to use the "[`-noxrecord`](x11vnc_opts.html#opt-noxrecord)" **x11vnc** command line option.

<a name="faq-aix-freeze"></a><a name="FAQ-19"></a>

**Q-19:** <font color="#007f00">When running **x11vnc** on an IBM AIX workstation after a few minutes the VNC connection freezes.</font>

One user reports when running **x11vnc** on AIX 5.3 in his CDE session after a few minutes or seconds **x11vnc** will "freeze" (no more updates being sent, etc.) The freezing appeared to be worse for versions later than 0.9.2.

The problem seems to be with the RECORD X extension on AIX and so a workaround is to use the "[`-noxrecord`](x11vnc_opts.html#opt-noxrecord)" **x11vnc** command line option. The user found no freezes occurred when using that option.

<a name="faq-build-customizations"></a><a name="FAQ-20"></a>

**Q-20:** <font color="#007f00">Are there any build-time customizations possible, e.g. change defaults, create a smaller binary, etc?</font>

There are some options. They are enabled by adding something like `-Dxxxx=1` to the `CPPFLAGS` environment variable before running `configure` (see the [build notes](index.html#solarisbuilding) for general background.)

<pre>/*
 * Mar/2006
 * Build-time customization via CPPFLAGS.
 *
 * Summary of options to include in CPPFLAGS for custom builds:
 *
 * -DVNCSHARED  to have the vnc display shared by default.
 * -DFOREVER  to have -forever on by default.
 * -DNOREPEAT=0  to have -repeat on by default.
 * -DADDKEYSYMS=0  to have -noadd_keysyms the default.
 *
 * -DREMOTE_DEFAULT=0  to disable remote-control on by default (-yesremote.)
 * -DREMOTE_CONTROL=0  to disable remote-control mechanism completely.
 * -DEXTERNAL_COMMANDS=0  to disable the running of all external commands.
 * -DFILEXFER=0  disable filexfer.
 *
 * -DHARDWIRE_PASSWD=...      hardwired passwords, quoting necessary.
 * -DHARDWIRE_VIEWPASSWD=...
 * -DNOPW=1                   make -nopw the default (skip warning)
 * -DUSEPW=1                  make -usepw the default
 * -DPASSWD_REQUIRED=1        exit unless a password is supplied.
 * -DPASSWD_UNLESS_NOPW=1     exit unless a password is supplied and no -nopw.
 *
 * -DWIREFRAME=0  to have -nowireframe as the default.
 * -DWIREFRAME_COPYRECT=0  to have -nowirecopyrect as the default.
 * -DWIREFRAME_PARMS=...   set default -wirecopyrect parameters.
 * -DSCROLL_COPYRECT=0     to have -noscrollcopyrect as the default.
 * -DSCROLL_COPYRECT_PARMS=...  set default -scrollcopyrect parameters.
 * -DSCALING_COPYRECT=0
 * -DXDAMAGE=0    to have -noxdamage as the default.
 * -DSKIPDUPS=0   to have -noskip_dups as the default or vice versa.
 *
 * -DPOINTER_MODE_DEFAULT={0,1,2,3,4}  set default -pointer_mode.
 * -DBOLDLY_CLOSE_DISPLAY=0  to not close X DISPLAY under -rawfb.
 * -DSMALL_FOOTPRINT=1  for smaller binary size (no help, no gui, etc) 
 *                      use 2 or 3 for even smaller footprint.
 * -DNOGUI  do not include the gui tkx11vnc.
 * -DPOLL_8TO24_DELAY=N  
 * -DDEBUG_XEVENTS=1  enable printout for X events.
 *
 * Set these in CPPFLAGS before running configure. E.g.:
 *
 *   % env CPPFLAGS="-DFOREVER -DREMOTE_CONTROL=0" ./configure
 *   % make
 */
</pre>

If other things (e.g. "`-I ...`") are needed in `CPPFLAGS` add them as well.

On some systems is seems you need to set `LC_ALL=C` for configure to work properly...

Be careful the following two variables: `HARDWIRE_PASSWD` and `HARDWIRE_VIEWPASSWD`. If set (remember to include the double quotes around the string), they will be used as default values for the `-passwd` and `-viewpasswd` options. Of course the strings will exist unobscured in the **x11vnc** binary: it better not be readable by unintendeds. Perhaps this is of use in remote access for an embedded application, etc...

Let us know if more build-time customizations would be useful.

<font size="-0">**[Win2VNC Related]**</font>
<a name="faq-win2vnc"></a><a name="FAQ-21"></a>

**Q-21:** <font color="#007f00">I have two separate machine displays in front of me, one Windows the other X11: can I use **x11vnc** in combination with Win2VNC in dual-screen mode to pass the keystrokes and mouse motions to the X11 display?</font>

Yes, for best response start up **x11vnc** with the "[`-nofb`](x11vnc_opts.html#opt-nofb)" option (disables framebuffer polling, and does other optimizations) on the secondary display (X11) machine. Then start up **Win2VNC** on the primary display (Windows) referring it to the secondary display.

This will also work X11 to X11 using [x2vnc](http://fredrik.hubbe.net/x2vnc.html), however you would probably just want to avoid VNC and use **x2x** for that.

For reference, here are some links to Win2VNC-like programs for multiple monitor setups:

*   [Original Win2VNC](http://www.hubbe.net/~hubbe/win2vnc.html)
*   [Enhanced Win2VNC](http://www.deboer.gmxhome.de/) (broken?) and [sourceforge link](http://sourceforge.net/projects/win2vnc/)
*   [x2vnc](http://fredrik.hubbe.net/x2vnc.html)
*   [x2x](http://freshmeat.net/projects/x2x/)
*   [zvnc](http://zapek.com/?page_id=26) (MorphOS)

All of them will work with **x11vnc** (except **x2x** where it is not needed.)<a name="faq-win2vnc-8bpp"></a><a name="FAQ-22"></a>

**Q-22:** <font color="#007f00">I am running **Win2VNC** on my Windows machine and "`x11vnc -nofb`" on Unix to pass keyboard and mouse to the Unix monitor. Whenever I start **Win2VNC** it quickly disconnects and **x11vnc** says: `rfbProcessClientNormalMessage: read: Connection reset by peer`</font>

Is the default visual of the X display you run **x11vnc** on low color (e.g. 8 bit per pixel PseudoColor)? (you can run `xdpyinfo` to check, look in the "screen" section.) There seems to be a bug in **Win2VNC** in that it cannot deal correctly with colormaps (PseudoColor is the most common example of a visual with a colormap.)

If so, there are a couple options. **1)** Can you set the default visual on your display to be depth 24 TrueColor? Sun machines often have 8+24 overlay/multi-depth visuals, and you can make the default visual depth 24 TrueColor (see `fbconfig(1)` and `Xsun(1)`.) **2)** As of Feb/2004 **x11vnc** has the [`-visual`](x11vnc_opts.html#opt-visual) option to allow you to **_force_** the framebuffer visual to whatever you want (this usually messes up the colors unless you are very clever.) In this case, the option provides a convenient workaround for the **Win2VNC** bug:

<pre>  x11vnc -nofb -visual TrueColor -display :0 ...
</pre>

So the visual will be set to 8bpp TrueColor and **Win2VNC** can handle this. Since **Win2VNC** does not use the framebuffer data there should be no problems in doing this.<a name="faq-macosx-nofb"></a><a name="FAQ-23"></a>

**Q-23:** <font color="#007f00">Can I run "`x11vnc -nofb`" on a Mac OS X machine to redirect mouse and keyboard input to it from Windows and X11 machines via **Win2VNC** and **x2vnc**, respectively?</font>

Yes, as of Nov/2006 [you can](#faq-macosx). There may be a trick or two you'll need to do to get the Clipboard exchange between the machines to work.

<font size="-0">**[Color Issues]**</font>
<a name="faq-8bpp"></a><a name="FAQ-24"></a>

**Q-24:** <font color="#007f00">The X display I run **x11vnc** on is only 8 bits per pixel (bpp) PseudoColor (i.e. only 256 distinct colors.) The **x11vnc** colors may start out OK, but after a while they are incorrect in certain windows.</font>

Use the [`-flashcmap`](x11vnc_opts.html#opt-flashcmap) option to have **x11vnc** watch for changes in the colormap, and propagate those changes back to connected clients. This can be slow (since the whole screen must be updated over the network whenever the colormap changes.) This flashing colormap behavior often happens if an application installs its own private colormap when the mouse is in its window. "`netscape -install`" is a well-known historical example of this. Consider reconfiguring the system to 16 bpp or depth 24 TrueColor if at all possible.

Also note the option [`-8to24`](x11vnc_opts.html#opt-8to24) (Jan/2006) can often remove the need for flashing the colormap. Everything is dynamically transformed to depth 24 at 32 bpp using the colormaps. There may be painting errors however (see the following FAQ for tips on reducing and correcting them.)

In some rare cases (SCO unixware) the [`-notruecolor`](x11vnc_opts.html#opt-notruecolor) option has corrected colors on 8bpp displays. The red, green, and blue masks were non-zero in 8bpp PseudoColor on an obscure setup, and this option corrected the problems.

<a name="faq-overlays"></a><a name="FAQ-25"></a>

**Q-25:** <font color="#007f00">Color problems: Why are the colors for some windows incorrect in **x11vnc**? BTW, my X display has nice overlay/multi-depth visuals of different color depths: e.g. there are both depth 8 and 24 visuals available at the same time.</font>

You may want to review the [previous question](#faq-8bpp) regarding 8 bpp PseudoColor.

On some hardware (Sun/SPARC and SGI), the [`-overlay`](x11vnc_opts.html#opt-overlay) option discussed a couple paragraphs down may solve this for you (you may want to skip to it directly.) On other hardware the less robust [`-8to24`](x11vnc_opts.html#opt-8to24) option may help (also discussed below.)

Run `xdpyinfo(1)` to see what the default visual is and what the depths of the other visuals are. Does the default visual have a depth of 8 but there are other visuals of depth 24? If it does, can you possibly re-configure your X server to make a depth 24 visual the default? If you can do it, this will save you a lot of grief WRT colors and **x11vnc** (and for general usage too!) Here is how I do this on an old Sparcstation 20 running Solaris 9 with SX graphics

<pre>  xinit -- -dev /dev/fb defclass TrueColor defdepth 24
</pre>

and it works nicely (note: to log into console from the dtlogin window, select "Options -> Command Line Login", then login and enter the above command.) See the `-dev` section of the `Xsun(1)` manpage for a description of the above arguments. If you have root permission, a more permanent and convenient thing to do is to record the arguments in a line like:

<pre>  :0  Local local_uid@console root /usr/openwin/bin/Xsun -dev /dev/fb defclass TrueColor defdepth 24
</pre>

in `/etc/dt/config/Xservers` (copy `/usr/dt/config/Xservers`.) Also look at the `fbconfig(1)` and related manpages (e.g. `ffbconfig, m64config, pgxconfig, SUNWjfb_config, etc ...`) for hardware framebuffer settings that may achieve the same effect.

In general for non-Sun machines, look at the "`-cc class`" and related options in your X server manpage (perhaps `Xserver(1)`), it may allow modifying the default visual (e.g. "`-cc 4`", see `<X11/X.h>` for the visual class numbers.) On XFree86 some video card drivers (e.g. Matrox `mga`) have settings like `Option "Overlay" "24,8"` to support multi-depth overlays. For these, use the "`-cc 4`" X server command line option to get a depth 24 default visual.

<a name="infaq_the-overlay-mode"></a>**_The `-overlay` mode:_** Another option is if the system with overlay visuals is a Sun system running Solaris or SGI running IRIX you can use the [`-overlay`](x11vnc_opts.html#opt-overlay) **x11vnc** option (Aug/2004) to have **x11vnc** use the Solaris `XReadScreen(3X11)` function to poll the "true view" of the whole screen at depth 24 TrueColor. `XReadDisplay(3X11)` is used on IRIX. This is useful for Legacy applications (older versions of Cadence CAD apps are mentioned by **x11vnc** users) that require the default depth be 8bpp, or the app will use a 8bpp visual even if depth 24 visuals are available, and so the default depth workaround described in the previous paragraph is not sufficient for these apps.

It seems that Xorg is working toward supporting `XReadDisplay(3X11)` as part of the RENDER extension work. When it does support it and provides a library API **x11vnc** will be modified to take advantage of the feature to support `-overlay` on Linux, *BSD, etc. Until then see the `-8to24` mode below.

_Misc. notes on `-overlay` mode:_ An amusing by-product of `-overlay` mode is that the mouse cursor shape is correct! (i.e. XFIXES is not needed.) The `-overlay` mode may be somewhat slower than normal mode due to the extra framebuffer manipulations that must be performed. Also, on Solaris there is a bug in that for some popup menus, the windows they overlap will have painting errors (flashing colors) while the popup is up (a workaround is to disable SaveUnders by passing `-su` to `Xsun`, e.g. in your `/etc/dt/config/Xservers` file.)

<a name="infaq_the-8to24-mode"></a>**_The `-8to24` mode:_** The [`-8to24`](x11vnc_opts.html#opt-8to24) **x11vnc** option (Jan/2006) is a kludge to try to dynamically rewrite the pixel values so that the 8bpp part of the screen is mapped onto depth 24 TrueColor. This is less robust than the `-overlay` mode because it is done by **x11vnc** outside of the X server. So only use it on OS's that do not support `-overlay`. The `-8to24` mode will work if the default visual is depth 24 or depth 8\. It scans for any windows within 3 levels of the root window that are 8bpp (i.e. legacy application), or in general ones that are not using the default visual. For the windows it finds it uses `XGetSubImage()` to retrieve the pixels values and uses the correct indexed colormap to create a depth 24 TrueColor view of the whole screen. This depth 24, 32bpp view is exported via VNC.

Even on pure 8bpp displays it can be used as an alternative to [`-flashcmap`](x11vnc_opts.html#opt-flashcmap) to avoid color flashing completely.

This scheme is approximate and can often lead to painting errors. You can manually correct most painting errors by pressing 3 `Alt_L`'s in a row, or by using something like: [`-fixscreen V=3.0`](x11vnc_opts.html#opt-fixscreen) to automatically refresh the screen every 3 seconds. Also `-fixscreen 8=3.0` has been added to just refresh the non-default visual parts of the screen.

In general the scheme uses many resources and may give rise to sluggish behavior. If multiple windows are using different 8bpp indexed colormaps all but one window may need to be iconified for the colors to be correct. There are a number of tunable parameters to try to adjust performance and painting accuracy. The option `-8to24 nogetimage` can give a nice speedup if the default depth 24 X server supports hiding the 8bpp bits in bits 25-32 of the framebuffer data. On very slow machines `-8to24 poll=0.2,cachewin=5.0` gives an useful speedup. See the [`-8to24`](x11vnc_opts.html#opt-8to24) help description for information on tunable parameters, etc.

Colors still not working correctly? Run `xwininfo` on the application with the incorrect colors to verify that the depth of its visual is different from the default visual depth (gotten from `xdpyinfo`.) One possible workaround in this case is to use the [`-id`](x11vnc_opts.html#opt-id) option to point **x11vnc** at the application window itself. If the application is complicated (lots of toplevel windows and popup menus) this may not be acceptable, and may even crash **x11vnc** (but not the application.) See also [`-appshare`](x11vnc_opts.html#opt-appshare).

It is theoretically possible to solve this problem in general (see `xwd(1)` for example), but it does not seem trivial or sufficiently fast for **x11vnc** to be able to do so in real time. The [`-8to24`](x11vnc_opts.html#opt-8to24) method does this approximately and is somewhat usable. Fortunately the [`-overlay`](x11vnc_opts.html#opt-overlay) option works for Solaris machines with overlay visuals where most of this problem occurs.

<a name="faq-directcolor"></a><a name="FAQ-26"></a>

**Q-26:** <font color="#007f00">I am on a high color system (depth ≥ 24) but I seem to have colormap problems. They either flash or everything is very dark.</font>

This can happen if the default Visual (use `xdpyinfo` to list them) is DirectColor instead of TrueColor. These are both usually used in high color modes, but whereas TrueColor uses static ramps for the Red, Green, and Blue components, DirectColor has arbitrary colormaps for the Red, Green, and Blue Components. Currently **x11vnc** cannot decode these colormaps and treats them just like TrueColor.

The only workaround so far is to restart the X server with the "`-cc 4`" option to force TrueColor as the default visual (DirectColor is "`-cc 5`"; see `/usr/include/X11/X.h`.) The only place we have seen this is with the virtual framebuffer server `Xvfb` on Xorg 7.2\. So in that case you probably should restart it with something like this: "`Xvfb :1 -cc 4 -screen 0 1280x1024x24`". It should be possible for **x11vnc** to handle DirectColor, but this hasn't been implemented due to its rare usage.

You may also see this problem on an X display with a TrueColor default visual where an application chooses a DirectColor visual for its window(s). It seems the application also needs to install its own colormap for the visual for the colors to be messed up in **x11vnc**. One can make `xwud` do this for example.

<a name="faq-windowid"></a><a name="FAQ-27"></a>

**Q-27:** <font color="#007f00">How do I figure out the window id to supply to the `-id windowid` option?</font>

Run the `xwininfo` program in a terminal. It will ask you to click on the desired application window. After clicking, it will print out much information, including the window id (e.g. `0x6000010`.) Also, the visual and depth of the window printed out is often useful in debugging **x11vnc** [color problems](#faq-overlays).

Also, as of Dec/2004 you can use "[`-id pick`](x11vnc_opts.html#opt-id)" to have **x11vnc** run `xwininfo(1)` for you and after you click the window it extracts the windowid. Besides "`pick`" there is also "`id:root`" to allow you to go back to root window when doing remote-control.

<a name="faq-transients-id"></a><a name="FAQ-28"></a>

**Q-28:** <font color="#007f00">Why don't menus or other transient windows come up when I am using the `-id windowid` option to view a single application window?</font>

This is related to the behavior of the `XGetImage(3X11)` and `XShmGetImage()` interfaces regarding backingstore, saveunders, etc. The way the image is retrieved depends on some aspects of how the X server maintains the display image data and whether other windows are clipping or obscuring it. See the `XGetImage(3X11)` man page for more details. If you disable BackingStore and SaveUnders in the X server you should be able to see these transient windows.

If things are not working and you still want to do the single window polling, try the [`-sid windowid`](x11vnc_opts.html#opt-sid) option ("shifted" windowid.)

_**Update**:_ as of Nov/2009 in the 0.9.9 **x11vnc** development tarball, there is an experimental Application Sharing mode that improves upon the `-id/-sid` single window sharing: [`-appshare`](x11vnc_opts.html#opt-appshare) (run "`x11vnc -appshare -help`" for more info.) It is still very primitive and approximate, but at least it displays multiple top-level windows.

<a name="faq-24bpp"></a><a name="FAQ-29"></a>

**Q-29:** <font color="#007f00">My X display is depth 24 at 24bpp (instead of the normal depth 24 at 32bpp.) I'm having lots of color and visual problems with **x11vnc** and/or **vncviewer**. What's up?</font>

First off, depth 24 at 24bpp (bpp=bits-per-pixel) is fairly uncommon and can cause problems in general. It also can be slower than depth 24 at 32bpp. You might want to switch to 32bpp (for XFree86 see the "`-fbbpp 32`", `DefaultFbBpp`, `FbBpp` and related options.) Perhaps you have 24bpp because the video memory of the machine is low and the screen wouldn't fit in video RAM at 32bpp. For this case depth 16 at 16bpp might be an acceptable option. Recently (2012) it seems that some Xen virtual system setups have the X server running at 24bpp. You should reconfigure it to use 32bpp or 16bpp.

In any event **x11vnc** should handle depth 24 at 24bpp (although performance may be slower, and you may need to use the ZRLE encoding instead of Tight.) There are some caveats involving the viewer however:The RealVNC Unix viewer cannot handle 24bpp from the server, it will say: "`main: setPF: not 8, 16 or 32 bpp?`" and exit. I have not checked the RealVNC Windows viewer.So you need to use the TightVNC Unix viewer. However there are some problems with that too. It seems `libvncserver` does not do 24bpp correctly with the Tight encoding. The colors and screen ultimately get messed up. So you have to use a different encoding with the TightVNC **vncviewer**, try "zlib", "hextile", or one of the other encodings (e.g. `vncviewer -encodings "zlib hextile" ...`.) I have not checked the TightVNC or UltraVNC Windows viewers.It appears the older RealVNC Unix viewers (e.g. 3.3.3 and 3.3.7) can handle 24bpp from the server, so you may want to use those. They evidently request 32 bpp and `libvncserver` obliges._**Update**:_ as of Apr/2006 you can use the [`-24to32`](x11vnc_opts.html#opt-24to32) option to have **x11vnc** dynamically transform the 24bpp pixel data to 32bpp. This extra transformation could slow things down further however.Now coming the opposite direction if you are running the **_vncviewer_** on the 24bpp display, TightVNC will fail with "`Can't cope with 24 bits-per-pixel. Sorry.`" and RealVNC will fail with "`main: Error: couldn't find suitable pixmap format`" so evidently you cannot use 24bpp for the vncviewers to work on that X display.Note, however, that the Unix viewer in the [Enhanced TightVNC Viewer (SSVNC)](ssvnc.html) project _can_ handle local 24bpp X displays. It does this by requesting a 16bpp pixel format (or 8bpp if the -bgr233 option has been supplied) from the VNC server, and translates that to 24bpp locally.SSVNC can also handle 24bpp remote displays if the VNC server is x11vnc. 
<font size="-0">**[Xterminals]**</font>
<a name="faq-noshm"></a><a name="FAQ-30"></a>

**Q-30:** <font color="#007f00">Can I use **x11vnc** to view and interact with an Xterminal (e.g. NCD) that is not running UNIX and so **x11vnc** cannot be run on it directly?</font>

You can, but it will likely be very wasteful of network bandwidth since you will be _polling the X display over the network_ as opposed to over the local hardware. To do this, run **x11vnc** on a UNIX machine as close as possible network-wise (e.g. same switch) to the Xterminal machine. Use the [`-display`](x11vnc_opts.html#opt-display) option to point the display to that of the Xterminal (you'll of course need basic X11 permission to do that) and finally supply the [`-noshm`](x11vnc_opts.html#opt-noshm) option (this enables the polling over the network.)

If the Xterminal's X display is open to the network for connections, you might use something like "`-display xterm123:0`". If you are trying to do this via an SSH tunnel (assuming you can actually ssh into the Xterminal) it will be a little tricky (either use the ssh "`-R`" option or consider ssh-ing in the other direction.) In all cases the X11 permissions need to allow the connection.

The response will likely be sluggish (maybe only one "frame" per second.) This mode is not recommended except for "quick checks" of hard to get to X servers. Use something like "`-wait 150`" to cut down on the polling rate. You may also need [`-flipbyteorder`](x11vnc_opts.html#opt-flipbyteorder) if the colors get messed up due to endian byte order differences.

<a name="faq-xterminal-xauth"></a><a name="FAQ-31"></a>

**Q-31:** <font color="#007f00">How do I get my X permissions (MIT-MAGIC-COOKIE file) correct for a Unix/Linux machine acting as an Xterminal?</font>

If the X display machine is a traditional Xterminal (where the X server process runs on the Xterminal box, but all of the X client applications (firefox, etc) run on a central server (aka "terminal server")), you will need to _log into_ the Xterminal machine (i.e. get a shell running there) and then start the **x11vnc** program. If the Xterminal Linux/Unix machine is stripped down (e.g. no users besides root) that may be difficult.

The next problem is the login Display Manager (e.g. gdm, kdm), and hence the MIT-MAGIC-COOKIE auth files, are on the central server and not on the Xterminal box where the X server and **x11vnc** processes are.

So unless X permissions are completely turned off (e.g. "`xhost +`"), to run the **x11vnc** process on the Xterminal box the MIT-MAGIC-COOKIE auth file data (`XAUTHORITY` or `$HOME/.Xauthority`) must be accessible by or copied to the Xterminal. If `$HOME/.Xauthority` is exported via NFS (this is insecure of course, but has been going on for decades), then **x11vnc** can simply pick it up via NFS (you may need to use the [`-auth`](x11vnc_opts.html#opt-auth) option to point to the correct file.) Other options include copying the auth file using `scp`, or something like:

<pre>  central-server>  xauth nextract - xterm123:0 | ssh xterm123 xauth nmerge -
</pre>

and then, say, ssh from central-server to xterm123 to start **x11vnc**. Here "xterm123" refers to the computer acting as the Xterminal and "central-server" is the terminal server. You can use "`xauth -f /path/to/cookie-file list`" to examine the contents of the cookie(s) in a file "`/path/to/cookie-file`". See the `xauth(1)` manpage for more details.

If the display _name_ in the cookie file needs to be changed between the two hosts, see [this note](faq.html#infaq_xauth_pain) on the "`xauth add ...`" command.

A less secure option is to run something like "`xhost +127.0.0.1`" while sitting at the Xterminal box to allow cookie-free local access for **x11vnc**. You can run "`xhost -127.0.0.1`" after **x11vnc** connects if you want to go back to the original permissions.

If the Xterminal is really stripped down and doesn't have any user accounts, NFS, etc. you'll need to contact your system administrator to set something up. It can be done!!!  Some Xterminal projects have actually enabled "run locally" facilities for the running of an occasional app more efficiently locally on the Xterminal box (e.g. `realplayer`.)

Not recommended, but as a last resort, you could have **x11vnc** [poll the Xterminal Display over the network](#faq-noshm). For this you would run a "`x11vnc -noshm ...`" process _on_ the central-server (and hope the network admin doesn't get angry...)

<a name="infaq_xauth_pain"></a>
Note: use of Display Manager (`gdm`, `kdm`, ...) auth cookie files (i.e. from `/var/...`,  `/tmp/...`, or elsewhere) may require modification via `xauth(1)` to correctly include the display **x11vnc** refers to (e.g. "`xauth -f cookie-file add :0 . 45be51ae2ce9dfbacd882ab3ef8e96b1`", where the "`45be51...`" cookie value was found from an "`xauth -f /path/to/original/cookie-file list`") or other reasons. See `xauth(1)` manpage for full details on how to transfer an MIT-MAGIC-COOKIE between machines and displays.

_VNCviewer performance on Xterminals:_  This isn't related to **x11vnc** on Xterminals, but we mention it here anyway because of the similar issues. If you are on an Xterminal and want to use `vncviewer` to connect to a VNC server somewhere, then performance would be best if you ran the _viewer_ on the Xterminal box. Otherwise, (i.e. running the viewer process on the central-server) all of the `vncviewer` screen drawing is done more inefficiently over the network. Something to consider, especially on a busy network. (BTW, this has all of the above permission, etc, problems: _both_ `vncviewer` and **x11vnc** are X client apps desired to be run on the Xterminal box.)

<font size="-0">**[Sun Rays]**</font>
<a name="faq-sunrays"></a><a name="FAQ-32"></a>

**Q-32:** <font color="#007f00">I'm having trouble using **x11vnc** with my Sun Ray session.</font>

The [Sun Ray technology](http://www.sun.com/sunray/index.html) is a bit like "VNC done in hardware" (the Sun Ray terminal device, DTU, playing the role of the vncviewer.) _**Completely**_ independent of that, the SunRay user's session is still an X server that speaks the X11 protocol and so **x11vnc** simply talks to the X server part to export the SunRay desktop to any place in the world (i.e. not only to a Sun Ray terminal device), creating a sort of "Soft Ray". Please see [this discussion of Sun Ray issues](sunray.html) for solutions to problems.

Also see the [Sun Ray Remote Control Toolkit](http://wiki.sun-rays.org/index.php/Remote_Control_Toolkit) that uses **x11vnc**.

<font size="-0">**[Remote Control]**</font>
<a name="faq-stop-bg"></a><a name="FAQ-33"></a>

**Q-33:** <font color="#007f00">How do I stop **x11vnc** once it is running in the background?</font>

As of Dec/2004 there is a remote control feature. It can change a huge number of parameters on the fly: see the [`-remote`](x11vnc_opts.html#opt-remote) and [`-query`](x11vnc_opts.html#opt-query) options. To shut down the running **x11vnc** server just type "`x11vnc -R stop`". To disconnect all clients do "`x11vnc -R disconnect:all`", etc.

If the [`-forever`](x11vnc_opts.html#opt-forever) option has not been supplied, **x11vnc** will automatically exit after the first client disconnects. In general if you cannot use the remote control, then you will have to kill the **x11vnc** process This can be done via: "`kill NNNNN`" (where `NNNNN` is the **x11vnc** process id number found from `ps(1)`), or "`pkill x11vnc`", or "`killall x11vnc`" (Linux only.)

If you have not put **x11vnc** in the background via the [`-bg`](x11vnc_opts.html#opt-bg) option or shell `&` operator, then simply press `Ctrl-C` in the shell where **x11vnc** is running to stop it.

_Potential Gotcha:_ If somehow your Keypress of `Ctrl-C` went _through_ **x11vnc** to the Xserver that then delivered it to **x11vnc** it is possible one or both of the `Ctrl` or `C` keys will be left stuck in the pressed down state in the Xserver. Tapping the stuck key (either via a new **x11vnc** or at the physical console) will release it from the stuck state. If the keyboard seems to be acting strangely it is often fixed by tapping `Ctrl`, `Shift`, and `Alt`. Alternatively, the [`-clear_mods`](x11vnc_opts.html#opt-clear_mods) option and [`-clear_keys`](x11vnc_opts.html#opt-clear_keys) option can be used to release pressed keys at startup and exit. The option [`-clear_all`](x11vnc_opts.html#opt-clear_all) will also try to unset Caps_Lock, Num_Lock, etc.

<a name="faq-remote_control"></a><a name="FAQ-34"></a>

**Q-34:** <font color="#007f00">Can I change settings in **x11vnc** without having to restart it? Can I remote control it?</font>

Look at the [`-remote`](x11vnc_opts.html#opt-remote) (an alias is `-R`) and [`-query`](x11vnc_opts.html#opt-query) (an alias is `-Q`) options added in Dec/2004\. They allow nearly everything to be changed dynamically and settings to be queried. Examples: "`x11vnc -R shared`", "`x11vnc -R forever`", "`x11vnc -R scale:3/4`", "`x11vnc -Q modtweak`", "`x11vnc -R stop`", "`x11vnc -R disconnect:all`", etc..

These commands do not start a **x11vnc** server, but rather communicate with one that is already running. The X display (`X11VNC_REMOTE` property) is used as the communication channel, so the X permissions and `DISPLAY` must be set up correctly for communication to be possible.

If no X server is involved (i.e. rawfb mode) then a file may be used as an alternative communication channel, via, say ["`-connect /path/to/somefile`"](x11vnc_opts.html#opt-connect) (both the x11vnc server and the remote control x11vnc processes specify the same "`-connect`" file.)

There is also a simple Tcl/Tk [gui](#faq-config-file) based on this remote control mechanism. See the [`-gui`](x11vnc_opts.html#opt-gui) option for more info. You will need to have Tcl/Tk (i.e. `/usr/bin/wish`) installed for it to work. It can also run in the system tray: "`-gui tray`" or as a standalone small icon window: "`-gui icon`". Use "`-gui tray=setpass`" for a naive user "Share My Desktop" mode.

<font size="-0">**[Security and Permissions]**</font>
<a name="faq-passwd"></a><a name="FAQ-35"></a>

**Q-35:** <font color="#007f00">How do I create a VNC password for use with **x11vnc**?</font>

You may already have one in `$HOME/.vnc/passwd` if you have used, say, the `vncserver` program from the regular RealVNC or TightVNC packages (i.e. launching the `Xvnc` server.) Otherwise, you could use the `vncpasswd(1)` program from those packages.

As of Jun/2004 **x11vnc** supports the `-storepasswd "pass" "file"` [option](x11vnc_opts.html#opt-storepasswd), which is the same functionality of `storepasswd`. Be sure to quote the `"pass"` if it contains shell meta characters, spaces, etc. Example:

<pre>  x11vnc -storepasswd 'sword*fish' $HOME/myvncpasswd
</pre>

You then use the password via the **x11vnc** option: "[`-rfbauth $HOME/myvncpasswd`](x11vnc_opts.html#opt-rfbauth)"

As of Jan/2006 if you do not supply any arguments:

<pre>  x11vnc -storepasswd
</pre>

you will be prompted for a password to save to `~/.vnc/passwd` (your keystrokes when entering the password will not be echoed to the screen.) If you supply one argument, e.g. "`x11vnc -storepasswd ~/.mypass`", the password you are prompted for will be stored in that file.

**x11vnc** also has the [`-passwdfile`](#faq-passwdfile) and `-passwd/-viewpasswd` plain text (i.e. not obscured like the `-rfbauth` VNC passwords) password options.

You can use the [`-usepw`](x11vnc_opts.html#opt-usepw) option to automatically use any password file you have in `~/.vnc/passwd` or `~/.vnc/passwdfile` (the latter is used with the `-passwdfile` option.)

<pre>  x11vnc -usepw -display :0 ...
</pre>

If neither file exists you are prompted to store a password in `~/.vnc/passwd`. If a password file cannot be found or created **x11vnc** exits immediately. An admin may want to set it up this way for users who do not know better.<a name="faq-passwd-noecho"></a><a name="FAQ-36"></a>

**Q-36:** <font color="#007f00">Can I make it so `-storepasswd` doesn't show my password on the screen?</font>

You can use the `vncpasswd` program from RealVNC or TightVNC mentioned above. As of Jan/2006 the `-storepasswd` option without any arguments will not echo your password as you type it and save the file to `~/.vnc/passwd`:

<pre>  # x11vnc -storepasswd
  Enter VNC password: 
  Verify password:    
  Write password to /home/myname/.vnc/passwd?  [y]/n 
  Password written to: /home/myname/.vnc/passwd
</pre>

You can also give it an alternate filename, e.g. "`x11vnc -storepasswd ~/.mypass`"<a name="faq-passwdfile"></a><a name="FAQ-37"></a>

**Q-37:** <font color="#007f00">Can I have two passwords for VNC viewers, one for full access and the other for view-only access to the display?</font>

Yes, as of May/2004 there is the [`-viewpasswd`](x11vnc_opts.html#opt-viewpasswd) option to supply the view-only password. Note the full-access password option [`-passwd`](x11vnc_opts.html#opt-passwd) must be supplied at the same time. E.g.: `-passwd sword -viewpasswd fish`.

To avoid specifying the passwords on the command line (where they could be observed via the `ps(1)` command by any user) you can use the [`-passwdfile`](x11vnc_opts.html#opt-passwdfile) option to specify a file containing plain text passwords. Presumably this file is readable only by you, and ideally it is located on the machine **x11vnc** is run on (to avoid being snooped on over the network.) The first line of this file is the full-access password. If there is a second line in the file and it is non-blank, it is taken as the view-only password. (use "`__EMPTY__`" to supply an empty one.)

View-only passwords currently do not work for the [`-rfbauth`](x11vnc_opts.html#opt-rfbauth) password option (standard VNC password storing mechanism.) FWIW, note that although the output (usually placed in `$HOME/.vnc/passwd`) by the `vncpasswd` or `storepasswd` programs (or from `x11vnc -storepasswd`) looks encrypted they are really just obscured to avoid "casual" password stealing. It takes almost no skill to figure out how to extract the plain text passwords from `$HOME/.vnc/passwd` since it is very straight-forward to work out what to do from the VNC source code.

<a name="faq-multipasswd"></a><a name="FAQ-38"></a>

**Q-38:** <font color="#007f00">Can I have as many full-access and view-only passwords as I like?</font>

Yes, as of Jan/2006 in the **libvncserver** CVS the [`-passwdfile`](x11vnc_opts.html#opt-passwdfile) option has been extended to handle as many passwords as you like. You put the view-only passwords after a line `__BEGIN_VIEWONLY__`.

You can also easily annotate and comment out passwords in the file. You can have **x11vnc** re-read the file dynamically when it is modified.

<a name="faq-unix-passwords"></a><a name="FAQ-39"></a>

**Q-39:** <font color="#007f00">Does **x11vnc** support Unix usernames and passwords? Can I further limit the set of Unix usernames who can connect to the VNC desktop?</font>

**_Update:_** as of Feb/2006 **x11vnc** has the [`-unixpw`](x11vnc_opts.html#opt-unixpw) option that does this outside of the VNC protocol and `libvncserver`. The standard `su(1)` program is used to validate the user's password. A familiar "login:" and "Password:" dialog is presented to the user on a black screen inside the vncviewer. The connection is dropped if the user fails to supply the correct password in 3 tries or does not send one before a 25 second timeout. Existing clients are view-only during this period. A list of allowed Unix usernames may also be supplied along with per-user settings.

There is also the [`-unixpw_nis`](x11vnc_opts.html#opt-unixpw_nis) option for non-shadow-password (typically NIS environments, hence the name) systems where the traditional `getpwnam()` and `crypt()` functions are used instead of `su(1)`. The encrypted user passwords must be accessible to the user running **x11vnc** in `-unixpw_nis` mode, otherwise the logins will always fail even when the correct password is supplied. See `ypcat(1)` and `shadow(5)`.

Two settings are enforced in the `-unixpw` and `-unixpw_nis` modes to provide extra security: the 1) [`-localhost`](x11vnc_opts.html#opt-localhost) and 2) [`-stunnel`](x11vnc_opts.html#opt-stunnel) or [`-ssl`](x11vnc_opts.html#opt-ssl) options. Without these one might send the Unix username and password data in clear text over the network which is a very bad idea. They can be relaxed if you want to provide encryption other than `stunnel` or [`-ssl`](x11vnc_opts.html#opt-ssl) (the constraint is automatically relaxed if `SSH_CONNECTION` is set and indicates you have ssh-ed in, however the `-localhost` requirement is still enforced.)

The two `-unixpw` modes have been tested on Linux, Solaris, Mac OS X, HP-UX, AIX, Tru64, FreeBSD, OpenBSD, and NetBSD. Additional testing is appreciated. For the last 4 it appears that `su(1)` will not prompt for a password if su-ing to **oneself**. Since **x11vnc** requires a password prompt from su, **x11vnc** forces those logins to fail even when the correct password is supplied. On *BSD it appears this can be corrected by removing the `pam_self.so` entry in `/etc/pam.d/su`.

**_Previous older discussion (prior to the -unixpw option):_**

Until the VNC protocol and `libvncserver` support this things will be approximate at best.

One approximate method involves starting **x11vnc** with the [`-localhost`](x11vnc_opts.html#opt-localhost) option. This basically requires the viewer user to log into the workstation where **x11vnc** is running via their Unix username and password, and then somehow set up a port redirection of his `vncviewer` connection to make it appear to emanate from the local machine. As discussed above, `ssh` is useful for this: "`ssh -L 5900:localhost:5900 user@hostname ...`" See the `ssh` wrapper scripts mentioned [elsewhere](index.html#tunnelling) on this page. [stunnel](#faq-ssl-tunnel-ext) does this as well.

Of course a malicious user could allow other users to get in through his channel, but that is a problem with every method. Another thing to watch out for is a malicious user on the _**viewer**_ side (where `ssh` is running) trying to sneak in through the `ssh` port redirection there.

Regarding limiting the set of Unix usernames who can connect, the traditional way would be to further require a VNC password to supplied (`-rfbauth`, `-passwd`, etc) and only tell the people allowed in what the VNC password is. A scheme that avoids a second password involves using the [`-accept`](x11vnc_opts.html#opt-accept) option that runs a program to examine the connection information to determine _which_ user is connecting from the local machine. That may be difficult to do, but, for example, the program could use the `ident` service on the local machine (normally `ident` should not be trusted over the network, but on the local machine it should be accurate: otherwise root has been compromised and so there are more serious problems! Unfortunately recent Linux distros seem to provide a random string (MD5 hash?) instead of the username.) An example script passed in via `-accept scriptname` that deduces the Unix username and limits who can be accepted might look something like this:

<pre>#!/bin/sh
if [ "$RFB_CLIENT_IP" != "127.0.0.1" -o "$RFB_SERVER_IP" != "127.0.0.1" ]; then
	exit 1	# something fishy... reject it.
fi
user=`echo "$RFB_CLIENT_PORT, $RFB_SERVER_PORT" | nc -w 1 $RFB_CLIENT_IP 113 \
	| grep 'USERID.*UNIX' | head -n 1 | sed -e 's/[\r ]//g' | awk -F: '{print $4}'`

for okuser in fred barney wilma betty 
do
	if [ "X$user" = "X$okuser" ]; then
		exit 0	# accept it
	fi
done
exit 1	# reject it
</pre>

For this to work with `ssh` port redirection, the `ssh` option `UsePrivilegeSeparation` must be enabled otherwise the userid will always be "root".

Here is a similar example based on Linux `netstat(1)` output:

<pre>#!/bin/sh
#
# accept_local_netstat:  x11vnc -accept command to accept a local
# vncviewer connection from acceptable users.  Linux netstat -nte is used.

PATH=/bin:/usr/bin:$PATH; export PATH;	# set to get system utils

allowed="`id -u fred`";			# add more user numbers if desired.

# check required settings
ok=1
if [ "X$allowed" = "X" ]; then
	ok=0;	# something wrong with allowed list
fi
if [ "X$RFB_CLIENT_IP" != "X127.0.0.1" -o "X$RFB_SERVER_IP" != "X127.0.0.1" ]; then
	ok=0;	# connection not over localhost
fi
if [ "$RFB_CLIENT_PORT" -le 0 -o "$RFB_SERVER_PORT" -le 0 ]; then
	ok=0;	# something wrong with tcp port numbers
fi
if [ "$ok" = 0 ]; then
	echo "$0: invalid setting:" 1>&2
	env | grep ^RFB | sort 1>&2
	exit 1
fi

# Linux netstat -nte:
# Proto Recv-Q Send-Q Local Address           Foreign Address         State       User       Inode      
# 0     0      0      RFB_CLIENT              RFB_SERVER           ESTABLISHED    nnnn       ....
#
user=`netstat -nte | grep ESTABLISHED \
	| grep " $RFB_CLIENT_IP:$RFB_CLIENT_PORT  *$RFB_SERVER_IP:$RFB_SERVER_PORT "`

echo "netstat match: $user" 1>&2
user=`echo "$user" | head -n 1 | sed -e 's/^.*ESTABLISHED/ /' | awk '{print $1}'`

ok=0
for u in $allowed
do
	if [ "X$user" = "X$u" ]; then
		ok=1
		break
	fi
done

if [ "X$ok" = "X1" ]; then
	echo "$0: user accepted: '$user'" 1>&2
	exit 0
else
	echo "$0: user '$user' invalid:" 1>&2
	echo "$0: allowed: $allowed" 1>&2
	env | grep ^RFB | sort 1>&2
	exit 1
fi
</pre>

<a name="faq-custom-passwords"></a><a name="FAQ-40"></a>

**Q-40:** <font color="#007f00">Can I supply an external program to provide my own custom login method (e.g. Dynamic/One-time passwords or non-Unix (LDAP) usernames and passwords)?</font>

Yes, there are several possibilities. For background see the FAQ on the [`-accept`](#faq-accept-opt) where an external program may be run to decide if a VNC client should be allowed to try to connect and log in. If the program (or local user prompted by a popup) answers "yes", then `-accept` proceeds to the normal VNC and **x11vnc** authentication methods, otherwise the connection is dropped.

To provide more direct coupling to the VNC client's username and/or supplied password the following options were added in Sep/2006:

*   `[-unixpw_cmd](x11vnc_opts.html#opt-unixpw_cmd) _command_`
*   `[-passwdfile](x11vnc_opts.html#opt-passwdfile) cmd:_command_`
*   `[-passwdfile](x11vnc_opts.html#opt-passwdfile) custom:_command_`

In each case "`_command_`" is an external command run by **x11vnc**. You supply it. For example, it may couple to your LDAP system or other servers you set up.

For `[-unixpw_cmd](x11vnc_opts.html#opt-unixpw_cmd)` the normal `[-unixpw](x11vnc_opts.html#opt-unixpw)` Login: and Password: prompts are supplied to the VNC viewer and the strings the client returns are then piped into "`_command_`" as the first two lines of its standard input. If the command returns success, i.e. `exit(0)`, the VNC client is accepted, otherwise it is rejected.

For "`[-passwdfile](x11vnc_opts.html#opt-passwdfile) cmd:_command_`" the command is run and it returns a password list (like a password file, see the `[-passwdfile](x11vnc_opts.html#opt-passwdfile) read:_filename_` mode.) Perhaps a dynamic, one-time password is retrieved from a server this way.

For "`[-passwdfile](x11vnc_opts.html#opt-passwdfile) custom:_command_`" one gets complete control over the VNC challenge-response dialog with the VNC client. **x11vnc** sends out a string of random bytes (16 by the VNC spec) and the client returns the same number of bytes in a way the server can verify only the authorized user could have created. The VNC protocol specifies DES encryption with a password. If you are willing to modify the VNC viewers, you can have it be anything you want, perhaps a less crackable MD5 hash scheme or one-time pad. Your program will read from its standard input the size of the challenge-response followed by a newline, then the challenge bytes followed by the response bytes. If your command then returns success, i.e. `exit(0)`, the VNC client is accepted, otherwise it is rejected.

In all cases the "`RFB_*`" environment variables are set as under [`-accept`](#faq-accept-opt). These variables can provide useful information for the externally supplied program to use.

<a name="faq-forever-shared"></a><a name="FAQ-41"></a>

**Q-41:** <font color="#007f00">Why does **x11vnc** exit as soon as the VNC viewer disconnects? And why doesn't it allow more than one VNC viewer to connect at the same time?</font>

These defaults are simple safety measures to avoid someone unknowingly leaving his X11 desktop exposed (to the internet, say) for long periods of time. Use the [`-forever`](x11vnc_opts.html#opt-forever) option (aka `-many`) to have **x11vnc** wait for more connections after the first client disconnects. Use the [`-shared`](x11vnc_opts.html#opt-shared) option to have **x11vnc** allow multiple clients to connect simultaneously.

Recommended additional safety measures include using `ssh` ([see above](index.html#tunnelling)), stunnel, [`-ssl`](x11vnc_opts.html#opt-ssl), or a VPN to authenticate and encrypt the viewer connections or to at least use the `-rfbauth passwd-file` [option](#faq-passwd) to use VNC password protection (or [`-passwdfile`](#faq-passwdfile)) It is up to _YOU_ to apply these security measures, they will not be done for you automatically.

<a name="faq-allow-opt"></a><a name="FAQ-42"></a>

**Q-42:** <font color="#007f00">Can I limit which machines incoming VNC clients can connect from?</font>

Yes, look at the [`-allow`](x11vnc_opts.html#opt-allow) and [`-localhost`](x11vnc_opts.html#opt-localhost) options to limit connections by hostname or IP address. E.g.

<pre>  x11vnc -allow 192.168.0.1,192.168.0.2
</pre>

for those two hosts or

<pre>  x11vnc -allow 192.168.0.
</pre>

for a subnet. For individual hosts you can use the hostname instead of the IP number, e.g.: "`-allow snoopy`", and "`-allow darkstar,wombat`". Note that `-localhost` achieves the same thing as "`-allow 127.0.0.1`"

For more control, build **libvncserver** with `libwrap` support [(tcp_wrappers)](#faq-tcp_wrappers) and then use `/etc/hosts.allow` See `hosts_access(5)` for complete details.

<a name="faq-tcp_wrappers"></a><a name="FAQ-43"></a>

**Q-43:** <font color="#007f00">How do I build **x11vnc/libvncserver** with `libwrap` (tcp_wrappers) support?</font>

Here is one way to pass this information to the `configure` script:

<pre>  env CPPFLAGS=-DUSE_LIBWRAP LDFLAGS=-lwrap ./configure
</pre>

then run `make` as usual. This requires `libwrap` and its development package (`tcpd.h`) to be installed on the build machine. If additional `CPPFLAGS` or `LDFLAGS` options are needed supply them as well using quotes.

The resulting **x11vnc** then uses libwrap/tcp_wrappers for connections. The service name you will use in `/etc/hosts.allow` and `/etc/hosts.deny` is "`vnc`", e.g.:

<pre>  vnc: 192.168.100.3 .example.com
</pre>

Note that if you run **x11vnc** out of [inetd](#faq-inetd) you do not need to build **x11vnc** with `libwrap` support because the `/usr/sbin/tcpd` reference in `/etc/inetd.conf` handles the tcp_wrappers stuff. Note that the name that inetd/xinetd uses for the `/etc/hosts.allow` and etc. checking will not be "`vnc`" but will be perhaps the basename of the program or a name specified in the inetd/xinetd configuration. So this name will likely be "`x11vnc`", but you probably can configure it to be anything you want.<a name="faq-listen-interface"></a><a name="FAQ-44"></a>

**Q-44:** <font color="#007f00">Can I have **x11vnc** only listen on one network interface (e.g. internal LAN) rather than having it listen on all network interfaces and relying on `-allow` to filter unwanted connections out?</font>

As of Mar/2005 there is the "[`-listen ipaddr`](x11vnc_opts.html#opt-listen)" option that enables this. For `ipaddr` either supply the desired network interface's IP address (or use a hostname that resolves to it) or use the string "`localhost`". For additional filtering simultaneously use the "[`-allow host1,...`](x11vnc_opts.html#opt-allow)" option to allow only specific hosts in.

This option is useful if you want to insure that no one can even begin a dialog with **x11vnc** from untrusted network interfaces (e.g. `ppp0`.) The option [`-localhost`](x11vnc_opts.html#opt-localhost) now implies "`-listen localhost`" since that is what most people expect it to do.

<a name="faq-listen-localhost"></a><a name="FAQ-45"></a>

**Q-45:** <font color="#007f00">Now that `-localhost` implies listening only on the loopback interface, how I can occasionally allow in a non-localhost via the `-R allowonce` remote control command?</font>

To do this specify "[`-allow localhost`](x11vnc_opts.html#opt-allow)". Unlike [`-localhost`](x11vnc_opts.html#opt-localhost) this will leave **x11vnc** listening on all interfaces (but of course only allowing in local connections, e.g. ssh redirs.) Then you can later run "`x11vnc -R allowonce:somehost`" or use to gui to permit a one-shot connection from a remote host.

<a name="faq-input-opt"></a><a name="FAQ-46"></a>

**Q-46:** <font color="#007f00">Can I fine tune what types of user input are allowed? E.g. have some users just be able to move the mouse, but not click or type anything?</font>

As of Feb/2005, the [`-input`](x11vnc_opts.html#opt-input) option allows you to do this. "K", "M", "B", "C", and "F" stand for Keystroke, Mouse-motion, Button-clicks, Clipboard, and File-Transfer, respectively. The setting: "`-input M`" makes attached viewers only able to move the mouse. "`-input KMBC,M`" lets normal clients do everything and enables view-only clients to move the mouse.

These settings can also be applied on a per-viewer basis via the remote control mechanism or the GUI. E.g. `x11vnc -R input:hostname:M`

<a name="faq-accept-opt"></a><a name="FAQ-47"></a>

**Q-47:** <font color="#007f00">Can I prompt the user at the local X display whether the incoming VNC client should be accepted or not? Can I decide to make some clients view-only? How about running an arbitrary program to make the decisions?</font>

Yes, look at the "[`-accept command`](x11vnc_opts.html#opt-accept)" option, it allows you to specify an external command that is run for each new client. (use quotes around the command if it contains spaces, etc.) If the external command returns 0 (success) the client is accepted, otherwise with any other return code the client is rejected. See below how to also accept clients view-only.

The external command will have the `RFB_CLIENT_IP` environment variable set to the client's numerical IP address, `RFB_CLIENT_PORT` its port number. Similarly for `RFB_SERVER_IP` and `RFB_SERVER_PORT` to allow identification of the tcp virtual circuit. `DISPLAY` will be set to that of the X11 display being polled. Also, `RFB_X11VNC_PID` is set to the **x11vnc** process id (e.g. in case you decided to kill it), `RFB_CLIENT_ID` will be an id number, and `RFB_CLIENT_COUNT` the number of other clients currently connected. `RFB_MODE` will be "accept".

**_Built-in Popup Window:_** As a special case, "`-accept popup`" will instruct **x11vnc** to create its own simple popup window. To accept the client press "y" or click mouse on the "Yes" button. To reject the client press "n" or click mouse on the "No" button. To accept the client View-only, press "v" or click mouse on the "View" button. If the [`-viewonly`](x11vnc_opts.html#opt-viewonly) option has been supplied, the "View" action will not be present: the whole display is view only in that case.

The popup window times out after 120 seconds, to change this behavior use "`-accept popup:N`" where `N` is the number of seconds (use 0 for no timeout.) More tricks: "`-accept popupmouse`" will only take mouse click responses, while "`-accept popupkey`" will only take keystroke responses (`popup` takes both.) After any of the 3 popup keywords you can supply a position of the window: `+N+M`, (the default is to center the window) e.g. `-accept popupmouse+10+10`.

Also as a special case "`-accept xmessage`" will run the `xmessage(1)` program to prompt the user whether the client should be accepted or not. This requires that you have `xmessage` installed and available via `PATH`. In case it is not already on your system, the `xmessage` program is available at [ftp://ftp.x.org/](ftp://ftp.x.org/)
(End of _Built-in Popup Window:_)

To include view-only decisions for the external commands, prefix the command something like this: `"yes:0,no:*,view:3 mycommand ..."` This associates the three actions: yes(accept), no(reject), and view(accept-view-only), with the numerical return (i.e. `exit()`) codes. Use "*" instead of a number to set the default action (e.g. in case the external command returns an unexpected return code.)

Here is an example `-accept` script called `accept_or_lock`. It uses `xmessage` and `xlock` (replace with your screen lock command, maybe it is "`xscreensaver-command -lock`", or `kdesktop_lock`, or "`dtaction LockDisplay`".) It will prompt the user at the X display whether to accept, reject, or accept view-only the client, but if the prompt times out after 60 seconds the screen is locked and the VNC client is **_accepted_**. This allows the remote access when no one is at the display.

<pre>#!/bin/sh
#
# accept_or_lock: prompt user at X display whether to accept an incoming
#                 VNC connection.  If timeout expires, screen is locked 
#                 and the VNC viewer is accepted (allows remote access
#                 when no one is sitting at the display.)
#                 
# usage: x11vnc ... -forever -accept 'yes:0,no:*,view:4 accept_or_lock'
#
xmessage -buttons yes:2,no:3,view-only:4 -center \
         -timeout 60 "x11vnc: accept connection from $RFB_CLIENT_IP?"
rc=$?
if [ $rc = 0 ]; then
        xlock & # or "xlock -mode blank" for no animations.
        sleep 5
        exit 0
elif [ $rc = 2 ]; then
        exit 0
elif [ $rc = 4 ]; then
        exit 4
fi
exit 1
</pre>

Stefan Radman has written a nice `dtksh` script [dtVncPopup](dtVncPopup) for use in CDE environments to do the same sort of thing. Information on how to use it is found at the top of the file. He encourages you to provide feedback to him to help improve the script.

Note that in all cases **x11vnc** will block while the external command or popup is being run, so attached clients will not receive screen updates, etc during this period.

To run a command when a client disconnects, use the "[`-gone command`](x11vnc_opts.html#opt-gone)" option. This is for the user's convenience only: the return code of the command is not interpreted by **x11vnc**. The same environment variables are set as in "`-accept command`" (except that `RFB_MODE` will be "gone".)

As of Jan/2006 the "[`-afteraccept command`](x11vnc_opts.html#opt-afteraccept)" option will run the command only after the VNC client has been accepted and authenticated. Like `-gone` the return code is not interpreted. `RFB_MODE` will be "afteraccept".)

<a name="faq-users-opt"></a><a name="FAQ-48"></a>

**Q-48:** <font color="#007f00">I start **x11vnc** as root because it is launched via `inetd(8)` or a display manager like `gdm(1)`. Can I have **x11vnc** later switch to a different user?</font>

As of Feb/2005 **x11vnc** has the [`-users`](x11vnc_opts.html#opt-users) option that allows things like this. Please read the documentation on it (also in the `x11vnc -help` output) carefully for features and caveats. It's use can often _decrease_ security unless care is taken.

BTW, a nice use of it is "`-users +nobody`" that switches to the Unix user `nobody` right after connections to the X display are established.

In any event, while running **x11vnc** as root, remember it comes with no warranty ;-).

<a name="faq-blockdpy"></a><a name="FAQ-49"></a>

**Q-49:** <font color="#007f00">I use a screen-lock when I leave my workstation (e.g. xscreensaver or xlock.) When I remotely access my workstation desktop via **x11vnc** I can unlock the desktop fine, but I am worried people will see my activities on the physical monitor. What can I do to prevent this, or at least make it more difficult?</font>

Probably most work environments would respect your privacy if you powered off the monitor. Also remember if people have physical access to your workstation they basically can do anything they want with it (e.g. install a backdoor for later use, etc.)

In any event, as of Jun/2004 there is an experimental utility to make it more difficult for nosey people to see your **x11vnc** activities. The source for it is [blockdpy.c](http://www.karlrunge.com/x11vnc/blockdpy.c) The idea behind it is simple (but obviously not bulletproof): when a VNC client attaches to **x11vnc** put the display monitor in the DPMS "off" state, if the DPMS state ever changes immediately start up the screen-lock program. The **x11vnc** user will notice something is happening and think about what to do next (while the screen is in a locked state.)

This works (or at least has a chance of working) because if the intruder moves the mouse or presses a key on the keyboard, the monitor wakes up out of the DPMS off state, and this induces the screen lock program to activate as soon as possible. Of course there are cracks in this, the eavesdropper could detach your monitor and insert a non-DPMS one, and there are race conditions. As mentioned above this is not bulletproof. A really robust solution would likely require X server and perhaps even video hardware support.

The `blockdpy` utility is launched by the [`-accept`](x11vnc_opts.html#opt-accept) option and told to exit via the [`-gone`](x11vnc_opts.html#opt-gone) option (the vnc client user should obviously re-lock the screen before disconnecting!) Instructions can be found in the source code for the utility at the above link. Roughly it is something like this:

<pre>  x11vnc ... -accept "blockdpy -bg -f $HOME/.bdpy" -gone "touch $HOME/.bdpy"
</pre>

but please read the top of the file.

_**Update:**_ As of Feb/2007 there is some builtin support for this: [`-forcedpms`](x11vnc_opts.html#opt-forcedpms) and [`-clientdpms`](x11vnc_opts.html#opt-clientdpms) however, they are probably less robust than the above `blockdpy.c` scheme, since if the person floods the physical machine with mouse or pointer input he can usually see flashes of the screen before the monitor is powered off again. See also the [`-grabkbd`](x11vnc_opts.html#opt-grabkbd), [`-grabptr`](x11vnc_opts.html#opt-grabptr), and [`-grabalways`](x11vnc_opts.html#opt-grabptr) options.

<a name="faq-gone-lock"></a><a name="FAQ-50"></a>

**Q-50:** <font color="#007f00">Can I have **x11vnc** automatically lock the screen when I disconnect the VNC viewer?</font>

Yes, a user mentions he uses the [`-gone`](x11vnc_opts.html#opt-gone) option under CDE to run a screen lock program:

<pre>  x11vnc -display :0 -forever -gone 'dtaction LockDisplay'
</pre>

Other possibilities are:

<pre>  x11vnc -display :0 -forever -gone 'xscreensaver-command -lock'
  x11vnc -display :0 -forever -gone 'kdesktop_lock'
  x11vnc -display :0 -forever -gone 'xlock &'
  x11vnc -display :0 -forever -gone 'xlock -mode blank &'
</pre>

Here is a scheme using the [`-afteraccept`](x11vnc_opts.html#opt-afteraccept) option (in version 0.8) to unlock the screen after the first valid VNC login and to lock the screen after the last valid VNC login disconnects:

<pre>  x11vnc -display :0 -forever -shared -afteraccept ./myxlocker -gone ./myxlocker
</pre>

Where the script `./myxlocker` is:

<pre>#!/bin/sh

#/usr/bin/env | grep RFB_ | sort        # for viewing RFB_* settings.

if [ "X$RFB_MODE" = "Xafteraccept" ]; then
        if [ "X$RFB_STATE" = "XNORMAL" ]; then  # require valid login
                if [ "X$RFB_CLIENT_COUNT" = "X1" ]; then
                        killall xlock	# Linux only.
                fi
        fi
elif [ "X$RFB_MODE" = "Xgone" ]; then
        if [ "X$RFB_STATE" = "XNORMAL" ]; then  # require valid login
                if [ "X$RFB_CLIENT_COUNT" = "X0" ]; then
                        xlock -mode blank &
                fi
        fi
fi
</pre>

Note the `xlock` option "`-mode blank`" to avoid animations.

There is a problem if you have **x11vnc** running this way in `-forever` mode and you hit Ctrl-C to stop it. The `xlock` (or other program) will get killed too. To work around this make a little script called `setpgrp` that looks like:

<pre>#!/usr/bin/perl
setpgrp(0, 0);
exec @ARGV;
</pre>

then use `-gone "setpgrp xlock &"`, etc. 
<font size="-0">**[Encrypted Connections]**</font>
<a name="faq-ssh-unix"></a><a name="FAQ-51"></a>

**Q-51:** <font color="#007f00">How can I tunnel my connection to **x11vnc** via an encrypted SSH channel between two Unix machines?</font>

See the description earlier on this page on [how to tunnel VNC via SSH from Unix to Unix](index.html#tunnelling). A number of ways are described along with some issues you may encounter.

Other secure encrypted methods exists, e.g. `stunnel`, `IPSEC`, various VPNs, etc.

See also the [Enhanced TightVNC Viewer (SSVNC)](ssvnc.html) page where much of this is now automated.

<a name="faq-ssh-putty"></a><a name="FAQ-52"></a>

**Q-52:** <font color="#007f00">How can I tunnel my connection to **x11vnc** via an encrypted SSH channel from Windows using an SSH client like Putty?</font>

[Above we described how to tunnel VNC via SSH from Unix to Unix](index.html#tunnelling), you may want to review it. To do this from Windows using Putty it would go something like this:

*   In the Putty dialog window under _'Session'_ enter the hostname or IP number of the Unix machine with display to be viewed.
*   Make sure the SSH protocol is selected and the server port is correct.
*   Under _'Connections/SSH/Tunnels'_ Add a Local connection with _'Source port:  5900'_ and _'Destination:  localhost:5900'_
*   Log into the remote machine by pressing _'Open'_ and supplying username, password, etc.
*   In that SSH shell, start up **x11vnc** by typing the command: `x11vnc -display :0` plus any other desired options (e.g. `-localhost`.)
*   Finally, start up your VNC Viewer in Windows and enter _'localhost:0'_ as the VNC server.

You can keep all of the settings in a Putty 'Saved Session'. Also, once everything is working, you can consider putting `x11vnc -display :0` (plus other cmdline options) in the _'Remote command'_ Putty setting under _'Connections/SSH'_.

See also the [Enhanced TightVNC Viewer (SSVNC)](ssvnc.html) page where much of this is now automated via the Putty `plink` utility.

For extra protection feel free to run **x11vnc** with the [`-localhost`](x11vnc_opts.html#opt-localhost) and `[-rfbauth](x11vnc_opts.html#opt-rfbauth)/[-passwdfile](x11vnc_opts.html#opt-passwdfile)` options.

If the machine you SSH into via Putty is not the same machine with the X display you wish to view (e.g. your company provides incoming SSH access to a gateway machine), then you need to change the above Putty dialog setting to: _'Destination: **otherhost**:5900'_, Once logged in, you'll need to do a second login (`ssh` or `rsh`) to the workstation machine 'otherhost' and then start up **x11vnc** on it. This can also be automated by [Chaining SSH's](chainingssh.html#gateway_double_ssh).

As discussed [above](index.html#tunnelling) another option is to first start the VNC viewer in "listen" mode, and then launch **x11vnc** with the "[`-connect localhost`](x11vnc_opts.html#opt-connect)" option to establish the reverse connection. In this case a Remote port redirection (not Local) is needed for port 5500 instead of 5900 (i.e. _'Source port:  5500'_ and _'Destination:  localhost:5500'_ for a Remote connection.)

<a name="faq-ssl-tunnel-ext"></a><a name="FAQ-53"></a>

**Q-53:** <font color="#007f00">How can I tunnel my connection to **x11vnc** via an encrypted SSL channel using an external tool like `stunnel`?</font>

It is possible to use a "lighter weight" encryption setup than SSH or IPSEC. SSL tunnels such as [stunnel](http://stunnel.mirt.net) (also [stunnel.org](http://www.stunnel.org)) provide an encrypted channel without the need for Unix users, passwords, and key passphrases required for `ssh` (and at the other extreme SSL can also provide a _complete_ signed certificate chain of trust.) On the other hand, since SSH is usually installed _everywhere_ and firewalls often let its port through, `ssh` is frequently the path of least resistance (it also nicely manages public keys for you.)

_**Update**:_ As of Feb/2006 **x11vnc** has the options [`-ssl`](x11vnc_opts.html#opt-ssl), [`-stunnel`](x11vnc_opts.html#opt-stunnel), and [`-sslverify`](x11vnc_opts.html#opt-sslverify) to provide integrated SSL schemes. They are discussed [in the Next FAQ](#faq-ssl-tunnel-int) (you probably want to skip to it now.)

We include these non-built-in method descriptions below for historical reference. They are handy because can be used to create SSL tunnels to any VNC (or other type of) server.

Here are some basic examples using [stunnel](http://stunnel.mirt.net) but the general idea for any SSL tunnel utility is the same:

*   Start up **x11vnc** and constrain it to listen on localhost.
*   Then start up the SSL tunnel running on the same machine to forward incoming connections to that **x11vnc**.
*   Set up and run a similar SSL tunnel for the _outgoing_ connection on the VNC viewer machine pointing it to the SSL/x11vnc server.
*   Optionally, set up server (or even client) public/private keys for use in authenticating one side to the other.
*   Finally, start the VNC Viewer and tell it to connect to the local port (e.g. a vnc display `localhost:0`) where its outgoing SSL tunnel is listening.

We'll first use the `stunnel` version 3 syntax since it is the most concise and Unixy.

Start up **x11vnc** listening on port 5900:

<pre>  x11vnc -display :0 -rfbport 5900 -localhost -bg -passwdfile ~/mypass
</pre>

Then start `stunnel` (version 3, not 4) with this command:

<pre>  stunnel -d 5901 -r 5900 -p /path/to/stunnel.pem
</pre>

The above two commands are run on host "`far-away.east`". The `stunnel.pem` is the self-signed PEM file certificate created when `stunnel` is built. One can also create certificates [signed by Certificate Authorities](ssl.html) or self-signed if desired using the **x11vnc** utilities described there.

<a name="infaq_viewer-side-stunnel"></a>**_SSL Viewers_**:  Next, on the **VNC viewer side** we need an SSL tunnel to encrypt the outgoing connection. The nice thing is _any_ SSL tunnel can be used because the protocol is a standard. For this example we'll also use `stunnel` on the viewer side on Unix. First start up the client-side `stunnel` (version 3, not 4):

<pre>  stunnel -c -d localhost:5902 -r far-away.east:5901
</pre>

Then point the viewer to the local tunnel on port 5902:

<pre>  vncviewer -encodings "copyrect tight zrle hextile" localhost:2
</pre>

That's it.  Note that the [ss_vncviewer](#ss_vncviewer) script can automate this easily, and so can the [Enhanced TightVNC Viewer (SSVNC)](ssvnc.html) package.

Be sure to use a VNC password because unlike `ssh` by default the encrypted SSL channel provides no authentication (only privacy.) With some extra configuration one could also set up certificates to provide authentication of either or both sides as well (and hence avoid man-in-the-middle attacks.) See the stunnel and openssl documentation and also [the key management section](ssl.html) for details.

<a name="infaq_stunnel-conf">`stunnel` has also been ported to Windows, and there are likely others to choose from for that OS. Much info for using it on Windows can be found at the stunnel site and in this</a> [article](http://www.securityfocus.com/infocus/1677) The article also shows the detailed steps to set up all the authentication certificates. (for both server and clients, see also the [x11vnc utilities](ssl.html) that do this.) The default Windows client setup (no certs) is simpler and only 4 files are needed in a folder: `stunnel.exe, stunnel.conf, libssl32.dll, libeay32.dll`. We used an `stunnel.conf` containing:

<pre># stunnel.conf:
client = yes
options = ALL
[myvncssl]
accept = localhost:5902
connect = far-away.east:5901
</pre>

then double click on the `stunnel.exe` icon to launch it (followed by pointing the VNC viewer to localhost:2).

_stunnel inetd-like mode:_

As an aside, if you don't like the little "gap" of unencrypted TCP traffic (and a localhost listening socket) on the local machine between stunnel and **x11vnc** it can actually be closed by having `stunnel` start up **x11vnc** in <a name="infaq_stunnel-inetd"></a>[`-inetd`](x11vnc_opts.html#opt-inetd) mode:

<pre>  stunnel -p /path/to/stunnel.pem -P none -d 5900 -l ./x11vnc_sh
</pre>

Where the script `x11vnc_sh` starts up **x11vnc**:

<pre>#!/bin/sh
x11vnc -q -inetd -display :0 -passwdfile ~/mypass
</pre>

Note that this creates a separate **x11vnc** process for each incoming connection (as any inetd x11vnc usage would), but for the case of normally just one viewer at a time it should not be a big problem.

_stunnel 4 syntax:_

Somewhat sadly, the `stunnel` version 4 syntax is not so amenable to the command line or scripts. You need to create a config file with the parameters. E.g.:

<pre>  stunnel x11vnc.cfg
</pre>

Where the file `x11vnc.cfg` contains:

<pre>foreground = yes
pid =
cert = /path/to/stunnel.pem
[x11vnc_stunnel]
accept  = 5901
connect = 5900
</pre>

One nice thing about version 4 is often the PEM file does not need to be specified because `stunnel` finds it in its installed area. One other gotcha the PEM file is usually only readable by root (it has the private key afterall), so you'll need to relax the permissions or make a copy that the user running x11vnc/stunnel can read.

<a name="infaq_ssl-vnc-viewers"></a>_SSL VNC Viewers:_

Regarding VNC viewers that "natively" do SSL unfortunately there do not seem to be many. The [SingleClick UltraVNC Java Viewer](http://sc.uvnc.com/javaviewer/index.html) is SSL and is compatible with **x11vnc**'s [`-ssl`](x11vnc_opts.html#opt-ssl) option and stunnel.) Commercial versions of VNC seem to have some SSL-like encryption built in, but we haven't tried those either and they probably wouldn't work since their (proprietary) SSL-like negotiation is likely embedded in the VNC protocol unlike our case where it is external.

_Note:_ as of Mar/2006 `libvncserver/x11vnc` provides a [SSL-enabled Java applet](#faq-ssl-tunnel-viewers) that can be served up via the [`-httpdir`](x11vnc_opts.html#opt-httpdir) or [`-http`](x11vnc_opts.html#opt-http) options when [`-ssl`](x11vnc_opts.html#opt-ssl) is enabled. It will also be served via HTTPS via either the VNC port (e.g. `https://host:5900/`) or a 2nd port via the [`-https`](x11vnc_opts.html#opt-https) option.

In general current SSL VNC solutions are not particularly "seemless". But it can be done, and with a wrapper script on the viewer side and the [`-stunnel`](x11vnc_opts.html#opt-stunnel) or [`-ssl`](x11vnc_opts.html#opt-ssl) option on the server side it works well and is convenient. Here is a simple script [ss_vncviewer](#ss_vncviewer) that automates running `stunnel` on the VNC viewer side on Unix a little more carefully than the commands printed above. (One could probably do a similar thing with a `.BAT` file on Windows in the stunnel folder.)

_**Update** Jul/2006:_ we now provide an [Enhanced TightVNC Viewer (SSVNC)](ssvnc.html) package that starts up STUNNEL automatically along with some other features. All binaries (`stunnel`, `vncviewer`, and some utilities) are provided in the package. It works on Unix, Mac OS X, and Windows.

<a name="faq-ssl-tunnel-int"></a><a name="FAQ-54"></a>

**Q-54:** <font color="#007f00">Does **x11vnc** have built-in SSL tunneling?</font>

You can read about non-built-in methods [in the Previous FAQ](#faq-ssl-tunnel-ext) for background.

SSL tunnels provide an encrypted channel without the need for Unix users, passwords, and key passphrases required for `ssh` (and at the other extreme SSL can also provide a complete signed certificate chain of trust.) On the other hand, since SSH is usually installed _everywhere_ and firewalls often let its port through, `ssh` is frequently the path of least resistance.

_Built-in SSL x11vnc options:_

As of Feb/2006 the **x11vnc** [`-ssl`](x11vnc_opts.html#opt-ssl) option automates the SSL tunnel creation on the **x11vnc** server side. An [SSL-enabled Java Viewer applet](#faq-ssl-tunnel-viewers) is also provided that can be served via `HTTP` or `HTTPS` to automate SSL on the client side.

The [`-ssl`](x11vnc_opts.html#opt-ssl) mode uses the [www.openssl.org](http://www.openssl.org/) library if available at build time.

The mode requires an SSL certificate and key (i.e. `.pem` file.) These are usually created via the `openssl(1)` program (in fact in for "`-ssl`" (same as "`-ssl SAVE`") it will run `openssl` for you automatically.) So the SSL is not completely "built-in" since this external tool needs to be installed, but at least **x11vnc** runs it for you automatically.

An `-ssl` example:

<pre>  x11vnc -display :0 -ssl -passwdfile ~/mypass
</pre>

You'll get output like this:

<pre>  09/04/2006 19:27:35 Creating a self-signed PEM certificate...
  09/04/2006 19:27:35 
  ...

  The SSL VNC desktop is:  far-away.east:0
  PORT=5900
  SSLPORT=5900
</pre>

In this case `openssl(1)` was used to create a PEM automatically. It will prompt you if you want to protect it with with a passphrase. Use "`-ssl SAVE_NOPROMPT`" to not be prompted. Use "`-ssl TMP`" to create a temporary self-signed cert that will be discarded when x11vnc exits.

_**Update**:_ As of Nov/2008 **x11vnc** also supports the [VeNCrypt](http://sourceforge.net/projects/vencrypt/) SSL/TLS tunnel extension to the VNC protocol. The older ANONTLS method (vino) is also supported. This support is on by default when the `-ssl` option is in use and can be fine-tuned using these options: [`-vencrypt`](x11vnc_opts.html#opt-vencrypt), [`-anontls`](x11vnc_opts.html#opt-anontls), and [`-sslonly`](x11vnc_opts.html#opt-sslonly).

The normal **x11vnc** `-ssl` operation is somewhat like a URL method `vncs://hostname` if `vnc://hostname` indicates a standard _unencrypted_ VNC connection. Just as `https://hostname` is an SSL encrypted version of `http://hostname`. The entire VNC session goes through the SSL tunnel. VeNCrypt, on the other hand, switches to SSL/TLS early in the VNC protocol handshake. **x11vnc** 0.9.6 supports both simultaneously when `-ssl` is active.

_**SSL VNC Viewers:**_. Viewer-side will need to use SSL as well. See the [next FAQ](#faq-ssl-tunnel-viewers) and [here](faq.html#infaq_ssl-vnc-viewers) for SSL enabled VNC **Viewers**, including SSVNC, to connect to the above **x11vnc** via SSL.

As seen above, the PEM (privacy enhanced mail) file does not need to be supplied if the `openssl(1)` command is available in `PATH`, in that case a self-signed, certificate good the current and subsequent **x11vnc** sessions is created (this may take a while on very slow machines.)

In general, the PEM file contains both the Certificate (i.e. public key) and the Private Key. Because of the latter, the file should be protected from being read by untrusted users. The best way to do this is to encrypt the key with a passphrase (note however this requires supplying the passphrase each time **x11vnc** is started up.)

See the discussion on [x11vnc Key Management](ssl.html) for some utilities provided for creating and managing certificates and keys and even for creating your own Certificate Authority (CA) for signing VNC server and client certificates. This may be done by importing the certificate into Web Browser or Java plugin keystores, or pointing `stunnel` to it. The wrapper script [ss_vncviewer](#ss_vncviewer) provides an example on unix (see the `-verify` option.)

Here are some notes on the simpler default (non-CA) operation. To have **x11vnc** save the generated certificate and key, use the "`SAVE`" keyword like this:

<pre>  x11vnc -ssl SAVE -display :0 ...
</pre>

(this is the same as the default: "`-ssl`".) This way it will be saved in the default directory `~/.vnc/certs/` as `server.crt` (the certificate only) and `server.pem` (both certificate and private key.) This opens up the possibility of copying the `server.crt` to machines where the VNC Viewer will be run to enable authenticating the **x11vnc** SSL VNC server to the clients. When authentication takes place this way (or via the more sophisticated CA signing described [here](ssl.html)), then Man-In-The-Middle-Attacks are prevented. Otherwise, the SSL encryption only provides protection against passive network traffic "sniffing" (i.e. you are not protected against M-I-T-M attacks.) Nowadays, most people seem mostly concerned mainly about passive sniffing (and the default **x11vnc** SSL mode protects against it.) Note that there are hacker tools like dsniff/webmitm and cain that implement SSL Man-In-The-Middle attacks. They rely on the client not bothering to check the cert.One can test to some degree that SSL is working after starting **x11vnc** with the `-stunnel` or `-ssl` option. From another machine one can use the `openssl` command something like this:

<pre> openssl s_client -debug -msg -showcerts -connect far-away.east:5900
</pre>

After all of the debugging output and informational messages you'll see the string "`RFB 003.008`" that came from **x11vnc**. Pointing a web browser connecting to: `https://far-away.east:5900/` and then viewing the SSL certificate information about the connection in the panels will also work.

Note: If you serve up the SSL enabled Java VNC Viewer via something like:

<pre> x11vnc -ssl -httpdir /usr/local/share/x11vnc/classes/ssl
</pre>

(or just the `-http` option), you can test it out completely using that, including using `https` to download it into the browser and connect to **x11vnc**._**The older `-stunnel` option:**_ Before the `-ssl` option there was a convenience option [`-stunnel`](x11vnc_opts.html#opt-stunnel) that would start an external SSL tunnel for you using `stunnel`. The `-ssl` method is the preferred way, but for historical reference we keep the `-stunnel` info here.

The [`-stunnel`](x11vnc_opts.html#opt-stunnel) mode requires the [stunnel.mirt.net](http://stunnel.mirt.net/) command `stunnel(8)` to be installed on the system.

Some `-stunnel` examples:

<pre>  x11vnc -display :0 -stunnel /path/to/stunnel.pem -passwdfile ~/mypass

  x11vnc -display :0 -stunnel SAVE ...
</pre>

You'll get output like this:

<pre>  The VNC desktop is:      localhost:50
  The SSL VNC desktop is:  far-away.east:0
  PORT=5950
  SSLPORT=5900
</pre>

That indicates stunnel is listening on port 5900 for incoming SSL-wrapped VNC connections from viewers. **x11vnc** is listening for _local_ connections on port 5950 in this case (remote viewers cannot connect to it directly.) For `-stunnel` to work the stunnel command must be installed on the machine and available in `PATH` (note stunnel is often installed in `sbin` directories rather than `bin`.) Note that the default "`-stunnel`" by itself creates a temporary cert (as in "`-ssl TMP`".)<a name="faq-ssl-tunnel-viewers"></a><a name="FAQ-55"></a>

**Q-55:** <font color="#007f00">How do I use VNC Viewers with built-in SSL tunneling?</font>

**_Notes on using "native" VNC Viewers with SSL:_**

There aren't any native VNC Viewers that do SSL (ask your VNC viewer developer to add the feature.) So a tunnel must be setup that you point the VNC Viewer to. This is often STUNNEL. You can do this [manually](faq.html#infaq_viewer-side-stunnel), or use the [ss_vncviewer](#ss_vncviewer) script on Unix, or our [Enhanced TightVNC Viewer (SSVNC)](ssvnc.html) package on Unix, Windows, or MacOSX. See the next section for Java Web browser SSL VNC Viewers (you only need a Java-enabled Web browser for it to work.)

**_Notes on the SSL enabled Java VNC Viewer provided in x11vnc_** `classes/ssl/VncViewer.jar`:

A Java applet VNC Viewer allows you to connect to a VNC Server from a Java-enabled Web browser.

The SSL enabled Java VNC Viewer (`VncViewer.jar`) in the **x11vnc** package supports _only_ SSL based connections by default. As mentioned above the [`-httpdir`](x11vnc_opts.html#opt-httpdir) can be used to specify the path to `.../classes/ssl`. A typical location might be `/usr/local/share/x11vnc/classes/ssl`. Or [`-http`](x11vnc_opts.html#opt-http) can be used to try to have it find the directory automatically.

Also note that the [SingleClick UltraVNC Java Viewer](http://sc.uvnc.com/javaviewer/index.html) is compatible with **x11vnc**'s [`-ssl`](x11vnc_opts.html#opt-ssl) SSL mode. (We tested it this way: "`java -cp ./VncViewer.jar VncViewer HOST far-away.east PORT 5900 USESSL 1 TRUSTALL 1`")

The Java viewer uses SSL to communicate securely with **x11vnc**. Note that the applet can _**optionally also**_ be downloaded into your web browser via `HTTPS` (which is `HTTP` over `SSL`.) This way the HTML page and the Java applet itself are _also_ delivered securely with SSL (as opposed to only the VNC traffic being encrypted with SSL.)

For this case the output will be something like this:

<pre>  x11vnc -ssl SAVE -http 
  ...
  The SSL VNC desktop is:  far-away.east:0
  Java SSL viewer URL:     https://far-away.east:5900/
  Java SSL viewer URL:     http://far-away.east:5800/
  PORT=5900
  SSLPORT=5900
</pre>

Indicating the two URLs (the first one encrypted, the second not) one could point the web browser at to get the VNC viewer applet. E.g. put this

<pre>   http://far-away.east:5800/
</pre>

or:

<pre>   https://far-away.east:5900/
</pre>

into your Java-enabled Web browser.

Note that KDE's Konqueror web browser seems to have problems with https Java applets, so you'll have to use the http/5800 with it (if you get https/5900 working let us know how you did it.)

If you are using a router/firewall with port-redirection, and you are redirecting ports other than the default ones (5800, 5900) listed above [see here](faq.html#infaq_ssl-router-redir).

The `https` service provided thru the actual VNC port (5900 in the above example) can occasionally be slow or unreliable (it has to read some input and try to guess if the connection is VNC or HTTP.) If it is unreliable for you and you still want to serve the Java applet via `https`, use the [`-https`](x11vnc_opts.html#opt-https) option to get an additional port dedicated to `https` (its URL will also be printed in the output.)

Another possibility is to add the `GET` applet parameter:

<pre>  https://far-away.east:5900/?GET=1
</pre>

This will have the VNC Viewer send a special HTTP GET string "`GET /request.https.vnc.connection HTTP/1.0`" that **x11vnc** will notice more quickly as a request for a VNC connection. Otherwise it must wait for a timeout to expire before it assumes a VNC connection.

You may also use "`urlPrefix=somestring`" to have `/somestring` prepended to `/request.https.vnc.connection`". Perhaps you are using a web server [proxy scheme](#faq-ssl-portal) to enter a firewall or otherwise have rules applied to the URL. If you need to have any slashes "`/`" in "somestring" use "`_2F_`" (a deficiency in libvncserver prevents using the more natural "`%2F`".)

You apply multiple applet parameters in the regular URL way, e.g.:

<pre>  https://far-away.east:5900/?GET=1&urlPrefix=mysubdir&...
</pre>

All of the **x11vnc** Java Viewer applet parameters are described in the file `classes/ssl/README`

<a name="infaq_first-time-https"></a>_**Tips on Getting the SSL Java Applet Working the First Time:**_  Unfortunately, it can be a little tricky getting the SSL VNC Java Viewer working with **x11vnc**. Here are some tips to getting working the first time (afterwards you can incrementally customize with more complex settings.)

*   **First try it on the LAN:** Do **NOT** try to have it work the first time going through firewalls, Web proxies, home router port redirections, or Apache portal. Just try a direct connection over your LAN first (if you only have 1 machine and no LAN, just do a direct connection to the same machine: `localhost`.) If the LAN machine you run x11vnc on has its own host-level firewall (most linux machine come with that on by default), disable it or at least let tcp ports 5800-6000 through.
*   **First try HTTP to download the Java Applet:** x11vnc can serve both the Java Applet jar file and VNC out of the same port (both tunneled through SSL, see below.) But it can lead to timing and other problems. So first try HTTP instead of HTTPS to download the Applet jar file (`VncViewer.jar`.) That is to say try `http://hostname:5800` in your web browser first before trying `https://hostname:5900`. **x11vnc** will print out the ports and URLs it is using, so use the HTTP one it prints out.
*   **Always Restart the Browser:** If you are having failures and have to repeatedly retry things **ALWAYS** restart the browser (i.e. completely exit it and then start a new browser process) each time. Otherwise as you are changing things the browser may "remember" failed applet downloads, etc. and just add to the confusion and irreproducibility. If you see it trying to download `VncViewer.class` (instead of `VncViewer.jar`) you know it is really confused and needs to be restarted.
*   **Step Lively:** If you get Browser or Java VM or VNC Viewer applet dialog boxes saying things like "Do you want to trust this certificate?" or "The hostname does not match the one on the certificate", etc. just go through them as quickly as possible. **x11vnc** cannot wait forever for each SSL connection, and so if you dawdle too long inspecting the certs, etc it can lead to problems. Get it working first before taking your time to read the details in the dialogs, etc.
*   **No inetd, Please:** Even if you intend to deploy via `inetd` or `xinetd` eventually, get that working **later** (and remember do not use something like "`-ssl TMP`" that creates a new temporary SSL certificate for every new socket connection.)
*   **Nothing Fancy:** Do not try fancy stuff like `-svc`, `-create`, `-unixpw`, "`-users unixpw=`", "`-users sslpeer=`", `-sslverify`, etc. Just get the simplest connection working first and then incrementally add what you need.

So the recommended test command lines are:

<pre>   x11vnc -ssl SAVE -http
   x11vnc -ssl SAVE -httpdir /path/to/x11vnc/classes/ssl
</pre>

Use the latter if **x11vnc** cannot automatically find the `classes/ssl` directory (this what the `-http` option instructs it to do.) Then point your browser to the HTTP (not HTTPS) URL it prints out.

Following the above guidelines, did it work? If so, Congratulations!! you created an SSL encrypted connection between the SSL Java applet running in your web browser and **x11vnc**. The fact that you used HTTP instead of HTTPS to download the applet is not the end of the world (some users do it this way), the main thing is that the _**VNC**_ traffic is encrypted with SSL. If you are having trouble even with the above baseline test case feel free to contact me (please send the _Full_ x11vnc output, not just part of it; the complete x11vnc command line; the URL(s) entered in the browser; the full Java Console output; and anything else you can think of.)

Next, you can add the features you want one by one testing it still works each time. I suggest first turning on the HTTPS applet download (`https://hostname:5900`) if that is what you intend to use. That one gives the most trouble because of the ambiguity of passing two different protocols (HTTP and VNC) through the same SSL service port.

Next, turn on `inetd` if you intend to use that (this can be tricky too, be sure to use `-oa logfile` and inspect it carefully if there are problems.) If you are going to use non-standard ports (e.g. "`-rfbport 443`" as root), work on that next. Then enable the firewall, router port redirection channel (you will somehow need to be outside to do that, maybe test that through another VNC session.)

Then, if you plan to use them, enable "fancy stuff" like "`-svc`" or "`-unixpw`", etc, etc. Be sure to add a password either "`-rfbauth`" or "`-unixpw`" or both. If you need to have the web browser use a corporate [Web Proxy](#faq-ssl-java-viewer-proxy) (i.e. it cannot connect directly) work on that last. Ditto for the [Apache portal](#faq-ssl-portal).

<a name="infaq_ssl-router-redir"></a>**_Router/Firewall port redirs:_**  If you are doing port redirection at your [router](index.html#firewalls) to an internal machine running **x11vnc** AND the internet facing port is different from the internal machine's VNC port, you will need to apply the `PORT` applet parameter to indicate to the applet the Internet facing port number (otherwise by default the internal machine's port, say 5900, is sent and that of course is rejected at the firewall/router.) For example:

<pre>  https://far-away.east:443/?GET=1&PORT=443
</pre>

So in this example the user configures his router to redirect connections to port 443 on his Internet side to, say, port 5900 on the internal machine running **x11vnc**. See also the [`-httpsredir`](x11vnc_opts.html#opt-httpsredir) option that will try to automate this for you.

To configure your router to do port redirection, see its instructions. Typically, from the inside you point a web browser to a special URL (e.g. http://192.168.1.1) and you get a web interface to configure it. Look for something like "Port Redirection" or "Port Forwarding", probably under "Advanced" or something like that. If you have a Linux or Unix system acting as your firewall/router, see its firewall configuration.

You can also use **x11vnc** options [`-rfbport NNNNN`](x11vnc_opts.html#opt-rfbport) and [`-httpport NNNNN`](x11vnc_opts.html#opt-httpport) to match the ports that your firewall will be redirecting to the machine where **x11vnc** is run.

**_Tedious Dialogs:_** If you do serve the SSL enabled Java viewer via `https` be prepared for quite a number of "are you sure you trust this site?" dialogs:

*   First from the Web browser that cannot verify the self-signed certificate when it downloads `index.vnc`.
*   From the Web browser again noting that the common name on the certificate does not match the hostname of the remote machine.
*   Next from the Java VM that cannot verify the self-signed certificate when it downloads `VncViewer.jar`.
*   And also from the Java VM again noting that the common name on the certificate does not match the hostname of the remote machine.
*   Finally from the Java VncViewer applet itself saying it cannot verify the certificate! (or a popup asking you if you want to see the certificate.)

Note that sometimes if you pause too long at one of the above dialogs then **x11vnc** may exceed a timeout and assume the current socket connection is VNC instead of the HTTPS it actually is (but since you have paused too long at the dialog the GET request comes too late.) Often hitting Reload and going through the dialogs more quickly will let you connect. **The Java VM dialogs are the most important ones to NOT linger at**. If you see in the **x11vnc** output a request for `VncViewer.class` instead of `VncViewer.jar` it is too late... you **will** need to completely restart the Web browser to get it to try for the jar again. You can use the [`-https`](x11vnc_opts.html#opt-https) option if you want a dedicated port for HTTPS connections instead of sharing the VNC port.

To see example **x11vnc** output for a successful `https://host:5900/` connection with the Java Applet see [This Page](ssl-output.html). And here is a newer example [including the Java Console output](java_console_direct.html).

All of the **x11vnc** Java Viewer applet parameters are described in the file `classes/ssl/README`

<a name="infaq_ss_vncviewer"></a><a name="ss_vncviewer">**_Notes on the VNC Viewer ss_vncviewer wrapper script:_**</a>

<a name="ss_vncviewer">If you want to use a native VNC Viewer with the SSL enabled **x11vnc** you will need to run an external SSL tunnel on the Viewer side. There do not seem to be any native SSL VNC Viewers outside of our **x11vnc** and</a> [SSVNC](ssvnc.html) packages. The basic ideas of doing this were discussed [for external tunnel utilities here](#faq-ssl-tunnel-ext).

The [ss_vncviewer](ss_vncviewer) script provided with **x11vnc** and SSVNC can set up the `stunnel` tunnel automatically on unix as long as the `stunnel` command is installed on the Viewer machine and available in PATH (and `vncviewer` too of course.) Note that on a Debian based system you will need to install the package `stunnel4` not `stunnel`. You can set the environment variables `STUNNEL` and `VNCVIEWERCMD` to point to the correct programs if you want to override the defaults.

Here are some examples:

<pre>  1)  ss_vncviewer far-away.east:0

  2)  ss_vncviewer far-away.east:0 -encodings "copyrect tight zrle hextile"

  3)  ss_vncviewer -verify ./server.crt far-away.east:0

  4)  ss_vncviewer -mycert ./client.pem far-away.east:0

  5)  ss_vncviewer -proxy far-away.east:8080 myworkstation:0
</pre>

The first one is the default mode and accepts the **x11vnc** certificate without question. The second one is as the first, but adds the `-encodings` options to the `vncviewer` command line.

The third one requires that the **x11vnc** server authenticate itself to the client against the certificate in the file `./server.crt` (e.g. one created by "`x11vnc -ssl SAVE`" and safely copied to the VNC viewer machine.)

The fourth one is for VNC Viewer authentication, it uses `./client.pem` to authenticate itself to **x11vnc**. One can supply both `-verify` and `-mycert` simultaneously.

The fifth one shows that Web proxies can be used if that is the only way to get out of the firewall. If the "double proxy" situation arises separate the two by commas. See [this page](ssl-portal.html) for more information on how Web proxies come into play.

If one uses a Certificate Authority (CA) scheme described [here](ssl.html), the wrapper script would use the CA cert instead of the server cert:

<pre>  3')  ss_vncviewer -verify ./cacert.crt far-away.east:0
</pre>

_**Update** Jul/2006:_ we now provide an [Enhanced TightVNC Viewer (SSVNC)](ssvnc.html) package that starts up STUNNEL automatically along with some other features. All binaries (`stunnel`, `vncviewer`, and some utilities) are provided in the package. It works on Unix, Mac OS X, and Windows.

<a name="faq-ssl-java-viewer-proxy"></a><a name="FAQ-56"></a>

**Q-56:** <font color="#007f00">How do I use the Java applet VNC Viewer with built-in SSL tunneling when going through a Web Proxy?</font>

**_The SSL enabled Java VNC Viewer and firewall Proxies_**:

SSL and HTTPS aside, there is a general problem with Firewall Proxies and Java Applets that open sockets. The applet is downloaded successfully (through the browser) using HTTP and the proxy, but when the applet tries to reconnect to the originating host (the only one allowed by security) it does not use the proxy channel. So it cannot reconnect to the server the applet came from!

We have found a convenient workaround: in the directory where `VncViewer.jar` resides there is a digitally _**signed**_ version of the same applet called `SignedVncViewer.jar`. Since the applet is digitally signed, there will be an additional dialog from the Java VM plugin asking you if you want to trust the applet fully.

You should say "Yes". If you do, the applet will be run in a mode where it can try to determine the firewall proxy host name and port (it will ask you for them if it cannot find them.) This way it can connect _directly_ to the Proxy and then request the `CONNECT` method to be redirected to the originating host (the **x11vnc** VNC Server.) SSL is then layered over this socket.

To do this you should use the `proxy.vnc` HTML file like via this URL in your browser:

<pre>  https://yourmachine.com:5900/proxy.vnc
</pre>

(instead of the unsigned one in `https://yourmachine.com:5900/` that gives the default `index.vnc`)**_Proxies that limit `CONNECT` to ports 443 and 563_**:

Things become trickier if the Web proxy **restricts** which `CONNECT` ports can be redirected to. For security, some (most?) proxies only allow port 443 (HTTPS) and 563 (SNEWS) by default. In this case, the only thing to do is run **x11vnc** on that low port, e.g. "`-rfbport 443`", (or use a port redirection on, say, a firewall or router port 443 to the internal machine.)

If you do such a redirection to an internal machine _and_ **x11vnc** is not listening on port 443, you will probably need to edit `proxy.vnc`. Suppose the SSL **x11vnc** server was listening on port 5901\. You should change the line in `proxy.vnc` from:

<pre>  <param name=PORT value=$PORT>
</pre>

to:

<pre>  <param name=PORT value=443>
</pre>

Since otherwise `$PORT` will be expanded to 5901 by **x11vnc** and the viewer applet will fail to connect to that port on the firewall.

Another way to achieve the same thing is to use the applet `PORT` parameter:

<pre>  https://yourmachine.com/proxy.vnc?PORT=443
</pre>

this is cleaner because it avoids editing the file, but requires more parameters in the URL. See also the [`-httpsredir`](x11vnc_opts.html#opt-httpsredir) **x11vnc** option that will try to automate this for you. To use the GET [trick discussed above](#faq-ssl-tunnel-viewers), do:

<pre>  https://yourmachine.com/proxy.vnc?GET=1&PORT=443
</pre>

All of the **x11vnc** Java Viewer applet parameters are described in the file `classes/ssl/README`

Here is an example of Java Console and x11vnc output for the [Web proxy case](java_console_proxy.html).

Note that both the [ss_vncviewer](#ss_vncviewer) stunnel Unix wrapper script and [Enhanced TightVNC Viewer (SSVNC)](ssvnc.html) can use Web proxies as well even though they do not involve a Web browser.

<a name="faq-ssl-portal"></a><a name="FAQ-57"></a>

**Q-57:** <font color="#007f00">Can Apache web server act as a gateway for users to connect via SSL from the Internet with a Web browser to **x11vnc** running on their workstations behind a firewall?</font>

Yes. You will need to configure apache to forward these connections. It is discussed [here](ssl-portal.html). This SSL VNC portal provides a clean alternative to the traditional method where the user uses SSH to log in through the gateway to create the encrypted port redirection to **x11vnc** running on her desktop.

Also see the [desktop.cgi](#faq-web-login) CGI script method that achieves much of what this Apache VNC SSL portal method does (as long as desktop.cgi's 'port redirection' mode is enabled.)

<a name="faq-ssl-ca"></a><a name="FAQ-58"></a>

**Q-58:** <font color="#007f00">Can I create and use my own SSL Certificate Authority (CA) with **x11vnc**?</font>

Yes, see [this page](ssl.html) for how to do this and the utility commands **x11vnc** provides to create and manage many types of certificates and private keys.

<font size="-0">**[Display Managers and Services]**</font>
<a name="faq-service"></a><a name="FAQ-59"></a>

**Q-59:** <font color="#007f00">How can I run **x11vnc** as a "service" that is always available?</font>

There are a number of ways to do this. The primary thing you need to decide is whether you want **x11vnc** to connect to the X session on the machine 1) regardless of who (or if anyone) has the X session, or 2) only if a certain user has the X session. Because X sessions are protected by X permissions (MIT-MAGIC-COOKIE files `XAUTHORITY` and `$HOME/.Xauthority`) the automatically started **x11vnc** will of course need to have sufficient permissions to connect to the X display.

Here are some ideas:

*   Use the description under "Continuously" in the [FAQ on **x11vnc** and Display Managers](faq.html#infaq_display-manager-continuously)
*   Use the description in the [FAQ on **x11vnc** and `inetd(8)`](#faq-inetd)
*   Use the description in the [FAQ on Unix user logins and `inetd(8)`](#faq-userlogin)
*   Start **x11vnc** from your `$HOME/.xsession` (or `$HOME/.xinitrc` or autostart script or ...)
*   Although less reliable, see the [x11vnc_loop](faq.html#infaq_x11vnc_loop) `rc.local` hack below.

The display manager scheme will not be specific to which user has the X session unless a test is specifically put into the display startup script (often named `Xsetup`.) The `inetd(8)` scheme may or may not be specific to which user has the X session (and it may not be able to do all users via the `XAUTHORITY` permission issues.)

The `.xsession`/`.xinitrc` scheme is obviously is specific to a particular user and only when they are logged into X. If you do not know what a `$HOME/.xsession` script is or how to use one, perhaps your desktop has a "session startup commands" configuration option. The command to be run in the `.xsession` or `.xinitrc` file may look like this:

<pre>x11vnc -logfile $HOME/.x11vnc.log -rfbauth $HOME/.vnc/passwd -forever -bg
</pre>

plus any other options you desire.

Depending on your desktop and/or OS/distribution the automatically run X startup scripts (traditionally `.xsession`/`.xinitrc`) may have to be in a different directory or have a different basename. One user recommends the description under 'Running Scripts Automatically' at [this link](http://club.mandriva.com/xwiki/bin/view/KB/XwinXset).

**_Firewalls:_** note all methods will require the host-level [firewall](index.html#firewalls) to be configured to allow connections in on a port. E.g. 5900 (default VNC port) or 22 (default SSH port for tunnelling VNC.) Most systems these days have firewalls turned on by default, so you will actively have to do something to poke a hole in the firewall at the desired port number. See your system administration tool for Firewall settings (Yast, Firestarter, etc.)

<a name="faq-display-manager"></a><a name="FAQ-60"></a>

**Q-60:** <font color="#007f00">How can I use **x11vnc** to connect to an X login screen like `xdm`, GNOME `gdm`, KDE `kdm`, or CDE `dtlogin`? (i.e. nobody is logged into an X session yet.)</font>

We describe two scenarios here. The first is called '**One time only**' meaning you just need to do it quickly once and don't want to repeat; and the second is called '**Continuously**' meaning you want the access to be available after every reboot and after every desktop logout.

* * *

**One time only:**   If the X login screen is running and you just want to connect to it once (i.e. a one-shot):

It is usually possible to do this by just adjusting the `XAUTHORITY` environment variable to point to the correct MIT-COOKIE auth file while running **x11vnc** as **root**, e.g. for the gnome display manager, GDM:

<pre>  x11vnc -auth /var/gdm/:0.Xauth -display :0
</pre>

(the [`-auth`](x11vnc_opts.html#opt-auth) option sets the `XAUTHORITY` variable for you.)

There will be a similar thing to do for `xdm` using however a different auth directory path (perhaps something like `/var/lib/xdm/authdir/authfiles/A:0-XQvaJk`) for the `xdm` greeter or `/var/lib/kdm/A:0-crWk72` (or `/var/run/xauth/A:0-qQPftr`, etc. etc) for the `kdm` greeter. Of course, the random characters in the file basename will vary and you will need to use the actual filename on your system. Read your system docs to find out where the display manager cookie files are kept.

**Trick:** sometimes `ps(1)` can reveal the X server process `-auth` argument (e.g. "`ps wwaux | grep auth`") and hence the path to the auth file.

x11vnc _must_ be run as root for this because the `/var/gdm/:0.Xauth`, `/var/lib/kdm/A:0-crWk72`, etc. auth files are only readable by root. If you do not want to run x11vnc as root, you can copy (as root or sudo) the auth file to some location and make it readable by your userid. Then run x11vnc as your userid with `-auth` pointed to the copied file.

_**Update** Dec/2009:_ use "[`-auth guess`](x11vnc_opts.html#opt-auth)" to have **x11vnc** try to guess the location of the auth file for you.

You next connect to **x11vnc** with a VNC viewer, give your username and password to the X login prompt to start your session.

<a name="infaq_gdm"></a>_**Note:**_  GDM: `gdm` seems to have an annoying setting that causes **x11vnc** (and any other X clients) to be killed after the user logs in. Setting `KillInitClients=false` in the `[daemon]` section of `/etc/X11/gdm/gdm.conf` (or `/etc/gdm/gdm.conf`, etc.) avoids this. Otherwise, just restart **x11vnc** and then reconnect your viewer. Other display managers (kdm, etc) may also have a similar problem. One user reports having to alter "`gdm.conf-custom`" as well.

_**Note:**_  Solaris: For `dtlogin` in addition to the above sort of trick (BTW, the auth file should be in `/var/dt`), you'll also need to add something like `Dtlogin*grabServer:False` to the `Xconfig` file (`/etc/dt/config/Xconfig` or `/usr/dt/config/Xconfig` on Solaris, see [the example](faq.html#infaq_dtlogin_solaris) at the end of this FAQ.) Then restart `dtlogin`, e.g.: `/etc/init.d/dtlogin stop; /etc/init.d/dtlogin start` or reboot.

_**Update** Nov/2008:_ Regarding GDM KillInitClients: see the [`-reopen`](x11vnc_opts.html#opt-reopen) option for another possible workaround.

_**Update** Oct/2009:_ Regarding GDM KillInitClients: starting with x11vnc 0.9.9 it will try to apply heuristics to detect if a window manager is not running (i.e. whether the Display Manager Greeter Login panel is still up.) If it thinks the display manager login is still up it will delay creating windows or using XFIXES. The former is what GDM uses to kill the initial clients, use of the latter can cause a different problem: an Xorg server crash. So with 0.9.9 and later it should all work without needing to set `KillInitClients=false` (which is a good because recent GDM, v2.24, has removed this option) or use `-noxfixes`. To disable the heuristics and delaying set `X11VNC_AVOID_WINDOWS=never`; to set the delay time explicitly use, e.g., `X11VNC_AVOID_WINDOWS=120` (delays for 120 seconds after the VNC connection; you have that long to log in.)

* * *

<a name="infaq_display-manager-continuously"></a>

**Continuously:**   Have **x11vnc** reattach each time the X server is restarted (i.e. after each logout and reboot):

To make **x11vnc** always attached to the X server including the login screen you will need to add a command to a display manager startup script.

Please consider the security implications of this! The VNC display for the X session always accessible (but hopefully password protected.) Add [`-localhost`](x11vnc_opts.html#opt-localhost) if you only plan to access via a [SSH tunnel](index.html#tunnelling).

The name of the display manager startup script file depends on desktop used and seem to be:

<pre>     GDM (GNOME)  /etc/X11/gdm/Init/Default
                  /etc/gdm/Init/Default
     KDM (KDE)    /etc/kde*/kdm/Xsetup
     XDM          /etc/X11/xdm/Xsetup          (or sometimes xdm/Xsetup_0)
     CDE          /etc/dt/config/Xsetup
</pre>

although the exact location can be operating system, distribution, and time dependent. See the documentation for your display manager:  `gdm(1), kdm(1), xdm(1), dtlogin(1)` for additional details. There may also be display number specific scripts: e.g. `Xsetup_0` vs. `Xsetup`, you need to watch out for.

**_Note:_**  You should read and understand all of the Note's and Update's in the '**One time only**' section above. All of the GDM topics apply here as well:

**_Note:_**  GDM: The above (in 'One time only') `gdm` setting of `KillInitClients=false` in `/etc/X11/gdm/gdm.conf` (or `/etc/gdm/gdm.conf`, etc.) for GDM is needed here as well. Other display managers (KDM, etc) may also have a similar problem.

Also see the _**Update** Oct/2009_ above where x11vnc 0.9.9 and later automatically avoids being killed.

**_Note:_**  DtLogin: The above (in 'One time only') `Dtlogin*grabServer:False` step for Solaris will be needed for `dtlogin` here as well.

In any event, the line you will add to the display manager script (Xsetup, Default, or whatever) will look something like:

<pre>  /usr/local/bin/x11vnc -rfbauth /path/to/the/vnc/passwd -o /var/log/x11vnc.log -forever -bg
</pre>

where you should customize the exact command to your needs (e.g. [`-localhost`](x11vnc_opts.html#opt-localhost) for SSH tunnel-only access; [`-ssl SAVE`](x11vnc_opts.html#opt-ssl) for SSL access; etc.)

_Happy, happy, joy, joy:_  Note that we do not need to specify `-display` or `-auth` because happily they are already set for us in the `DISPLAY` and `XAUTHORITY` environment variables for the `Xsetup` script!!!

You may also want to force the VNC port with something like "`-rfbport 5900`" (or [`-N`](x11vnc_opts.html#opt-N)) to avoid autoselecting one if 5900 is already taken.

<a name="infaq_gdm_fedora"></a>

* * *

**Fedora/gdm:** Here is an example of what we did on a vanilla install of Fedora-C3 (seems to use `gdm` by default.) Add a line like this to `/etc/X11/gdm/Init/:0`

<pre>  /usr/local/bin/x11vnc -rfbauth /etc/x11vnc.passwd -forever -bg -o /var/log/x11vnc.log
</pre>

And then add this line to `/etc/X11/gdm/gdm.conf` (or `/etc/gdm/gdm.conf`, etc.) in the `[daemon]` section:

<pre>  KillInitClients=false
</pre>

Then restart: `/usr/sbin/gdm-restart` (or reboot.) The `KillInitClients=false` setting is important: without it **x11vnc** will be killed immediately after the user logs in. Here are [full details on how to configure `gdm`](http://www.jirka.org/gdm-documentation/x241.html)

* * *

<a name="infaq_dtlogin_solaris"></a>**Solaris/dtlogin:** Here is an example of what we did on a vanilla install of Solaris:
Make the directory /etc/dt/config:

<pre>  mkdir -p /etc/dt/config
</pre>

Copy over the Xconfig file for customization:

<pre>  cp /usr/dt/config/Xconfig /etc/dt/config/Xconfig
</pre>

Edit /etc/dt/config/Xconfig and uncomment the line:

<pre>  Dtlogin*grabServer:        False
</pre>

Next, copy over Xsetup for customization:

<pre>  cp /usr/dt/config/Xsetup /etc/dt/config/Xsetup
</pre>

Edit /etc/dt/config/Xsetup and at the bottom put a line like:

<pre>  /usr/local/bin/x11vnc -forever -o /var/log/x11vnc.log -bg
</pre>

(tweaked to your local setup and preferences, a password via `-rfbauth`, etc. would be a very good idea.)

Restart the X server and dtlogin:

<pre>  /etc/init.d/dtlogin stop
  /etc/init.d/dtlogin start
</pre>

(or reboot or maybe just restart the X session.)<a name="infaq_kdm_fedora"></a>

* * *

**KDM:** One user running the `kdm` display manager reports putting this line:

<pre>  x11vnc -forever -rfbauth /home/xyz/.vnc/passwd -bg -o /var/log/x11vnc.log
</pre>

in `/etc/kde/kdm/Xsetup`. After rebooting the system it all seemed to work fine.

* * *

<a name="infaq_x11vnc_loop"></a>If you do not want to deal with any display manager startup scripts, here is a kludgey script that can be run manually or out of a boot file like `rc.local`: [x11vnc_loop](x11vnc_loop) It will need some local customization before running. Because the `XAUTHORITY` auth file must be guessed by this script, use of the display manager script method described above is greatly preferred. There is also the [`-loop`](x11vnc_opts.html#opt-loop) option that does something similar.

If the machine is a traditional Xterminal you may want to read [this FAQ](#faq-xterminal-xauth).

**_Firewalls:_** note all methods will require the host-level [firewall](index.html#firewalls) to be configured to allow connections in on a port. E.g. 5900 (default VNC port) or 22 (default SSH port for tunnelling VNC.) Most systems these days have firewalls turned on by default, so you will actively have to do something to poke a hole in the firewall at the desired port number. See your system administration tool for Firewall settings (Yast, Firestarter, etc.)

<a name="faq-inetd"></a><a name="FAQ-61"></a>

**Q-61:** <font color="#007f00">Can I run **x11vnc** out of `inetd(8)`? How about `xinetd(8)`?</font>

Yes, perhaps a line something like this in `/etc/inetd.conf` will do it for you:

<pre>  5900 stream tcp nowait root /usr/sbin/tcpd /usr/local/bin/x11vnc_sh
</pre>

where the shell script `/usr/local/bin/x11vnc_sh` uses the [`-inetd`](x11vnc_opts.html#opt-inetd) option and looks something like (you'll need to customize to your settings.)

<pre>#!/bin/sh
/usr/local/bin/x11vnc -inetd -display :0 -auth /home/fred/.Xauthority \
	-rfbauth /home/fred/.vnc/passwd -o /var/log/x11vnc_sh.log
</pre>

_Important:_  Note that you must redirect the standard error output to a log file (e.g. `-o logfile`) or "`2>/dev/null`" for proper operation via `inetd` (otherwise the standard error also goes to the VNC vncviewer, and that confuses it greatly, causing it to abort.) If you do _not_ use a wrapper script as above but rather call **x11vnc** directly in `/etc/inetd.conf` and do not redirect stderr to a file, then you _must_ specify the `-q` (aka [`-quiet`](x11vnc_opts.html#opt-q,)) option: "`/usr/local/bin/x11vnc -q -inetd ...`". When you supply both `-q` and `-inet` and no "`-o logfile`" then stderr will automatically be closed (to prevent, e.g. library stderr messages leaking out to the viewer.) The recommended practice is to use "`-o logfile`" to collect the output in a file or wrapper script with "`2>logfile`" redirection because the errors and warnings printed out are very useful in troubleshooting problems.

Note also the need to set `XAUTHORITY` via [`-auth`](x11vnc_opts.html#opt-auth) to point to the MIT-COOKIE auth file to get permission to connect to the X display (setting and exporting the `XAUTHORITY` variable accomplishes the same thing.) See the `x11vnc_loop` file in the previous question for more ideas on what that auth file may be, etc. The scheme described in the [FAQ on Unix user logins and `inetd(8)`](#faq-userlogin) works around the `XAUTHORITY` issue nicely.

_Note:_  On Solaris you cannot have the bare number `5900` in `/etc/inetd.conf`, you'll need to replace it with a word like `x11vnc` an then put something like "`x11vnc 5900/tcp`" in `/etc/services`.

Since the process runs as root, it might be a bad idea to have the logfile in a world-writable area like `/tmp` if there are untrustworthy users on the machine. Perhaps `/var/log` is a better place.

Be sure to look at your `/etc/hosts.allow` and `/etc/hosts.deny` settings to limit the machines that can connect to this service (your desktop!) For the above example with `/etc/hosts.allow`:

<pre>  x11vnc_sh : 123.45.67.89
</pre>

A really safe way to do things is to limit the above `inetd` to `localhost` only (via `/etc/hosts.allow`) and use `ssh` to tunnel the incoming connection. Using `inetd` for this prevents there being a tiny window of opportunity between **x11vnc** starting up and your **vncviewer** connecting to it. Always use a VNC password to further protect against unwanted access.

For `xinetd(8)`, one user reports he created the file `/etc/xinetd.d/x11vncservice` containing the following:

<pre># default: off
# description:
service x11vncservice
{
        flags           = REUSE NAMEINARGS
        port            = 5900
        type            = UNLISTED
        socket_type     = stream
        protocol        = tcp
        wait            = no
        user            = root
        server          = /usr/sbin/tcpd
        server_args     = /usr/local/bin/x11vnc_sh
        disable         = no
}
</pre>

With the contents of `/usr/local/bin/x11vnc_sh` similar to the example given above. One user reports this works with avoiding the wrapper script:

<pre>service x11vncservice
{
        port            = 5900
        type            = UNLISTED
        socket_type     = stream
        protocol        = tcp
        wait            = no
        user            = root
        server          = /usr/local/bin/x11vnc
        server_args     = -inetd -q -display :0 -auth /var/gdm/:0.Xauth
        disable         = no
}
</pre>

(or one can replace the `-q` with say "`-o /var/log/x11vnc.log`" to capture a log)

The above works nicely for GDM because the -auth file is a fixed name. For KDM or XDM the filename varies. Here is one idea for a `x11vnc_sh` wrapper to try to guess the name:

<pre>#!/bin/sh
COLUMNS=256
export COLUMNS
authfile=`ps wwaux | grep '/X.*-auth' | grep -v grep | sed -e 's/^.*-auth *//' -e 's/ .*$//' | head -n 1`

if [ -r "$authfile" ]; then
        exec /usr/local/bin/x11vnc -inetd -o /var/log/x11vnc.log -display :0 -auth "$authfile"
fi
exit 1
</pre>

Starting with **x11vnc** 0.9.3 this can be automated by:

<pre>#!/bin/sh
exec /usr/local/bin/x11vnc -inetd -o /var/log/x11vnc.log -find -env FD_XDM=1
</pre>

<a name="faq-avahi"></a><a name="FAQ-62"></a>

**Q-62:** <font color="#007f00">Can I have **x11vnc** advertise its VNC service and port via mDNS / Zeroconf (e.g. Avahi) so VNC viewers on the local network can detect it automatically?</font>

Yes, as of Feb/2007 **x11vnc** supports mDNS / Zeroconf advertising of its service via the Avahi client library. Use the option [-avahi](x11vnc_opts.html#opt-avahi) (same as [-mdns](x11vnc_opts.html#opt-mdns) or [-zeroconf](x11vnc_opts.html#opt-zeroconf)) to enable it. Depending on your setup you may need to install [Avahi](http://www.avahi.org/) (including the development/build packages), enable the server: `avahi-daemon` and `avahi-dnsconfd`, and possibly open up UDP port 5353 on your firewall.

If the Avahi client library or build environment is not available at build-time, then at run-time **x11vnc** will try to look for external helper programs, `avahi-browse(1)` or `dns-sd(1)`, to do the work.

The service was tested with Chicken of the VNC ("Use Bonjour" selected) on a Mac on the same network and the service was noted and listed in the servers list. Clicking on it and then "Connect" connected automatically w/o having to enter any hostnames or port numbers.

It appears SuSE 10.1 comes with avahi (or you can add packages, e.g. `avahi-0.6.5-27`) but not the development package (you can use the OpenSuSE `avahi-devel` rpm.) Unfortunately, you may need to disable another Zeroconf daemon "`/etc/init.d/mdnsd stop`", before doing "`/etc/init.d/avahi-daemon start`" and "`/etc/init.d/avahi-dnsconfd start`". We also had to comment out the `browse-domains` line in `/etc/avahi/avahi-daemon.conf`. Hopefully there is "LessConf" to do on other distros/OS's...

<a name="faq-userlogin"></a><a name="FAQ-63"></a>

**Q-63:** <font color="#007f00">Can I have **x11vnc** allow a user to log in with her UNIX username and password and then have it find her X session display on that machine and then attach to it? How about starting an X session if one cannot be found?</font>

The easiest way to do this is via [inetd(8)](#faq-inetd) using the [-unixpw](x11vnc_opts.html#opt-unixpw) and [-display WAIT](x11vnc_opts.html#opt-display_WAIT) options. The reason inetd(8) makes this easier is that it starts a new **x11vnc** process for each new user connection. Otherwise a wrapper would have to listen for connections and spawn new **x11vnc**'s (see [this example](faq.html#infaq_stunnel-inetd) and also the [-loopbg](x11vnc_opts.html#opt-loop) option.) inetd(8) is not required for this, but it makes some aspects more general.

Also with inetd(8) users always connect to a fixed VNC display, say `hostname:0`, and do not need to memorize a special VNC display number just for their personal use, etc.

_**Update:**_ Use the [-find](x11vnc_opts.html#opt-find), [-create](x11vnc_opts.html#opt-create), [-svc](x11vnc_opts.html#opt-svc), and [-xdmsvc](x11vnc_opts.html#opt-xdmsvc) options that are shorthand for common FINDCREATEDISPLAY usage modes (e.g. terminal services) described below. (i.e. simply use "`-svc`" instead of the cumbersome "`-display WAIT:cmd=FINDCREATEDISPLAY-Xvfb -unixpw -users unixpw= -ssl SAVE`")

The [-display WAIT](x11vnc_opts.html#opt-display_WAIT) option makes **x11vnc** wait until a VNC viewer is connected before attaching to the X display.

Additionally it can be used to run an external command that returns the `DISPLAY` and `XAUTHORITY` data. We provide some useful builtin ones (FINDDISPLAY and FINDCREATEDISPLAY below), but in principle one could supply his own script: "`-display WAIT:cmd=/path/to/find_display`" where the script `find_display` might look something like [this.](find_display.html)

A default script somewhat like the above is used under "`-display WAIT:cmd=FINDDISPLAY`" (same as [`-find`](x11vnc_opts.html#opt-find)) The format for any such command is that it returns `DISPLAY=:disp` as the first line and any remaining lines are either `XAUTHORITY=file` or raw xauth data (the above example does the latter.) If applicable (`-unixpw` mode), the program is run as the Unix user name who logged in.

On Linux if the virtual terminal is known the program appends ",VT=n" to the DISPLAY line; a `chvt n` will be attempted automatically. Or if only the X server process ID is known it appends ",XPID=n" (a `chvt` will be attempted by x11vnc.)

_**Tip:**_ Note that the [`-find`](x11vnc_opts.html#opt-find) option is an alias for "`-display WAIT:cmd=FINDDISPLAY`". Use it!

The [-unixpw](x11vnc_opts.html#opt-unixpw) option allows [UNIX password logins](#faq-unix-passwords). It conveniently _knows_ the Unix username whose X display should be found. Here are a couple `/etc/inetd.conf` examples of this usage:

<pre>5900  stream  tcp  nowait  nobody  /usr/sbin/tcpd /usr/local/bin/x11vnc -inetd -unixpw \
      -find -o /var/log/x11vnc.log -ssl SAVE -ssldir /usr/local/certs
</pre>

<pre>5900  stream  tcp  nowait  root    /usr/sbin/tcpd /usr/local/bin/x11vnc -inetd -unixpw \
      -find -o /var/log/x11vnc.log -ssl SAVE -users unixpw=
</pre>

Note we have used the [`-find`](x11vnc_opts.html#opt-find) alias and the very long lines have been split. An alternative is to use a wrapper script, e.g. `/usr/local/bin/x11vnc.sh` that has all of the options. (see also the [`-svc`](x11vnc_opts.html#opt-svc) alias.)

In the first inetd line **x11vnc** is run as user "nobody" and stays user nobody during the whole session. The permissions of the log files and certs directory will need to be set up to allow "nobody" to use them.

In the second one **x11vnc** is run as root and switches to the user that logs in due to the "[-users unixpw=](x11vnc_opts.html#opt-users)" option.

Note that [SSL](#faq-ssl-tunnel-int) is required for this mode because otherwise the Unix password would be passed in clear text over the network. In general `-unixpw` is not required for this sort of scheme, but it is convenient because it determines exactly who the Unix user is whose display should be sought. Otherwise the `find_display` script would have to use some method to work out DISPLAY, XAUTHORITY, etc (perhaps you use multiple inetd ports and hardwire usernames for different ports.)

If you really want to disable the SSL or SSH [-localhost](x11vnc_opts.html#opt-localhost) constraints (this is not recommended unless you really know what you are doing: Unix passwords sent in clear text is a very bad idea...) read the [-unixpw](x11vnc_opts.html#opt-unixpw) documentation.

A inetd(8) scheme for a fixed user that doesn't use SSL or unix passwds could be:

<pre>  /usr/local/bin/x11vnc -inetd -users =fred -find -rfbauth /home/fred/.vnc/passwd -o /var/log/x11vnc.log
</pre>

The "[-users =fred](x11vnc_opts.html#opt-users)" option will cause **x11vnc** to switch to user fred and then find his X display. The VNC password (`-rfbauth`) as opposed to Unix password (`-unixpw`) is used to authenticate the VNC client.

Similar looking commands to the above examples can be run directly and do not use inetd (just remove the `-inetd` option and run from the cmdline, etc.)

<a name="infaq_findcreatedisplay"></a> 
_**X Session Creation:**_ An added (Nov/2006) extension to FINDDISPLAY is FINDCREATEDISPLAY where if it **does not find** an X display via the FINDDISPLAY method it will **_create_** an X server session for the user (i.e. desktop/terminal server.) This is the only time **x11vnc** actually tries to start up an X server (normally it just attaches to an existing one.)

For virtual sessions you will need to install the **Xvfb** program (e.g. `apt-get install xvfb`) or our **Xdummy** program (see below.)

By default it will only try to start up virtual (non-hardware) X servers: first [`Xvfb`](#faq-xvfb) and if that is not available then `Xdummy` (included in the x11vnc source code.) Note that `Xdummy` only works on Linux whereas `Xvfb` works just about everywhere (and in some situations Xdummy must be run as root, but its default is to not run as root.) An advantage of Xdummy over Xvfb is that Xdummy supports RANDR dynamic screen resizing, which can be handy if the user accesses the desktop from different sized screens (e.g. workstation and laptop.)

So an `inetd(8)` example might look like:

<pre>5900 stream tcp nowait root /usr/sbin/tcpd /usr/local/bin/x11vnc -inetd \
      -o /var/log/x11vnc.log -http -prog /usr/local/bin/x11vnc \
      -ssl SAVE -unixpw -users unixpw= -display WAIT:cmd=FINDCREATEDISPLAY
</pre>

Where the very long lines have been split. See below where that long and cumbersome last line is replaced by the [`-svc`](x11vnc_opts.html#opt-svc) alias.

The above mode will allow direct SSL (e.g. [ss_vncviewer](#ss_vncviewer) or [SSVNC](ssvnc.html)) access and also Java Web browers access via: `https://hostname:5900/`.

_**Tip:**_ Note that the [`-create`](x11vnc_opts.html#opt-create) option is an alias for "`-display WAIT:cmd=FINDCREATEDISPLAY-Xvfb`".

_**Tip:**_ Note that [`-svc`](x11vnc_opts.html#opt-svc) is a short hand for the long "`-ssl SAVE -unixpw -users unixpw= -display WAIT:cmd=FINDCREATEDISPLAY`" part. Unlike `-create`, this alias also sets up SSL encryption and Unix password login.

The above inetd example then simplifies to:

<pre>5900 stream tcp nowait root /usr/sbin/tcpd /usr/local/bin/x11vnc -inetd \
      -o /var/log/x11vnc.log -http -prog /usr/local/bin/x11vnc \
      -svc
</pre>

_**Tip:**_ In addition to the usual unixpw parameters, inside the VNC viewer the user can specify after his username (following a ":" see [`-display WAIT`](x11vnc_opts.html#opt-display_WAIT) for details) for FINDCREATEDISPLAY they can add "`geom=WxH`" or "`geom=WxHxD`" to specify the width, height, and optionally the color depth. E.g. "`fred:geom=800x600`" at the login: prompt. Also if the env. var X11VNC_CREATE_GEOM is set to the desired WxH or WxHxD that will be used by **x11vnc**.

You can set the env. var X11VNC_SKIP_DISPLAY to a comma separated list of displays to ignore in the FINDDISPLAY process (to force creation of new displays in some cases.) The user logging in via the vncviewer can also set this via `username:nodisplay=...`)

If you do not plan on using the Java Web browser applet you can remove the `-http` (and `-prog`) option since this will speed up logging-in by a few seconds (**x11vnc** will not have to wait to see if a connection is HTTPS or VNC.)

For reference, `xinetd` format in the file, say, `/etc/xinetd.d/x11vnc`:

<pre>service x11vnc
{
        type            = UNLISTED
        port            = 5900
        socket_type     = stream
        protocol        = tcp
        wait            = no
        user            = root
        server          = /usr/local/bin/x11vnc
        server_args     = -inetd -o /var/log/x11vnc.log -http -prog /usr/local/bin/x11vnc -svc
        disable         = no
}
</pre>

To print out the script in this case use "`-display WAIT:cmd=FINDCREATEDISPLAY-print`". To change the preference of Xservers and which to try list them, e.g.: "`-display WAIT:cmd=FINDCREATEDISPLAY-X,Xvfb,Xdummy`" or use "[`-create_xsrv X,Xvfb,Xdummy`](x11vnc_opts.html#opt-create_xsrv)". The "`X`" one means to try to start up a real, hardware X server, e.g. `startx(1)` (if there is already a real X server running this may only work on Linux and the `chvt` program may [need to be run](#faq-linuxvc) to switch to the correct Linux virtual terminal.) **x11vnc** will try to run `chvt` automatically if it can determine which VT should be switched to.

<a name="xdm_greeter_config"></a>_**XDM/GDM/KDM Login Greeter Panel:**_ If you want to present the user with a xdm/gdm/kdm display manager "greeter" login you can use `Xvfb.xdmcp` instead of `Xvfb`, etc in the above list. However, you need to configure xdm/gdm/kdm to accept localhost XDMCP messages, this can be done by (from -help output):

<pre>      If you want the FINDCREATEDISPLAY session to contact an XDMCP login
      manager (xdm/gdm/kdm) on the same machine, then use "Xvfb.xdmcp"
      instead of "Xvfb", etc.  The user will have to supply his username
      and password one more time (but he gets to select his desktop
      type so that can be useful.)  For this to work, you will need to
      enable localhost XDMCP (udp port 177) for the display manager.
      This seems to be:

       for gdm in gdm.conf:   Enable=true in section [xdmcp]
       for kdm in kdmrc:      Enable=true in section [Xdmcp]
       for xdm in xdm-config: DisplayManager.requestPort: 177
</pre>

Unless you are also providing XDMCP service to xterminals or other machines, make sure that the host access list only allows local connections (the name of this file is often `Xaccess` and it is usually setup by default to do just that.) Nowadays, host level firewalling will also typically block UDP (port 177 for XDMCP) by default effectively limiting the UDP connections to localhost.

_**Tip:**_ Note that [`-xdmsvc`](x11vnc_opts.html#opt-xdmsvc) is a short hand alias for the long "`-ssl SAVE -unixpw -users unixpw= -display WAIT:cmd=FINDCREATEDISPLAY-Xvfb.xdmcp`". So we simply use:

<pre>service x11vnc
{
        type            = UNLISTED
        port            = 5900
        socket_type     = stream
        protocol        = tcp
        wait            = no
        user            = root
        server          = /usr/local/bin/x11vnc
        server_args     = -inetd -o /var/log/x11vnc.log -xdmsvc
        disable         = no
}
</pre>

(Note: use "`-svc`" instead of "`-xdmsvc`" for no XDMCP login greeter.)_**Local access (VNC Server and VNC Viewer on the same machine):**_ To access your virtual X display session locally (i.e. while sitting at the same machine it is running on) one can perhaps have something like this in their `$HOME/.xinitrc`

<pre>#!/bin/sh
x11vnc -create -rfbport 5905 -env WAITBG=1
vncviewer -geometry +0+0 -encodings raw -passwd $HOME/.vnc/passwd localhost:5
</pre>

You may not need the `-passwd`. Recent RealVNC viewers might be this:

<pre>#!/bin/sh
x11vnc -create -rfbport 5905 -env WAITBG=1
vncviewer -FullScreen -PreferredEncoding raw -passwd $HOME/.vnc/passwd localhost:5
</pre>

This way a bare X server is run with no window manager or desktop; it simply runs only the VNC Viewer on the real X server. The Viewer then draws the virtual X session on to the real one. On your system it might not be `$HOME/.xinitrc`, but rather `.xsession`, `.Xclients`, or something else. You will need to figure out what it is for your system and configuration.

There may be a problem if the resolution (WxH) of the virtual X display does not match that of the physical X display.

If you do not want to or cannot figure out the X startup script name (`.xinitrc`, etc) you could save the above commands to a shell script, say "`vnclocal`", and the log in via the normal KDM or GDM greeter program using the "Failsafe" option. Then in the lone xterm that comes up type "`vnclocal`" to connect to your virtual X display via **x11vnc** and `vncviewer`.

* * *

**_Summary_**: The "`-display WAIT:cmd=FINDCREATEDISPLAY`" scheme can be used to provide a "desktop service" (i.e. terminal service) on the server machine: you always get some desktop there, either a real hardware X server or a virtual one (depending on how you set things up.)

So it provides simple "terminal services" based on Unix username and password. The created X server sessions (virtual or real hardware) will remain running after you disconnect the VNC viewer and will be found again on reconnecting via VNC and logging in. To terminate them use the normal way to Exit/LogOut from inside your X session. The user does not have to memorize which VNC display number is his. They all go the same one (e.g. `hostname:0`) and it switches based on username.

<a name="faq-loop"></a><a name="FAQ-64"></a>

**Q-64:** <font color="#007f00">Can I have **x11vnc** restart itself after it terminates?</font>

One could do this in a shell script, but now there is an option [-loop](x11vnc_opts.html#opt-loop) that makes it easier. Of course when **x11vnc** restarts it needs to have permissions to connect to the (potentially new) X display. This mode could be useful if the X server restarts often. Use e.g. "`-loop5000`" to sleep 5000 ms between restarts. Also "`-loop2000,5`" to sleep 2000 ms and only restart 5 times.

One can also use the [-loopbg](x11vnc_opts.html#opt-loop) to emulate inetd(8) to some degree, where each connected process runs in the background. It could be combined, say, with the [-svc](x11vnc_opts.html#opt-svc) option to provide simple terminal services without using inetd(8).

<a name="faq-java-http"></a><a name="FAQ-65"></a>

**Q-65:** <font color="#007f00">How do I make **x11vnc** work with the Java VNC viewer applet in a web browser?</font>

To have **x11vnc** serve up a Java VNC viewer applet to any web browsers that connect to it, run **x11vnc** with this [option](x11vnc_opts.html#opt-httpdir):

<pre>  -httpdir /path/to/the/java/classes/dir
</pre>

(this directory will contain the files `index.vnc` and, for example, `VncViewer.jar`) Note that **libvncserver** contains the TightVNC Java classes jar file for your convenience. (it is the file `classes/VncViewer.jar` in the source tree.)

You will see output something like this:

<pre>  14/05/2004 11:13:56 Autoprobing selected port 5900
  14/05/2004 11:13:56 Listening for HTTP connections on TCP port 5800
  14/05/2004 11:13:56   URL http://walnut:5800
  14/05/2004 11:13:56 screen setup finished.
  14/05/2004 11:13:56 The VNC desktop is walnut:0
  PORT=5900
</pre>

then you can connect to that URL with any Java enabled browser. Feel free to customize the default `index.vnc` file in the classes directory.

As of May/2005 the [-http](x11vnc_opts.html#opt-http) option will try to guess where the Java classes jar file is by looking in expected locations and ones relative to the **x11vnc** binary.

Also note that if you wanted to, you could also start the Java viewer entirely from the viewer-side by having the jar file there and using either the `java` or `appletviewer` commands to run the program.

<pre>  java -cp ./VncViewer.jar VncViewer HOST far-away.east PORT 5900
</pre>

**Proxies:** See the [discussion here](#faq-ssl-java-viewer-proxy) if the web browser must use a web proxy to connect to the internet. It is tricky to get Java applets to work in this case: a signed applet must be used so it can connect to the proxy and ask for the redirection to the VNC server. One way to do this is to use the signed SSL one referred to in `classes/ssl/proxy.vnc` and set `disableSSL=yes` (note that this has no encryption; please use SSL or SSH as discuss elsewhere on this page) in the URL or the file.

<a name="faq-reverse-connect"></a><a name="FAQ-66"></a>

**Q-66:** <font color="#007f00">Are reverse connections (i.e. the VNC server connecting to the VNC viewer) using "`vncviewer -listen`" and `vncconnect(1)` supported?</font>

As of Mar/2004 **x11vnc** supports reverse connections. On Unix one starts the VNC viewer in listen mode: "`vncviewer -listen`" (see your documentation for Windows, etc), and then starts up **x11vnc** with the [`-connect`](x11vnc_opts.html#opt-connect) option. To connect immediately at **x11vnc** startup time use the "`-connect host:port`" option (use commas for a list of hosts to connect to.) The ":port" is optional (default is VNC listening port is 5500.)

If a file is specified instead: `-connect /path/to/some/file` then that file is checked periodically (about once a second) for new hosts to connect to.

The [`-remote`](x11vnc_opts.html#opt-remote) control option (aka `-R`) can also be used to do this during an active **x11vnc** session, e.g.:

<pre>x11vnc -display :0 -R connect:hostname.domain
</pre>

Use the "[`-connect_or_exit`](x11vnc_opts.html#opt-connect_or_exit)" option to have **x11vnc** exit if the reverse connection fails. Also, note the "`-rfbport 0`" option disables TCP listening for connections (potentially useful for reverse connection mode, assuming you do not want any "forward" connections.)

Note that as of Mar/2006 **x11vnc** requires password authentication for reverse connections as well as for forward ones (assuming password auth has been enabled, e.g. via `-rfbauth`, `-passwdfile`, etc.) Many VNC servers do not require any password for reverse connections. To regain the old behavior supply this option "`-env X11VNC_REVERSE_CONNECTION_NO_AUTH=1`" to **x11vnc**.

**_Vncconnect command:_** To use the `vncconnect(1)` program (from the core VNC package at www.realvnc.com) specify the [`-vncconnect`](x11vnc_opts.html#opt-vncconnect) option to **x11vnc** (Note: as of Dec/2004 `-vncconnect` is now the default.) `vncconnect(1)` must be pointed to the same X11 DISPLAY as **x11vnc** (since it uses X properties to communicate with **x11vnc**.) If you do not have or do not want to get the `vncconnect(1)` program, the following script (named "Vncconnect") may work if your `xprop(1)` supports the `-set` option:

<pre>#!/bin/sh
# usage: Vncconnect <host>
#        Vncconnect <host:port>
# note: not all xprop(1) support -set.
#
xprop -root -f VNC_CONNECT 8s -set VNC_CONNECT "$1"
</pre>

<a name="faq-reverse-connect-proxy"></a><a name="FAQ-67"></a>

**Q-67:** <font color="#007f00">Can reverse connections be made to go through a Web or SOCKS proxy or SSH?</font>

Yes, as of Oct/2007 **x11vnc** supports reverse connections through proxies: use the "[`-proxy host:port`](x11vnc_opts.html#opt-proxy)" option. The default is to assume the proxy is a Web proxy. Note that most Web proxies only allow proxy destination connections to ports 443 (HTTPS) and 563 (SNEWS) and so this might not be too useful unless the proxy has been modified (AllowCONNECT apache setting) or the VNC viewer listens on one of those ports (or the router does a port redir.) A web proxy may also be specified via "`-proxy http://host:port`"

For SOCKS4 and SOCKS4a proxies use this format "`-proxy socks://host:port`". If the reverse connection hostname is a numerical IP or "localhost" then SOCKS4 (no host lookup) is used, otherwise SOCKS4a will be used. For SOCKS5 (proxy will do lookup and many other things) use "`-proxy socks5://host:port`". Note that the SSH builtin SOCKS proxy "`ssh -D port`" only does SOCKS4 or SOCKS5, so use `socks5://` for a ssh -D proxy.

The proxying works for both SSL encrypted and normal reverse connections.

An experimental mode is "`-proxy http://host:port/...`" where the URL (e.g. a CGI script) is retrieved via the GET method. See [`-proxy`](x11vnc_opts.html#opt-proxy) for more info.

Another experimental mode is "`-proxy ssh://user@host`" in which case a SSH tunnel is used for the proxying. See [`-proxy`](x11vnc_opts.html#opt-proxy) for more info.

Up to 3 proxies may be chained together by listing them by commas e.g.: "`-proxy http://host1:port1,socks5://host2:port2`" in case one needs to ricochet off of several machines to ultimately reach the listening viewer.

<a name="faq-web-login"></a><a name="FAQ-68"></a>

**Q-68:** <font color="#007f00">Can **x11vnc** provide a multi-user desktop web login service as an Apache CGI or PHP script?</font>

Yes. See the example script [desktop.cgi](desktop.cgi.pl) for ideas. It is in the source tree in the directory `x11vnc/misc`. It serves **x11vnc**'s SSL enabled Java Applet to the web browser with the correct connection information for the user's virtual desktop (an [Xvfb session](#faq-xvfb) via [`-create`](x11vnc_opts.html#opt-create); be sure to add the Xvfb package.) HTTPS/SSL enabled Apache should be used to serve the script to avoid unix and vnc passwords from being sent in cleartext and sniffed.

By default it uses a separate VNC port for each user desktop (either by autoprobing in a range of ports or using a port based on the userid number.) The web server's firewall must allow incoming connections to these ports.

It is somewhat difficult to do all of this with x11vnc listening on a **single** port, however there is also a 'fixed port' scheme described in the script based on [-loopbg](x11vnc_opts.html#opt-loop) that works fairly well (but more experience is needed to see what problems contention for the same port causes; however at worst one user may need to re-login.)

There is also an optional 'port redirection' mode for desktop.cgi that allows redirection to other machines inside the firewall already running SSL enabled VNC servers. This provides much of the functionality as the [SSL Portal](#faq-ssl-portal) and is easier to set up.

<a name="faq-xvfb"></a><a name="FAQ-69"></a>

**Q-69:** <font color="#007f00">Can I use **x11vnc** as a replacement for `Xvnc`? (i.e. not for a real display, but for a virtual one I keep around.)</font>

You can, but you would not be doing this for performance reasons (for virtual X sessions via VNC, `Xvnc` should give the fastest response.) You may want to do this because `Xvnc` is buggy and crashes, does not support an X server extension you desire, or you want to take advantage of one of **x11vnc**'s unending number of options and features.

One way to achieve this is to have a `**Xvfb**(1)` virtual framebuffer X server running in the background and have **x11vnc** attached to it. Another method, faster and more accurate, is to use the "dummy" Device Driver in XFree86/Xorg (see below.)

For these virtual sessions you will need to install the **Xvfb** program (e.g. `apt-get install xvfb`) or our **Xdummy** program (see below.)

In either case, one can view this desktop both remotely and also [_locally_](faq.html#infaq_localaccess) using vncviewer. Make sure vncviewer's "`-encodings raw`" is in effect for local viewing (compression seems to slow things down locally.) For local viewing you set up a "bare" window manager that just starts up `vncviewer` and nothing else ([See how below](faq.html#infaq_localaccess).)

Here is one way to start up **Xvfb**:

<pre>  xinit -- /usr/bin/Xvfb :1 -cc 4 -screen 0 1024x768x16
</pre>

This starts up a 16bpp virtual display. To export it via VNC use

<pre>  x11vnc -display :1 ...
</pre>

Then have the remote `vncviewer` attach to **x11vnc**'s VNC display (e.g. :0 which is port 5900.)

The "`-cc 4`" **Xvfb** option is to force it to use a TrueColor visual instead of DirectColor (this works around a recent bug in the Xorg **Xvfb** server.)

One good thing about **Xvfb** is that the virtual framebuffer exists in main memory (rather than in the video hardware), and so **x11vnc** can "screen scrape" it very efficiently (more than, say, 100X faster than normal video hardware.)

_**Update** Nov/2006:_ See the [`FINDCREATEDISPLAY`](faq.html#infaq_findcreatedisplay) discussion of the "[`-display WAIT:cmd=FINDDISPLAY`](x11vnc_opts.html#opt-display_WAIT)" option where virtual (Xvfb or Xdummy, or even real ones by changing an option) X servers are started **automatically** for new users connecting. This provides a "desktop service" for the machine. You either get your real X session or your virtual (Xvfb/Xdummy) one whenever you connect to the machine (`inetd(8)` is a nice way to provide this service.) The [-find](x11vnc_opts.html#opt-find), [-create](x11vnc_opts.html#opt-create), [-svc](x11vnc_opts.html#opt-svc), and [-xdmsvc](x11vnc_opts.html#opt-xdmsvc) aliases can also come in handy here.

There are some annoyances WRT **Xvfb** however. The default keyboard mapping seems to be very poor. One should run **x11vnc** with [`-add_keysyms`](x11vnc_opts.html#opt-add_keysyms) option to have keysyms added automatically. Also, to add the `Shift_R` and `Control_R` modifiers something like this is needed:

<pre>#!/bin/sh
xmodmap -e "keycode any = Shift_R"
xmodmap -e "add Shift = Shift_L Shift_R"
xmodmap -e "keycode any = Control_R"
xmodmap -e "add Control = Control_L Control_R"
xmodmap -e "keycode any = Alt_L"
xmodmap -e "keycode any = Alt_R"
xmodmap -e "keycode any = Meta_L"
xmodmap -e "add Mod1 = Alt_L Alt_R Meta_L"
</pre>

(note: these are applied automatically in the [`FINDCREATEDISPLAY`](faq.html#infaq_findcreatedisplay) mode of **x11vnc**.) Perhaps the **Xvfb** options `-xkbdb` or `-xkbmap` could be used to get a better default keyboard mapping...

**_Dummy Driver:_**  A user points out a faster and more accurate method is to use the "dummy" Device Driver of XFree86/Xorg instead of **Xvfb**. He uses this to create a persistent and resizable desktop accessible from anywhere. In the `Device` Section of the config file set `Driver "dummy"`. You may also need to set `VideoRam NNN` to be large enough to hold the framebuffer. The framebuffer is kept in main memory like **Xvfb** except that the server code is closely correlated with the real XFree86/Xorg Xserver unlike **Xvfb**.

The main drawback to this method (besides requiring extra configuration and possibly root permission) is that it also does the Linux Virtual Console/Terminal (VC/VT) [switching](#faq-linuxvc) even though it does not need to (since it doesn't use a real framebuffer.) There are some "dual headed" (actually multi-headed/multi-user) patches to the X server that turn off the VT usage in the X server. _**Update**:_ As of Jul/2005 we have an `LD_PRELOAD` script [`Xdummy`](Xdummy) that allows you to use a stock (i.e. unpatched) Xorg or XFree86 server with the "dummy" driver and not have any VT switching problems! An advantage of Xdummy over Xvfb is that Xdummy supports RANDR dynamic screen resizing.

The standard way to start the "dummy" driver would be:

<pre>startx -- :1 -config /etc/X11/xorg.conf.dummy
</pre>

where the file `/etc/X11/xorg.conf.dummy` has its `Device` Section modified as described above. To use the `LD_PRELOAD` wrapper script:

<pre>startx -- /path/to/Xdummy :1
</pre>

An `xdm(1)` example is also provided.

In general, one can use these sorts of schemes to use **x11vnc** to export other virtual X sessions, say `Xnest` or even `Xvnc` itself (useful for testing `x11vnc`.)

<a name="infaq_localaccess">_**Local access (VNC Server and VNC Viewer on the same machine):**_ You use a VNC viewer to access the display remotely; to access your virtual X display **locally** (i.e. while sitting at the same machine it is running on) one can perhaps have something like this in their `$HOME/.xinitrc`</a>

<pre><a name="infaq_localaccess">#!/bin/sh
x11vnc -display :5 -rfbport 5905 -bg
vncviewer -geometry +0+0 -encodings raw -passwd $HOME/.vnc/passwd localhost:5</a> </pre>

<a name="infaq_localaccess">The display numbers (VNC and X) will likely be different (you could also try</a> [-find](x11vnc_opts.html#opt-find)), and you may not need the `-passwd`. Recent RealVNC viewers might be this:

<pre>#!/bin/sh
x11vnc -display :5 -rfbport 5905 -bg
vncviewer -FullScreen -PreferredEncoding raw -passwd $HOME/.vnc/passwd localhost:5
</pre>

This way a bare X server is run with no window manager or desktop; it simply runs only the VNC Viewer on the real X server. The Viewer then draws the virtual X session on to the real one. On your system it might not be `$HOME/.xinitrc`, but rather `.xsession`, `.Xclients`, or something else. You will need to figure out what it is for your system and configuration._**XDM/GDM/KDM One-Shot X sessions:**_ For the general replacement of Xvnc by Xvfb+x11vnc, one user describes a similar setup he created where the X sessions are one-shot's (destroyed after the vncviewer disconnects) and it uses the XDM/GDM/KDM login greeter [here](xdm_one_shot.html).<a name="faq-headless"></a><a name="FAQ-70"></a>

**Q-70:** <font color="#007f00">How can I use **x11vnc** on "headless" machines? Why might I want to?</font>

An interesting application of **x11vnc** is to let it export displays of "headless" machines. For example, you may have some lab or server machines with no keyboard, mouse, or monitor, but each one still has a video card. One can use **x11vnc** to provide a simple "desktop service" from these server machines.

An X server can be started on the headless machine (sometimes this requires configuring the X server to not fail if it cannot detect a keyboard or mouse, see the next paragraph.) Then you can export that X display via **x11vnc** (e.g. see [this FAQ](faq.html#infaq_display-manager-continuously)) and access it from anywhere on the network via a VNC viewer.

Some tips on getting X servers to start on machines without keyboard or mouse: For XFree86/Xorg the `Option "AllowMouseOpenFail" "true"` "ServerFlags" config file option is useful. On Solaris `Xsun` the `+nkeyboard` and `+nmouse` options are useful (put them in the server command line args in `/etc/dt/config/Xservers`.) There are patches available for `Xsun` at least back to Solaris 8 that support this. See `Xserver(1)` for more info.

A tip on getting X servers to use higher resolutions on machines without monitor: The monitor can tell the video card which resolutions and sync frequency ranges are allowed. With no monitor attached this information is unavailable and the X server will default to a very low, safe resolution (e.g. 800x600) that nearly all monitors should handle. It is possible to work around this in the X server config file, e.g. to force the specification of which modes are supported. Here is an a example for the `xorg.conf` file for Xorg:

<pre>Section "Device"
Identifier "VNC Device"
Driver "vesa"
EndSection

Section "Screen"
Identifier "VNC Screen"
Device "VNC Device"
Monitor "VNC Monitor"
SubSection "Display"
Modes "1024x768"
EndSubSection
EndSection

Section "Monitor"
Identifier "VNC Monitor"
HorizSync 30-70
VertRefresh 50-75
EndSection
</pre>

More info [here](http://ubuntuforums.org/showthread.php?t=1297815). (the above might not work on more recent Xorg versions.) Other xorg.conf file options are possible to solve this problem. It should be possible to use a driver for the card instead of the vesa driver and this will enable larger resolutions and could be faster too.

Although this usage may sound strange it can be quite useful for a GUI (or other) testing or QA setups: the engineers do not need to walk to lab machines running different hardware, OS's, versions, etc (or have many different machines in their office.) They just connect to the various test machines over the network via VNC. The advantage to testing this way instead of using `Xvnc` or even `Xvfb` is that the test is done using the _real_ X server, fonts, video hardware, etc. that will be used in the field.

One can imagine a single server machine crammed with as many video cards as it can hold to provide multiple simultaneous access or testing on different kinds of video hardware.

See also the [`FINDCREATEDISPLAY`](faq.html#infaq_findcreatedisplay) discussion of the "[`-display WAIT:cmd=FINDDISPLAY`](x11vnc_opts.html#opt-display_WAIT)" option where virtual Xvfb or Xdummy, or real X servers are started automatically for new users connecting. The [-find](x11vnc_opts.html#opt-find), [-create](x11vnc_opts.html#opt-create), [-svc](x11vnc_opts.html#opt-svc), and [-xdmsvc](x11vnc_opts.html#opt-xdmsvc) aliases can also come in handy here.

<font size="-0">**[Resource Usage and Performance]**</font>
<a name="faq-solshm"></a><a name="FAQ-71"></a>

**Q-71:** <font color="#007f00">I have lots of memory, but why does **x11vnc** fail with    `shmget: No space left on device`    or    `Minor opcode of failed request: 1 (X_ShmAttach)`?</font>

It is not a matter of free memory, but rather free shared memory (shm) slots, also known as shm segments. This often occurs on a public Solaris machine using the default of only 100 slots. You (or the owner or root) can clean them out with `ipcrm(1)`. **x11vnc** tries hard to release its slots, but it, and other programs, are not always able to (e.g. if `kill -9`'d.)

Sometimes **x11vnc** will notice the problem with shm segments and tries to get by with fewer, only giving a warning like this:

<pre>  19/03/2004 10:10:58 shmat(tile_row) failed.
  shmat: Too many open files
  19/03/2004 10:10:58 error creating tile-row shm for len=4
  19/03/2004 10:10:58 reverting to single_copytile mode
</pre>

Here is a shell script [`shm_clear`](shm_clear) to list and prompt for removal of your unattached shm segments (attached ones are skipped.) I use it while debugging **x11vnc** (I use "`shm_clear -y`" to assume "yes" for each prompt.) If **x11vnc** is regularly not cleaning up its shm segments, please contact me so we can work to improve the situation.

Longer term, on Solaris you can put something like this in `/etc/system`:

<pre>  set shmsys:shminfo_shmmax = 0x2000000
  set shmsys:shminfo_shmmni = 0x1000
</pre>

to sweep the problem under the rug (4096 slots.) On Linux, examine `/proc/sys/kernel/shmmni`; you can modify the value by writing to that file.

Things are even more tight on Solaris 8 and earlier, there is a default maximum number of shm segments _per process_ of 6. The error is the X server (not **x11vnc**) being unable to attach to the segments, and looks something like this:

<pre>  30/04/2004 14:04:26 Got connection from client 192.168.1.23
  30/04/2004 14:04:26   other clients:
  X Error of failed request:  BadAccess (attempt to access private resource denied)
     Major opcode of failed request:  131 (MIT-SHM)
     Minor opcode of failed request:  1 (X_ShmAttach)
     Serial number of failed request:  14
     Current serial number in output stream:  17
</pre>

This tight limit on Solaris 8 can be increased via:

<pre>  set shmsys:shminfo_shmseg = 100
</pre>

in `/etc/system`. See the next paragraph for more workarounds.

To minimize the number of shm segments used by **x11vnc** try using the [`-onetile`](x11vnc_opts.html#opt-onetile) option (corresponds to only 3 shm segments used, and adding `-fs 1.0` knocks it down to 2.) If you are having much trouble with shm segments, consider disabling shm completely via the [`-noshm`](x11vnc_opts.html#opt-noshm) option. Performance will be somewhat degraded but when done over local machine sockets it should be acceptable (see an [earlier question](#faq-noshm) discussing `-noshm`.)

<a name="faq-less-resource"></a><a name="FAQ-72"></a>

**Q-72:** <font color="#007f00">How can I make **x11vnc** use less system resources?</font>

The [`-nap`](x11vnc_opts.html#opt-nap) (now on by default; use `-nonap` to disable) and "[`-wait n`](x11vnc_opts.html#opt-wait)" (where `n` is the sleep between polls in milliseconds, the default is 30 or so) option are good places to start. In addition, something like "[`-sb 15`](x11vnc_opts.html#opt-sb)" will cause **x11vnc** to go into a deep-sleep mode after 15 seconds of no activity (instead of the default 60.)

Reducing the X server bits per pixel depth (e.g. to 16bpp or even 8bpp) will further decrease memory I/O and network I/O. The ShadowFB X server setting will make **x11vnc**'s screen polling less severe. Using the [`-onetile`](x11vnc_opts.html#opt-onetile) option will use less memory and use fewer shared memory slots (add [`-fs 1.0`](x11vnc_opts.html#opt-fs) for one less slot.)

<a name="faq-more-resource"></a><a name="FAQ-73"></a>

**Q-73:** <font color="#007f00">How can I make **x11vnc** use MORE system resources?</font>

You can try [`-threads`](x11vnc_opts.html#opt-threads) (note this mode can be unstable and/or crash; and as of May/2008 is strongly discouraged, see the option description) or dial down the wait time (e.g. `-wait 1`) and possibly dial down [`-defer`](x11vnc_opts.html#opt-defer) as well. Note that if you try to increase the "frame rate" too much you can bog down the server end with the extra work it needs to do compressing the framebuffer data, etc.

That said, it is possible to "stream" video via **x11vnc** if the video window is small enough. E.g. a 256x192 `xawtv` TV capture window (using the **x11vnc** [`-id`](x11vnc_opts.html#opt-id) option) can be streamed over a LAN or wireless at a reasonable frame rate. If the graphics card's framebuffer read rate is [faster](index.html#fb_read_slow) than normal then the video window size and frame rate can be much higher. The use of [TurboVNC](#faq-turbovnc) and/or TurboJPEG can make the frame rate somewhat higher still (but most of this hinges on the graphics card's read rate.)

<a name="faq-slow-link"></a><a name="FAQ-74"></a>

**Q-74:** <font color="#007f00">I use **x11vnc** over a slow link with high latency (e.g. dialup modem or broadband), is there anything I can do to speed things up?</font>

Some things you might want to experiment with (many of which will help performance on faster links as well):

  X server/session parameters:

*   Configure the X server bits per pixel to be 16bpp or even 8bpp. (reduces amount of data needed to be polled, compressed, and sent)
*   Use a smaller desktop size (e.g. 1024x768 instead of 1280x1024)
*   Make sure the desktop background is a **solid color** (the background is resent _every_ time it is re-exposed.) Consider using the [`-solid [color]`](x11vnc_opts.html#opt-solid) option to try to do this automatically.
*   Configure your window manager or desktop "theme" to not use fancy images, shading, and gradients for the window decorations, etc. Disable window animations, etc. Maybe your desktop has a "low bandwidth" theme you can easily switch into and out of. Also in Firefox disable eye-candy, e.g.: Edit -> Preferences -> Advanced -> Use Smooth Scrolling (deselect it.)
*   Avoid small scrolls of large windows using the Arrow keys or scrollbar. Try to use PageUp/PageDown instead. (not so much of a problem in x11vnc 0.7.2 if [`-scrollcopyrect`](x11vnc_opts.html#opt-scrollcopyrect) is active and detecting scrolls for the application.)
*   If the [`-wireframe`](x11vnc_opts.html#opt-wireframe) option is not available (earlier than x11vnc 0.7.2 or you have disabled it via `-nowireframe`) then Disable Opaque Moves and Resizes in the window manager/desktop.
*   _**However**_ if `-wireframe` is active (on by default in x11vnc 0.7.2) then you should _**Enable**_ Opaque Moves and Resizes in the window manager! This seems counter-intuitive, but because x11vnc detects the move/resize events _early_ there is a _huge_ speedup over a slow link when Opaque Moves and Resizes are enabled. (e.g. CopyRect encoding will be used.)
*   Turn off Anti-aliased fonts on your system, web browser, terminal windows, etc. AA fonts do not compress as well as traditional fonts (sometimes 10X less.)
*   On Firefox/Mozilla (and anything else) turn off "Smooth Scroll" animations. In Firefox put in the URL "about:config" and set `general.smoothScroll` to false.
*   On Xorg/XFree86 turn on the Shadow Framebuffer to speed up reading. (`Option "ShadowFB" "true"` in the Device section of `/etc/X11/XF86Config`) This disables 2D acceleration on the physical display and so may not be worth it (if you play games, etc), but could be of use in some situations. Note: If the network link is very slow, this speedup may not be noticed.

  VNC viewer parameters:

*   Use a [TightVNC enabled viewer](http://www.tightvnc.com)! (Actually, RealVNC 4.x viewer with ZRLE encoding is not too bad either; some claim it is faster.)
*   Make sure the `tight` (or `zrle`) encoding is being used (look at `vncviewer` and `x11vnc` outputs)
*   Request 8 bits per pixel using `-bgr233` (up to 4X speedup over depth 24 TrueColor (32bpp), but colors will be off)
*   RealVNC 4.x viewer has some _extremely_ low color modes (only 64 and even 8 colors.) [SSVNC does too](ssvnc.html). The colors are poor, but it is usually noticeably faster than bgr233 (256 colors.)
*   Try increasing the TightVNC `-compresslevel` (compresses more on server side before sending, but uses more CPU)
*   Try reducing the TightVNC `-quality` (increases JPEG compression, but is lossy with painting artifacts)
*   Try other VNC encodings via `-encodings` (`tight` may be the fastest, but you should compare it to `zrle` and maybe some of the others)
*   On the machine where `vncviewer` is run, make sure Backing Store is enabled (Xorg/XFree86 disables it by default causing re-exposures of `vncviewer` to be _very_ slow) `Option "backingstore"` in config file.

  **x11vnc** parameters:

*   Make sure the [`-wireframe`](x11vnc_opts.html#opt-wireframe) option is active (it should be on by default) and you have Opaque Moves/Resizes _Enabled_ in the window manager.
*   Make sure the [`-scrollcopyrect`](x11vnc_opts.html#opt-scrollcopyrect) option is active (it should be on by default.) This detects scrolls in many (but not all) applications an applies the CopyRect encoding for a big speedup.
*   Enforce a solid background when VNC viewers are connected via [`-solid`](x11vnc_opts.html#opt-solid)
*   Try x11vnc's client-side caching [client-side caching](#faq-client-caching) scheme: [`-ncache`](x11vnc_opts.html#opt-ncache)
*   Specify [`-speeds modem`](x11vnc_opts.html#opt-speeds) to force the wireframe and scrollcopyrect heuristic parameters (and any future ones) to those of a dialup modem connection (or supply the `rd,bw,lat` numerical values that characterize your link.)
*   If wireframe and scrollcopyrect aren't working, try using the more drastic [`-nodragging`](x11vnc_opts.html#opt-nodragging) (no screen updates when dragging mouse, but sometimes you miss visual feedback)
*   Set [`-fs 1.0`](x11vnc_opts.html#opt-fs) (disables fullscreen updates)
*   Try increasing [`-wait`](x11vnc_opts.html#opt-wait) or [`-defer`](x11vnc_opts.html#opt-defer) (reduces the maximum "frame rate", but won't help much for large screen changes)
*   Try the [`-progressive pixelheight`](x11vnc_opts.html#opt-progressive) mode with the block `pixelheight` 100 or so (delays sending vertical blocks since they may change while viewer is receiving earlier ones)
*   If you just want to watch one (simple) window use [`-id`](x11vnc_opts.html#opt-id) or [`-appshare`](x11vnc_opts.html#opt-appshare) (cuts down extraneous polling and updates, but can be buggy or insufficient)
*   Set [`-nosel`](x11vnc_opts.html#opt-nosel) (disables all clipboard selection exchange)
*   Use [`-nocursor`](x11vnc_opts.html#opt-nocursor) and [`-nocursorpos`](x11vnc_opts.html#opt-nocursorpos) (repainting the remote cursor position and shape takes resources and round trips)
*   On very slow links (e.g. <= 28.8) you may need to increase the [`-readtimeout n`](x11vnc_opts.html#opt-readtimeout) setting if it sometimes takes more than 20sec to paint the full screen, etc.
*   Do not use [`-fixscreen`](x11vnc_opts.html#opt-fixscreen) to automatically refresh the whole screen, tap three `Alt_L`'s then the screen has painting errors (rare problem.)

_**Example for the KDE desktop:**_

Launch the "KDE Control Center" utility. Sometimes this is called "Personal Settings".

Select "Desktop".

 Then Select "Window Behavior". In the "Moving" Tab set these:

*   YES - Display content in moving windows
*   YES - Display content in resizing windows
*   NO   - Display window geometry when moving or resizing
*   NO   - Animate minimize and restore

 In the "Translucency" Tab set:

*   NO   - Use translucency/shadows

Next hit "Back" and then select "Panels".

 In the "Appearance" Tab set:

*   NO   - Enable icon mouseover effects
*   NO   - Enable transparency

Now go all the way back up to the top and Select "Appearance & Themes".

 Select "Background" and set:

*   YES - No picture
*   Colors: Single Color

 Select "Fonts" and disable anti-aliased fonts if you are bold enough.

 Select "Launch Feedback" and set:

*   Busy Cursor: No Busy Cursor
*   NO   - Enable taskbar notification

 Select "Screen Saver" and set:

*   Screen Saver: Blank Screen

 Select "Style" and in the "Effects" Tab set:

*   NO   - Enable GUI effects

_**Example for the GNOME desktop:**_

*   TBD.

<a name="faq-xdamage"></a><a name="FAQ-75"></a>

**Q-75:** <font color="#007f00">Does **x11vnc** support the X DAMAGE Xserver extension to find modified regions of the screen quickly and efficiently?</font>

Yes, as of Mar/2005 **x11vnc** will use the X DAMAGE extension by default if it is available on the display. This requires `libXdamage` to be available in the build environment as well (recent Linux distros and Solaris 10 have it.)

The DAMAGE extension enables the X server to report changed regions of the screen back to **x11vnc**. So **x11vnc** doesn't have to guess where the changes are (by polling every pixel of the entire screen every 2-4 seconds.) The use of X DAMAGE dramatically reduces the load when the screen is not changing very much (i.e. most of the time.) It also noticeably improves updates, especially for very small changed areas (e.g. clock ticking, cursor flashing, typing, etc.)

Note that the DAMAGE extension does not speed up the actual _reading_ of pixels from the video card framebuffer memory, by, say, mirroring them in main memory. So reading the fb is still painfully [slow (e.g. 5MB/sec)](index.html#fb_read_slow), and so even using X DAMAGE when large changes occur on the screen the bulk of the time is still spent retrieving them. Not ideal, but use of the ShadowFB XFree86/Xorg option speeds up the reading considerably (at the cost of h/w acceleration.)

Unfortunately the current Xorg DAMAGE extension implementation can at times be overly conservative and report very large rectangles as "damaged" even though only a small portion of the pixels have actually been modified. This behavior is often the fault of the window manager (e.g. it redraws the entire, unseen, frame window underneath the application window when it gains focus), or the application itself (e.g. does large, unnecessary repaints.)

To work around this deficiency, **x11vnc** currently only trusts small DAMAGE rectangles to contain real damage. The larger rectangles are only used as hints to focus the traditional scanline polling (i.e. if a scanline doesn't intersect a recent DAMAGE rectangle, the scan is skipped.) You can use the "[`-xd_area A`](x11vnc_opts.html#opt-xd_area)" option to adjust the size of the trusted DAMAGE rectangles. The default is 20000 pixels (e.g. a 140x140 square, etc.) Use "`-xd_area 0`" to disable the cutoff and trust _all_ DAMAGE rectangles.

The option "[`-xd_mem f`](x11vnc_opts.html#opt-xd_mem)" may also be of use in tuning the algorithm. To disable using DAMAGE entirely use "[`-noxdamage`](x11vnc_opts.html#opt-noxdamage)".

<a name="faq-xdamage-opengl"></a><a name="FAQ-76"></a>

**Q-76:** <font color="#007f00">My OpenGL application shows no screen updates unless I supply the `-noxdamage` option to **x11vnc**.</font>

One user reports in his environment (MythTV using the NVIDIA OpenGL drivers) he gets no updates after the initial screen is drawn unless he uses the "[`-noxdamage`](x11vnc_opts.html#opt-noxdamage)" option.

This seems to be a bug in the X DAMAGE implementation of that driver. You may have to use `-noxdamage` as well. A way to autodetect this will be tried, probably the best it will do is automatically stop using X DAMAGE.

A developer for [MiniMyth](http://minimyth.org/) reports that the 'alphapulse' tag of the theme G.A.N.T. can also cause problems, and should be avoided when using VNC.

_Update:_ see [this FAQ](#faq-beryl) too.

<a name="faq-pointer-mode"></a><a name="FAQ-77"></a>

**Q-77:** <font color="#007f00">When I drag windows around with the mouse or scroll up and down things really bog down (unless I do the drag in a single, quick motion.) Is there anything to do to improve things?</font>

This problem is primarily due to [slow hardware read rates](index.html#fb_read_slow) from video cards: as you scroll or move a large window around the screen changes are much too rapid for x11vnc to keep up them (it can usually only read the video card at about 5-10 MB/sec, so it can take a good fraction of a second to read the changes induce from moving a large window, if this to be done a number of times in succession the window or scroll appears to "lurch" forward.) See the description in the [`-pointer_mode`](x11vnc_opts.html#opt-pointer_mode) option for more info. The next bottleneck is compressing all of these changes and sending them out to connected viewers, however the VNC protocol is pretty much self-adapting with respect to that (updates are only packaged and sent when viewers ask for them.)

As of Jan/2004 there are some improvements to **libvncserver**. The default should now be much better than before and dragging small windows around should no longer be a huge pain. If for some reason these changes make matters worse, you can go back to the old way via the "[`-pointer_mode 1`](x11vnc_opts.html#opt-pointer_mode)" option.

Also added was the [`-nodragging`](x11vnc_opts.html#opt-nodragging) option that _disables all_ screen updates while dragging with the mouse (i.e. mouse motion with a button held down.) This gives the snappiest response, but might be undesired in some circumstances when you want to see the visual feedback while dragging (e.g. menu traversal or text selection.)

As of Dec/2004 the [`-pointer_mode n`](x11vnc_opts.html#opt-pointer_mode) option was introduced. n=1 is the original mode, n=2 an improvement, etc.. See the `-pointer_mode n` help for more info.

Also, in some circumstances the [`-threads`](x11vnc_opts.html#opt-threads) option can improve response considerably. Be forewarned that if more than one vncviewer is connected at the same time then `libvncserver` may not be thread safe (try to get the viewers to use different VNC encodings, e.g. tight and ZRLE.) This option can be unstable and so as of Feb/2008 it is disabled by default. Set env. `X11VNC_THREADED=1` to re-enable.

As of Apr/2005 two new options (see the [wireframe FAQ](#faq-wireframe) and [scrollcopyrect FAQ](#faq-scrollcopyrect) below) provide schemes to sweep this problem under the rug for window moves or resizes and for some (but not all) window scrolls. These are the preferred way of avoiding the "lurching" problem, contact me if they are not working. Note on SuSE and some other distros the RECORD X extension used by scrollcopyrect is not enabled by default, turn it on in `xorg.conf`:

<pre>Section "Module"
        ...
        Load  "record"
        ...
EndSection
</pre>

<a name="faq-wireframe"></a><a name="FAQ-78"></a>

**Q-78:** <font color="#007f00">Why not do something like wireframe animations to avoid the windows "lurching" when being moved or resized?</font>

Nice idea for a hack! As of Apr/2005 **x11vnc** by default will apply heuristics to try to guess if a window is being (opaquely) moved or resized. If such a change is detected framebuffer polling and updates will be suspended and only an animated "wireframe" (a rectangle outline drawn where the moved/resized window would be) is shown. When the window move/resize stops, it returns to normal processing: you should only see the window appear in the new position. This spares you from interacting with a "lurching" window between all of the intermediate steps. BTW the lurching is due to [slow video card read rates](#faq-pointer-mode) (see [here too](index.html#fb_read_slow).) A displacement, even a small one, of a large window requires a non-negligible amount of time, a good fraction of a second, to read in from the hardware framebuffer.

Note that Opaque Moves/Resizes must be **Enabled** by your window manager for `-wireframe` to do any good.

The mode is currently on by default because most people are afflicted with the problem. It can be disabled with the [`-nowireframe`](x11vnc_opts.html#opt-wireframe) option (aka `-nowf`.) Why might one want to turn off the wireframing? Since **x11vnc** is merely guessing when windows are being moved/resized, it may guess poorly for your window-manager or desktop, or even for the way you move the pointer. If your window-manager or desktop already does its own wireframing then this mode is a waste of time and could do the wrong thing occasionally. There may be other reasons the new mode feels unnatural. If you have very expensive video hardware (SGI, well now even proprietary Xorg drivers are fast at reading) or are using an in-RAM video framebuffer (SunRay, ShadowFB, Xvfb), the read rate from _that_ framebuffer may be very fast (100's of MB/sec) and so you don't really see much lurching (at least over a fast LAN): opaque moves look smooth in **x11vnc**. Note: ShadowFB is often turned on when you are using the `vesafb` or `fbdev` XFree86 video driver instead of a native one so you might be using it already and not know.

The heuristics used to guess window motion or resizing are simple, but are not fool proof: **x11vnc** is sometimes tricked and so you'll occasionally see the lurching opaque move and rarely something even worse.

First it assumes that the move/resize will occur with a mouse button pressed, held down and dragged (of course this is only mostly true.) Next it will only consider a window for wireframing if the mouse pointer is initially "close enough" to the edges of the window frame, e.g. you have grabbed the title bar or a resizer edge (this requirement can be disabled and it also not applied if a modifier key, e.g. Alt, is pressed.) If these are true, it will wait an amount of time to see if the window starts moving or resizing. If it does, it starts drawing the wireframe "outline" of where the window would be. When the mouse button is released, or a timeout occurs, it goes back to the standard mode to allow the actual framebuffer changes to propagate to the viewers.

These parameters can be tweaked:

*   Color/Shade of the wireframe.
*   Linewidth of the outline frame.
*   Cutoff size of windows to not apply wireframing to.
*   Cutoffs for closeness to Top, Bottom, Left, and Right edges of window.
*   Modifier keys to enable interior window grabbing.
*   Maximum time to wait for dragging pointer events.
*   Maximum time to wait for the window to start moving/resizing.
*   Maximum time to show a wireframe animation.
*   Minimum time between sending wireframe outlines.

See the ["`-wireframe tweaks`"](x11vnc_opts.html#opt-wireframe) option for more details. On a slow link, e.g. dialup modem, the parameters may be automatically adjusted for better response.

<a name="infaq_wirecopyrect"></a>_CopyRect encoding:_  In addition to the above there is the ["`-wirecopyrect mode`"](x11vnc_opts.html#opt-wireframe) option. It is also on by default. This instructs **x11vnc** to not only show the wireframe animation, but to also instruct all connected VNC viewers to locally translate the window image data from the original position to the new position on the screen when the animation is done. This speedup is the VNC CopyRect encoding: the framebuffer update doesn't need to send the actual new image data. This is nice in general, and very convenient over a slow link, but since it is based on heuristics you may need to disable it with the `-nowirecopyrect` option (aka `-nowcr`) if it works incorrectly or unnaturally for you.

The `-wirecopyrect` modes are: "never" (same as `-nowirecopyrect`); "top", only apply the CopyRect if the window is appears to be on the top of the window stack and is not obstructed by other windows; and "always" to always try to apply the CopyRect (obstructed regions are usually clipped off and not translated.)

Note that some desktops (KDE and xfce) appear to mess with the window stacking in ways that are not yet clear. In these cases **x11vnc** works around the problem by applying the CopyRect even if obscuring windows' data is translated! Use `-nowirecopyrect` if this yields undesirable effects for your desktop.

Also, the CopyRect encoding may give incorrect results under `-scale` (depending on the scale factor the CopyRect operation is often only approximate: the correctly scaled framebuffer will be slightly different from the translated one.) **x11vnc** will try to push a "cleanup" update after the CopyRect if `-scale` is in effect. Use `-nowirecopyrect` if this or other painting errors are unacceptable.

<a name="faq-scrollcopyrect"></a><a name="FAQ-79"></a>

**Q-79:** <font color="#007f00">Can **x11vnc** try to apply heuristics to detect when a window is scrolling its contents and use the CopyRect encoding for a speedup?</font>

Another nice idea for a hack! As of May/2005 **x11vnc** will by default apply heuristics to try to detect if the window that has the input focus is scrolling its contents (but only when **x11vnc** is feeding user input, keystroke or pointer, to the X server.) So, when detected, scrolls induced by dragging on a scrollbar or by typing (e.g. Up or Down arrows, hitting Return in a terminal window, etc), will show up much more quickly than via the standard **x11vnc** screen polling update mechanism.

There will be a speedup for _both_ slow and fast links to viewers. For slow links the speedup is mostly due to the CopyRect encoding not requiring the image data to be transmitted over the network. For fast links the speedup is primarily due to **x11vnc** _not having to read the scrolled framebuffer data_ from the X server (recall that reading from the hardware framebuffer is [slow](index.html#fb_read_slow).)

To do this **x11vnc** uses the RECORD X extension to snoop the X11 protocol between the X client with the focus window and the X server. This extension is usually present on most X servers (but SuSE disables it for some reason.) On XFree86/Xorg it can be enabled via `Load "record"` in the `Module` section of the config file if it isn't already:

<pre>Section "Module"
        ...
        Load  "record"
        ...
EndSection
</pre>

Currently the RECORD extension is used as little as possible so as to not slow down regular use. Only simple heuristics are applied to detect `XCopyArea` and `XConfigureWindow` calls from the application. These catch a lot of scrolls, e.g. in mozilla/firefox and in terminal windows like gnome-terminal and xterm. Unfortunately the toolkits KDE applications use make scroll detection less effective (only rarely are they detected: i.e. Konqueror and Konsole don't work.) An interesting project, that may be the direction **x11vnc** takes, is to record _all_ of the X11 protocol from all clients and try to "tee" the stream into a modified Xvfb watching for CopyRect and other VNC speedups. A potential issue is the RECORD stream is delayed from actual view on the X server display: if one falls too far behind it could become a mess...

The initial implementation of [`-scrollcopyrect`](x11vnc_opts.html#opt-scrollcopyrect) option is useful in that it detects many scrolls and thus gives a much nicer working environment (especially when combined with the [`-wireframe`](x11vnc_opts.html#opt-wireframe) [`-wirecopyrect`](x11vnc_opts.html#opt-wirecopyrect) [options](#faq-wireframe), which are also on by default; and if you are willing to enable the ShadowFB things are _very_ fast.) The fact that there aren't long delays or lurches during scrolling is the primary improvement.

But there are some drawbacks:

*   Not all scrolls are detected. Some apps scroll windows in ways that cannot currently be detected, and other times **x11vnc** "misses" the scroll due to timeouts, etc. Sometimes it is more distracting that a speedup occasionally doesn't work as opposed to being consistently slow!
*   For rapid scrolling (i.e. sequence of many scrolls over a short period) there can be painting errors (tearing, bunching up, etc.) during the scroll. These will repair themselves after the scroll is over, but when they are severe it can be distracting. Try to think of the approximate window contents as a quicker and more useful "animation" compared to the slower polling scheme...
*   Scrolling inside shells in terminal windows (gnome-terminal, xterm), can lead to odd painting errors. This is because **x11vnc** did not have time to detect a screen change just before the scroll (most common is the terminal undraws the block cursor before scrolling the text up: in the viewer you temporarily see multiple block cursors.) Another issue is with things like `more(1)`: scroll detection for 5-6 lines happens nicely, but then it can't keep up and so there is a long pause for the standard polling method to deliver the remaining updates.
*   More rarely sometimes painting errors are _not_ repaired after the scroll is over. This may be a bug in x11vnc or libvncserver, or it may be an inescapable fact of the CopyRect encoding and the delay between RECORD callbacks and what is actually on the X display. One can tap the `Alt_L` key (Left "Alt" key) 3 times in a row to signal **x11vnc** to refresh the screen to all viewers. Your VNC-viewer may have its own screen refresh hot-key or button. See also: [`-fixscreen`](x11vnc_opts.html#opt-fixscreen)
*   Some applications, notably OpenOffice, do `XCopyArea` scrolls in weird ways that assume ancestor window clipping is taking place. See the [`-scr_skip`](x11vnc_opts.html#opt-scr_skip) option for ways to tweak this on a per-application basis.
*   Selecting text while dragging the mouse may be slower, especially if the Button-down event happens near the window's edge. This is because the scrollcopyrect scheme is watching for scrolls via RECORD and has to wait for a timeout to occur before it does the update.
*   For reasons not yet understood the RECORD extension can stop responding (and hence scrolls are missed.) As a workaround **x11vnc** attempts to reset the RECORD connection every 60 seconds or so. Another workaround is to type 4 `Super_L` (Left Super/Windows-Flag key) in a row to reset RECORD. Work is in progress to try to fix this bug.
*   Sometimes you need to "retrain" **x11vnc** for a certain window because it fails to detect scrolls in it. Sometimes clicking inside the application window or selecting some text in it to force the focus helps.
*   When using the [`-scale`](x11vnc_opts.html#opt-scale) option there will be a quick CopyRect scroll, but it needs to be followed by a slower "cleanup" update. This is because for a fixed finite screen resolution (e.g. 75 dpi) scaling and copyrect-ing are not exactly independent. Scaling involves a blending of nearby pixels and if you translate a pixel the neighbor pixel weighting may be different. So you have to wait a bit for the cleanup update to finish. On slow links **x11vnc** may automatically decide to not detect scrolls when `-scale` is in effect. In general it will also try to defer the cleanup update if possible.

If you find the `-scrollcopyrect` behavior too approximate or distracting you can go back to the standard polling-only update method with the [`-noscrollcopyrect`](x11vnc_opts.html#opt-scrollcopyrect) (or `-noscr` for short.) If you find some extremely bad and repeatable behavior for `-scrollcopyrect` please report a bug.

Alternatively, as with `-wireframe`, there are many tuning parameters to try to improve the situation. You can also access these parameters inside the gui under "Tuning". These parameters can be tweaked:

*   The minimum pixel area of a rectangle to be watched for scrolls.
*   A list if application names to skip scroll detection.
*   Which keystrokes should trigger scroll detection.
*   Which applications should have a "terminal" tweak applied to them.
*   When repeating keys (e.g. Up arrow) should be discarded to preserve a scroll.
*   Cutoffs for closeness to Top, Bottom, Left, and Right edges of window for mouse induced scrolls.
*   Set timeout parameters for keystroke induced scrolls.
*   Set timeout parameters for mouse pointer induced scrolls.
*   Have the full screen be periodically refreshed to fix painting errors.

<a name="faq-client-caching"></a><a name="FAQ-80"></a>

**Q-80:** <font color="#007f00">Can **x11vnc** do client-side caching of pixel data? I.e. so when that pixel data is needed again it does not have to be retransmitted over the network.</font>

As of Dec/2006 in the [0.9 development tarball](index.html#beta-test) there is an experimental client-side caching implementation enabled by the "[`-ncache n`](x11vnc_opts.html#opt-ncache)" option. In fact, during the test period it was on by default with `n` set to 10\. To disable it use "`-noncache`".

It is a simple scheme where a (**very** large) lower portion of the framebuffer (i.e. starting just below the user's actual desktop display) is used for storing pixel data. CopyRect; a fast, essentially local viewer-side VNC encoding; is used to swap the pixel data in and out of the actual display area. It gives an excellent speedup for iconifying/deiconifying and moving windows and re-posting of menus (often it doesn't feel like VNC at all: there is no delay waiting for the pixel data to fill in.)

This scheme is nice because it does all of this within the existing VNC protocol, and so it works with all VNC viewers.

A challenge to doing more sophisticated (e.g. compressed and/or shared) client-side caching is that one needs to extend the VNC protocol, modify a viewer and then also convince users to adopt your modified VNC Viewer (or get the new features to be folded into the main VNC viewers, patches accepted, etc... likely takes many years before they might be deployed in the field.) So it is convenient that the "`-ncache n`" works with any unaltered VNC viewer.

A drawback of the "`-ncache n`" method is that in the VNC Viewer you can scroll down and **actually see** the cached pixel data. So it looks like there is a bug: you can scroll down in your viewer and see a strange "history" of windows on your desktop. This is working as intended. One will need to try to adjust the size of his VNC Viewer window so the cache area cannot be seen. [SSVNC](ssvnc.html) (see below) can do this automatically.

At some point LibVNCServer may implement a "rfbFBCrop" pseudoencoding that viewers can use to learn which portion of the framebuffer to actually show to the users (with the hidden part used for caching, or perhaps something else, maybe double buffering or other offscreen rendering...)

The Enhanced TightVNC Viewer (SSVNC) Unix viewer has a nice [-ycrop](ssvnc.html#ycrop) option to help hide the pixel cache area from view. It will turn on automatically if the framebuffer appears to be very tall (height more than twice the width), or you can supply the actual value for the height. If the screen is resized by scaling, etc, the ycrop value is scaled as well. In fullscreen mode you cannot scroll past the end of the actual screen, and in non-fullscreen mode the window manager frame is adjusted to fit the actual display (so you don't see the pixel cache region) and the scrollbars are very thin to avoid distraction and trouble fitting inside your display. Use the "`-sbwidth n`" viewer option to make the scrollbars thicker if you like.

Another drawback of the scheme is that it is **VERY** memory intensive, the `n` in "`-ncache n`" is the factor of increase over the base framebuffer size to use for caching. It is an even integer and should be fairly large, 6-12, to achieve good response. This usually requires about 50-100MB of additional RAM on both the client and server sides. For example with `n=6` a 1280x1024 display will use a framebuffer that is 1280x7168: everything below row 1024 is the pixel buffer cache. If you are running on low memory machines or memory is tight because of other running applications you should not use `-ncache`.

The reason for so much memory is because the pixel data is not compressed and so the whole window to be saved must be stored "offscreen". E.g. for a large web browser window this can be nearly 1 million pixels, and that is only for a _single_ window! One typically wants to cycle between 5-10 large active windows. Also because both backing-store (the window's actual contents) and save-unders (the pixels covered up by the window) are cached offscreen that introduces an additional factor of 2 in memory use.

However, even in the smallest usage mode with `n` equal 2 and [`-ncache_no_rootpixmap`](x11vnc_opts.html#opt-ncache_no_rootpixmap) set (this requires only 2X additional framebuffer memory) there is still a noticable improvement for many activities, although it is not as dramatic as with, say `n` equal 12 and rootpixmap (desktop background) caching enabled.

The large memory consumption of the current implementation can be thought of as a tradeoff to providing caching _and_ being compatible with all VNC viewers and also ease of implementing. Hopefully it can be tuned to use less, or the VNC community will extend the protocol to allow caching and replaying of compressed blobs of data.

Another option to experiment with is "[`-ncache_cr`](x11vnc_opts.html#opt-ncache_cr)". By specifying it, **x11vnc** will try to do smooth _opaque_ window moves instead of its wireframe. This can give a very nice effect (note: on Unix the realvnc viewer seems to be smoother than the tightvnc viewer), but can lead to some painting problems, and can be jerky in some circumstances.

Surprisingly, for very slow connections, e.g. modem, the `-ncache_cr` option can actually improve window drags. This is probably because no pixel data (only CopyRect instructions) are sent when dragging a window. Normally, the wireframe must be sent and this involves compressing and sending the lines that give rise to the moving box effect (note that real framebuffer data is sent to "erase" the white lines of the box.)

If you experience painting errors you can can tap the `Alt_L` key (Left "Alt" key) 3 times in a row to signal **x11vnc** to refresh the screen to all viewers. You may also need to iconify and then deiconify any damaged windows to correct their cache data as well. Note that if you change color viewer depth (e.g. 8bpp to full color) dynamically that will usually lead to the entire extended framebuffer being resent which can take a long time over very slow links: it may be better to reconnect and reset the format right after doing so. **x11vnc** will try to detect the format change and clear (make completely black) the cache region.  

_Gotcha for older Unix VNC Viewers:_ The older Unix VNC viewers (e.g. current TightVNC Unix Viewer) require X server backingstore to keep off-viewer screen data local. If the viewer-side X server has backingstore disabled (sadly, currently the default on Linux, etc), then to get the offscreen pixels the viewer has to ask for a refresh over the network, thereby defeating the caching. Use something like this in your viewer-side `/etc/X11/xorg.conf` file (or otherwise get your viewer-side system to do it)

<pre>Section "Device"
        ...
        Option  "backingstore"
        ...
EndSection
</pre>

No problems like this have been observed with Windows VNC Viewers: they all seem to keep their entire framebuffer in local memory.  

_Gotcha for KDE krdc VNC Viewer:_ One user found that KDE's krdc viewer has some sort of hardwired limit on the maximum size of the framebuffer (64MB?). It fails quickly saying "The connection to the host has been interrupted." The workaround for his 1280x1024 x11vnc-side display was to run with "`-ncache 10`", i.e. a smaller value to be under the krdc threshold.

Although this scheme is not as quick (nor as compressed) as nx/nomachine, say, it does provide a good step in the direction of improving VNC performance by client side caching.

<a name="faq-turbovnc"></a><a name="FAQ-81"></a>

**Q-81:** <font color="#007f00">Does **x11vnc** support TurboVNC?</font>

As of Feb/2009 (development tarball) there is an experimental kludge to let you build **x11vnc** using TurboVNC's modified TightVNC encoding. [TurboVNC](http://www.virtualgl.org/About/TurboVNC) is part of the [VirtualGL](http://www.virtualgl.org/) project. It does two main things to speed up the TightVNC encoding:

*   It eliminates bottlenecks, overheads, wait-times in the TightVNC encoding implementation and instead only worries about sending very well (and quickly) compressed JPEG data.
*   A fast proprietary JPEG implemention is used (Intel IPP on x86) instead of the usual `libjpeg` implementation. [TurboJPEG](http://sourceforge.net/project/showfiles.php?group_id=117509&package_id=166100) is an interface library, `libturbojpeg`, provided by the project that achieves this.

TurboVNC works very well over LAN and evidently fast Broadband too. When using it with **x11vnc** in such a situation you may want to dial down the delays, e.g. "[`-wait 5`](x11vnc_opts.html#opt-wait)" and "[`-defer 5`](x11vnc_opts.html#opt-defer)" (or even a smaller setting) to poll and pump things out more quickly.

See the instructions in "`x11vnc/misc/turbovnc/README`" for how to build **x11vnc** with TurboVNC support. You will also need to download the [TurboJPEG](http://sourceforge.net/project/showfiles.php?group_id=117509&package_id=166100) software.

In brief, the steps look like this:

<pre>  cd x11vnc-x.y.z/x11vnc/misc/turbovnc
  ./apply_turbovnc
  cd ../../..
  env LDFLAGS='-L/DIR -Xlinker --rpath=/DIR' ./configure
  make AM_LDFLAGS='-lturbojpeg'
</pre>

where you replace "`/DIR`" with the directory containing `libturbojpeg.so` you downloaded separately. If it works out well enough TurboVNC support will be integrated into **x11vnc** and more of its tuning features will be implemented. Support for TurboVNC in [SSVNC](ssvnc.html) viewer has been added as an experiment as well. If you try either one, let us know how it went.

There also may be some `Linux.i686` and `Darwin.i386` **x11vnc** binaries with TurboVNC support in the [misc. bins](bins) directory. For other platforms you will need to compile yourself.

On relatively cheap and old hardware (Althon64 X2 5000+ / GeForce 6200) **x11vnc** and [SSVNC](ssvnc.html), both TurboVNC enabled, were able to sustain 13.5 frames/sec (fps) and 15 Megapixels/sec using the VirtualGL supplied OpenGL benchmark program `glxspheres`. VirtualGL on higher-end hardware can sustain [20-30 fps](http://www.virtualgl.org/About/Reports) with the `glxspheres` benchmark.

_**Potential Slowdown:**_ As we describe [elsewhere](index.html#fb_read_slow), unless you use **x11vnc** with an X server using, say, NVidia proprietary drivers (or a virtual X server like Xvfb or Xdummy, or in `ShadowFB` mode), then the read rate from the graphics card can be rather slow (e.g. 10 MB/sec) and becomes the bottleneck when using **x11vnc** over fast networks. Note that all of Xorg's drivers currently (2009) have slow read rates (only proprietary drivers appear to have optimized reads.)

So under these (more or less typical) conditions, the speed improvement provided by TurboVNC may only be marginal. Look for this output to see your read rate:

<pre>  28/02/2009 11:11:07 Autoprobing TCP port 
  28/02/2009 11:11:07 Autoprobing selected port 5900
  28/02/2009 11:11:08 fb read rate: 10 MB/sec
  28/02/2009 11:11:08 screen setup finished.
</pre>

A rate of 10 MB/sec means a 1280x1024x24 screen takes 0.5 seconds to read in. TurboVNC compresses that to JPEG in a much shorter time. On the other hand, an NVidia driver may have a read rate of 250 MB/sec and so only takes 0.02 seconds to read the entire screen in. 
<font size="-0">**[Mouse Cursor Shapes]**</font>
<a name="faq-cursor-shape"></a><a name="FAQ-82"></a>

**Q-82:** <font color="#007f00">Why isn't the mouse cursor shape (the little icon shape where the mouse pointer is) correct as I move from window to window?</font>

On X servers supporting XFIXES or Solaris/IRIX Overlay extensions it is possible for **x11vnc** to do this correctly. See a few paragraphs down for the answer.

Historically, the X11 mouse cursor shape (i.e. little picture: an arrow, X, I-beam, resizer, etc) is one of the few _WRITE-only_ objects in X11\. That is, an application can tell the X server what the cursor shape should be when the pointer is in a given window, but a program (like **x11vnc**) unfortunately cannot _read_ this information. I believe this is because the cursor shape is often downloaded to the graphics hardware (video card), but I could be mistaken.

A simple kludge is provided by the "[`-cursor X`](x11vnc_opts.html#opt-cursor)" option that changes the cursor when the mouse is on the root background (or any window has the same cursor as the root background.) Note that desktops like GNOME or KDE often cover up the root background, so this won't work for those cases. Also see the "[`-cursor some`](x11vnc_opts.html#opt-cursor)" option for additional kludges.

Note that as of Aug/2004 on Solaris using the SUN_OVL overlay extension and IRIX, **x11vnc** can show the correct mouse cursor when the [`-overlay`](x11vnc_opts.html#opt-overlay) option is supplied. See [this FAQ](faq.html#infaq_the-overlay-mode) for more info.

Also as of Dec/2004 XFIXES X extension support has been added to allow exact extraction of the mouse cursor shape. XFIXES fixes the problem of the cursor-shape being write-only: **x11vnc** can now query the X server for the current shape and send it back to the connected viewers. XFIXES is available on recent Linux Xorg based distros and [Solaris 10](index.html#solaris10-build).

The only XFIXES issue is the handling of alpha channel _transparency_ in cursors. If a cursor has any translucency then in general it must be approximated to opaque RGB values for use in VNC. There are some situations where the cursor transparency can also handled exactly: when the VNC Viewer requires the cursor shape be drawn into the VNC framebuffer or if you apply a patch to your VNC Viewer to extract hidden alpha channel data under 32bpp. [Details can be found here](#faq-xfixes-alpha-hacks).

<a name="faq-xfixes-alpha"></a><a name="FAQ-83"></a>

**Q-83:** <font color="#007f00">When using XFIXES cursorshape mode, some of the cursors look really bad with extra black borders around the cursor and other cruft. How can I improve their appearance?</font>

This happens for cursors with transparency ("alpha channel"); regular X cursors (bitmaps) should be correct. Unfortunately **x11vnc** 0.7 was released with a very poor algorithm for approximating the transparency, which led to the ugly black borders.

The problem is as follows: XFIXES allows **x11vnc** to retrieve the current X server cursor shape, including the alpha channel for transparency. For traditional bitmap cursors the alpha value will be 0 for completely transparent pixels and 255 for completely opaque pixels; whereas for modern, eye-candy cursors an alpha value between 0 and 255 means to blend in the background colors to that degree with the cursor colors. The pixel color blending formula is something like this: Red = Red_cursor * α + Red_background * (1 - α), (where here 0 ≤ α ≤ 1), with similar for Green and Blue. The VNC protocol does not currently support an alpha channel in cursors: it only supports regular X bitmap cursors and Rich Cursors that have RGB (Red, Green, Blue) color data, but no "A" = alpha data. So in general **x11vnc** has to _approximate_ a cursor with transparency to create a Rich Cursor. This is easier said than done: some cursor themes have cursors with complicated drop shadows and other forms of translucency.

Anyway, for the **x11vnc** 0.7.1 release the algorithm for approximating transparency is much improved and hopefully gives decent cursor shapes for most cursor themes and you don't have to worry about it.

In case it still looks bad for your cursor theme, there are (of course!) some tunable parameters. The "[`-alphacut n`](x11vnc_opts.html#opt-alphacut)" option lets you set the threshold "n" (between 0 and 255): cursor pixels with alpha values below n will be considered completely transparent while values equal to or above n will be completely opaque. The default is 240\. The "[`-alphafrac f`](x11vnc_opts.html#opt-alphafrac)" option tries to correct individual cursors that did not fare well with the default `-alphacut` value: if a cursor has less than fraction `f` (between 0.0 and 1.0) of its pixels selected by the default `-alphacut`, the threshold is lowered until `f` of its pixels are selected. The default fraction is 0.33.

Finally, there is an option [`-alpharemove`](x11vnc_opts.html#opt-alpharemove) that is useful for themes where many cursors are light colored (e.g. "whiteglass".) XFIXES returns the cursor data with the RGB values pre-multiplied by the alpha value. If the white cursors look too grey, specify `-alpharemove` to brighten them by having **x11vnc** divide out the alpha value.

One user played with these parameters and reported back:

<pre> Of the cursor themes present on my system:

   gentoo and gentoo-blue:   alphacut:192 - noalpharemove

   gentoo-silver:            alphacut:127 and alpharemove

   whiteglass and redglass (presumably also handhelds, which is based
   heavily on redglass) look fine with the apparent default of alphacut:255.
</pre>

<a name="faq-xfixes-alpha-hacks"></a><a name="FAQ-84"></a>

**Q-84:** <font color="#007f00">In XFIXES mode, are there any hacks to handle cursor transparency ("alpha channel") exactly?</font>

As of Jan/2005 `libvncserver` has been modified to allow an alpha channel (i.e. RGBA data) for Rich Cursors. So **x11vnc** can now send the alpha channel data to `libvncserver`. However, this data will only be used for VNC clients that do not support the CursorShapeUpdates VNC extension (or have disabled it.) It can be disabled for all clients with the [`-nocursorshape`](x11vnc_opts.html#opt-nocursorshape) **x11vnc** option. In this case the cursor is drawn, correctly blended with the background, into the VNC framebuffer before being sent out to the client. So the alpha blending is done on the **x11vnc** side. Use the [`-noalphablend`](x11vnc_opts.html#opt-noalphablend) option to disable this behavior (always approximate transparent cursors with opaque RGB values.)

The CursorShapeUpdates VNC extension complicates matters because the cursor shape is sent to the VNC viewers supporting it, and the viewers draw the cursor locally. This improves response over slow links. Alpha channel data for these locally drawn cursors is not supported by the VNC protocol.

However, in the `libvncserver` CVS there is a patch to the TightVNC viewer to make this work for CursorShapeUpdates under some circumstances. This hack is outside of the VNC protocol. It requires the screens on both sides to be depth 24 at 32bpp (it uses the extra 8 bits to secretly hide the cursor alpha channel data.) Not only does it require depth 24 at 32bpp, but it also currently requires the client and server to be of the same endianness (otherwise the hidden alpha data gets reset to zero by a `libvncserver` translation function; we can fix this at some point if there is interest.) The patch is for the TightVNC 1.3dev5 Unix vncviewer and it enables the TightVNC viewer to do the cursor alpha blending locally. The patch code should give an example on how to change the Windows TightVNC viewer to achieve the same thing (send me the patch if you get that working.)

This patch is applied to the [Enhanced TightVNC Viewer (SSVNC)](ssvnc.html) package we provide.

<font size="-0">**[Mouse Pointer]**</font>
<a name="faq-cursor-arrow"></a><a name="FAQ-85"></a>

**Q-85:** <font color="#007f00">Why does the mouse arrow just stay in one corner in my vncviewer, whereas my cursor (that does move) is just a dot?</font>

This default takes advantage of a [tightvnc](http://www.tightvnc.com/) extension (CursorShapeUpdates) that allows specifying a cursor image shape for the local VNC viewer. You may disable it with the [`-nocursor`](x11vnc_opts.html#opt-nocursor) option to **x11vnc** if your viewer does not have this extension.

Note: as of Aug/2004 this should be fixed: the default for non-tightvnc viewers (or ones that do not support CursorShapeUpdates) will be to draw the moving cursor into the **x11vnc** framebuffer. This can also be disabled via `-nocursor`.

<a name="faq-cursor-positions"></a><a name="FAQ-86"></a>

**Q-86:** <font color="#007f00">Can I take advantage of the TightVNC extension to the VNC protocol where Cursor Positions Updates are sent back to all connected clients (i.e. passive viewers can see the mouse cursor being moved around by another viewer)?</font>

Use the [`-cursorpos`](x11vnc_opts.html#opt-cursorpos) option when starting **x11vnc**. A VNC viewer must support the Cursor Positions Updates for the user to see the mouse motions (the TightVNC viewers support this.) As of Aug/2004 `-cursorpos` is the default. See also [`-nocursorpos`](x11vnc_opts.html#opt-nocursorpos) and [`-nocursorshape`](x11vnc_opts.html#opt-nocursorshape).

<a name="faq-buttonmap-opt"></a><a name="FAQ-87"></a>

**Q-87:** <font color="#007f00">Is it possible to swap the mouse buttons (e.g. left-handed operation), or arbitrarily remap them? How about mapping button clicks to keystrokes, e.g. to partially emulate Mouse wheel scrolling?</font>

You can remap the mouse buttons via something like: [`-buttonmap 13-31`](x11vnc_opts.html#opt-buttonmap) (or perhaps 12-21.) Also, note that `xmodmap(1)` lets you directly adjust the X server's button mappings, but in some circumstances it might be more desirable to have **x11vnc** do it.

One user had an X server with only one mouse button(!) and was able to map all of the VNC client mouse buttons to it via: `-buttonmap 123-111`.

Note that the [`-debug_pointer`](x11vnc_opts.html#opt-debug_pointer) option prints out much info for every mouse/pointer event and is handy in solving problems.

To map mouse button clicks to keystrokes you can use the alternate format where the keystrokes are enclosed between colons like this :<`KeySym`>: in place of the mouse button digit. For a sequence of keysyms separate them with "+" signs. Look in the include file `<X11/keysymdef.h>`, or use `xev(1)`, or `-debug_keyboard` to find the keysym names. Button clicks can also be included in the sequence via the fake keysyms `Button1`, etc.

As an example, suppose the VNC viewer machine has a mouse wheel (these generate button 4 and 5 events), but the machine that **x11vnc** is run on only has the 3 regular buttons. In normal operation **x11vnc** will discard the button 4 and 5 events. However, either of the following button maps could possibly be of use emulating the mouse wheel events in this case:

<pre>  -buttonmap 12345-123:Prior::Next:
  -buttonmap 12345-123:Up+Up+Up::Down+Down+Down:
</pre>

Exactly what keystroke "scrolling" events they should be bound to depends on one's taste. If this method is too approximate, one could consider not using [`-buttonmap`](x11vnc_opts.html#opt-buttonmap) but rather configuring the X server to think it has a mouse with 5 buttons even though the physical mouse does not. (e.g. '`Option "ZAxisMapping" "4 5"`'.)

Note that when a keysym-mapped mouse button is clicked down this immediately generates the key-press and key-release events (for each keysym in turn if the mapping has a sequence of keysyms.) When the mouse button goes back up nothing is generated.

If you include modifier keys like `Shift_L` instead of key-press immediately followed by key-release the state of the modifier key is toggled (however the initial state of the modifier key is ignored.) So to map the right button to type my name 'Karl Runge' I could use this:

<pre>  -buttonmap 3-:Shift_L+k+Shift_L+a+r+l+space+Shift_L+r+Shift_L+u+n+g+e:
</pre>

(yes, this is getting a little silly.)

BTW, Coming the other way around, if the machine you are sitting at does not have a mouse wheel, but the remote machine does (or at least has 5 buttons configured), this key remapping can be useful:

<pre>  -remap Super_R-Button4,Menu-Button5
</pre>

you just tap those two keys to get the mouse wheel scrolls (this is more useful than the Up and Down arrow keys because a mouse wheel "click" usually gives a multi-line scroll.) 
<font size="-0">**[Keyboard Issues]**</font>
<a name="faq-altgr"></a><a name="FAQ-88"></a>

**Q-88:** <font color="#007f00">How can I get my `AltGr` and `Shift` modifiers to work between keyboards for different languages?</font>

The option [`-modtweak`](x11vnc_opts.html#opt-modtweak) should help here. It is a mode that monitors the state of the `Shift` and `AltGr` Modifiers and tries to deduce the correct keycode to send, possibly by sending fake modifier key presses and releases in addition to the actual keystroke.

_**Update**:_  As of Jul/2004 `-modtweak` is now the default (use `-nomodtweak` to get the old behavior.) This was done because it was noticed on newer XFree86 setups even on bland "us" keyboards like "`pc104 us`" XFree86 included a "ghost" key with both "<" and ">" it. This key does not exist on the keyboard (see [this FAQ](#faq-greaterless) for more info.) Without `-modtweak` there was then an ambiguity in the reverse map keysym => keycode, making it so the "<" symbol could not be typed.

Also see the [FAQ about the `-xkb` option](#faq-xkbmodtweak) for a more powerful method of modifier tweaking for use on X servers with the XKEYBOARD extension.

When trying to resolve keyboard mapping problems, note that the [`-debug_keyboard`](x11vnc_opts.html#opt-debug_keyboard) option prints out much info for every keystroke and so can be useful debugging things.

Note that one user had a strange setup and none of the above helped. His solution was to _disable_ all of the above and use [`-nomodtweak`](x11vnc_opts.html#opt-modtweak). This is the simplest form of keystroke insertion and it actually solved the problem. Try it if the other options don't help.

<a name="faq-greaterless"></a><a name="FAQ-89"></a>

**Q-89:** <font color="#007f00">When I try to type a "<" (i.e. less than) instead I get ">" (i.e. greater than)! Strangely, typing ">" works OK!!</font>

Does your keyboard have a single key with both "<" and ">" on it? Even if it doesn't, your X server may think your keyboard has such a key (e.g. `pc105` in the `XF86Config` file when it should be something else, say `pc104`.)

_Short Cut:_ Try the [`-xkb`](x11vnc_opts.html#opt-xkb) or [`-sloppy_keys`](x11vnc_opts.html#opt-sloppy_keys) options and see if that helps the situation. The discussion below is a bit outdated (e.g. [`-modtweak`](x11vnc_opts.html#opt-modtweak) is now the default) but it is useful reference for various tricks and so is kept.

The problem here is that on the Xserver where **x11vnc** is run there are **two** keycodes that correspond to the "<" keysym. Run something like this to see:

<pre>  xmodmap -pk | egrep -i 'KeyCode|less|greater'
  There are 4 KeySyms per KeyCode; KeyCodes range from 8 to 255.
      KeyCode     Keysym (Keysym) ...
       59         0x002c (comma)  0x003c (less)
       60         0x002e (period) 0x003e (greater)
       94         0x003c (less)   0x003e (greater)
</pre>

That keycode 94 is the special key with both "<" and ">". When **x11vnc** receives the "<" keysym over the wire from the remote VNC client, it unfortunately maps it to keycode 94 instead of 59, and sends 94 to the X server. Since `Shift` is down (i.e. you are Shifting the comma key), the X server interprets this as Shifted-94, which is ">".

A workaround in the X server configuration is to "deaden" that special key:

<pre>  xmodmap -e "keycode 94 = "
</pre>

However, one user said he had to do this:

<pre>  xmodmap -e "keycode 94 = 0x002c 0x003c"
</pre>

(If the numerical values are different for your setup, substitute the ones that correspond to your display. The above `xmodmap` scheme can often be used to work around other ambiguous keysym to keycode mappings.)

Alternatively, here are some **x11vnc** options to try to work around the problem:

<pre>   -modtweak
</pre>

and

<pre>   -remap less-comma
</pre>

These are convenient in that they do not modify the actual X server settings. The former ([`-modtweak`](x11vnc_opts.html#opt-modtweak)) is a mode that monitors the state of the `Shift` and `AltGr` modifiers and tries to deduce the correct keycode sequence to send. Since Jul/2004 `-modtweak` is now the default. The latter ([`-remap less-comma`](x11vnc_opts.html#opt-remap)) is an immediate remapping of the keysym `less` to the keysym `comma` when it comes in from a client (so when `Shift` is down the `comma` press will yield "<".)

See also the [FAQ about the `-xkb` option](#faq-xkbmodtweak) as a possible workaround using the XKEYBOARD extension.

Note that the [`-debug_keyboard`](x11vnc_opts.html#opt-debug_keyboard) option prints out much info for every keystroke to aid debugging keyboard problems.

<a name="faq-greaterless-sloppy"></a><a name="FAQ-90"></a>

**Q-90:** <font color="#007f00">Extra Character Inserted, E.g.: When I try to type a "<" (i.e. less than) instead I get "<," (i.e. an extra comma.)</font>

This is likely because you press "`Shift`" then "`<`" but then released the `Shift` key before releasing the "`<`". Because of a [keymapping ambiguity](#faq-greaterless) the last event "`<` up" is interpreted as "," because that key unshifted is the comma.

This extra character insertion will happen for other combinations of characters: in general it can happen whenever the `Shift` key is released early.

This should not happen in [`-xkb`](x11vnc_opts.html#opt-xkb) mode, because it works hard to resolve the ambiguities. If you do not want to use `-xkb`, try the option [`-sloppy_keys`](x11vnc_opts.html#opt-sloppy_keys) to attempt a similar type of algorithm.

One user had this problem for Italian and German keyboards with the key containing ":" and "." When he typed ":" he would get an extra "." inserted after the ":". The solution was `-sloppy_keys`.

<a name="faq-xkbmodtweak"></a><a name="FAQ-91"></a>

**Q-91:** <font color="#007f00">I'm using an "international" keyboard (e.g. German "de", or Danish "dk") and the `-modtweak` mode works well if the VNC viewer is run on a Unix/Linux machine with a similar keyboard.   But if I run the VNC viewer on Unix/Linux with a different keyboard (e.g. "us") or Windows with any keyboard, I can't type some keys like:   "@", "$", "<", ">", etc. How can I fix this?</font>

The problem with Windows is it does not seem to handle `AltGr` well. It seems to fake it up by sending `Control_L+Alt_R` to applications. The Windows VNC viewer sends those two down keystrokes out on the wire to the VNC server, but when the user types the next key to get, e.g., "@" the Windows VNC viewer sends events bringing the up the `Control_L+Alt_R` keys, and then sends the "@" keysym by itself.

The Unix/Linux VNC viewer on a "us" keyboard does a similar thing since "@" is the `Shift` of the "2" key. The keysyms `Shift` and "@" are sent to the VNC server.

In both cases no `AltGr` is sent to the VNC server, but we know `AltGr` is needed on the physical international keyboard to type a "@".

This all worked fine with **x11vnc** running with the [`-modtweak`](x11vnc_opts.html#opt-modtweak) option (it figures out how to adjust the Modifier keys (`Shift` or `AltGr`) to get the "@".) However it fails under recent versions of XFree86 (and the X.org fork.) These run the XKEYBOARD extension by default and make heavy use of it to handle international keyboards.

To make a long story short, on these newer XFree86 setups the traditional X keymap lookup **x11vnc** uses is no longer accurate. **x11vnc** can't find the keysym "@" anywhere in the keymapping! (even though it is in the XKEYBOARD extended keymapping.)

**_How to Solve:_** As of Jul/2004 **x11vnc** has two changes:

*   `-modtweak` (tweak Modifier keys) is now the default (use `-nomodtweak` to go back to the old way)
*   there is a new option `-xkb` to use the XKEYBOARD extension API to do the Modifier key tweaking.

The [`-xkb`](x11vnc_opts.html#opt-xkb) option seems to fix all of the missing keys: "@", "<", ">", etc.: it is recommended that you try it if you have this sort of problem. Let us know if there are any remaining problems (see the next paragraph for some known problems.) If you specify the `-debug_keyboard` (aka `-dk`) option _twice_ you will get a huge amount of keystroke debugging output (send it along with any problems you report.)

_**Update**:_ as of Jun/2005 **x11vnc** will try to automatically enable [`-xkb`](x11vnc_opts.html#opt-xkb) if it appears that would be beneficial (e.g. if it sees any of "@", "<", ">", "[" and similar keys are mapped in a way that needs the `-xkb` to access them.) To disable this automatic check use `-noxkb`.

_Known problems:_

*   One user had to disable a "ghost" `Mode_switch` key that was causing problems under `-xkb`. His physical `AltGr` key was bound to `ISO_Level3_Shift` (which seems to be the XKEYBOARD way of doing things), while there was a ghost key `Mode_switch` (which seems to be obsolete) in the mapping as well. Both of these keysyms were bound to `Mod5` and **x11vnc** was unfortunately choosing `Mode_switch`.

    From the **x11vnc** `-xkb -dk -dk` output it was noted that `Mode_switch` was attached to keycode 93 (no physical key generates this keycode) while `ISO_Level3_Shift` was attached to keycode 113. The keycode skipping option was used to disable the ghost key: [`-skip_keycodes 93`](x11vnc_opts.html#opt-skip_keycodes)

*   In implementing `-xkb` we noticed that some characters were still not getting through, e.g. "~" and "^". This is not really an XKEYBOARD problem. What was happening was the VNC viewer was sending the keysyms `asciitilde` and `asciicircum` to **x11vnc**, but on the X server with the international keyboard those keysyms were not mapped to any keys. So **x11vnc** had to skip them (Note: as of May/2005 they are added by default see -add_keysyms below.)

    The way these characters are typically entered on international keyboards is by "dead" (aka "mute") keys. E.g. to enter "~" at the physical display the keysym `dead_tilde` is pressed and released (this usually involves holding `AltGr` down while another key is pressed) and then `space` is pressed. (this can also be used get characters with the "~" symbol on top, e.g. "ã" by typing "a" instead of `space`.)

    What to do? In general the VNC protocol has not really solved this problem: what should be done if the VNC viewer sends a keysym not recognized by the VNC server side? Workarounds can possibly be created using the [`-remap`](x11vnc_opts.html#opt-remap) **x11vnc** option:

    <pre>  -remap asciitilde-dead_tilde,asciicircum-dead_circumflex
    </pre>

    etc. Use `-remap filename` if the list is long. Please send us your workarounds for this problem on your keyboard. Perhaps we can have **x11vnc** adjust automatically at some point. Also see the [`-add_keysyms`](x11vnc_opts.html#opt-add_keysyms) option in the next paragraph.

    _**Update**:_ for convenience "[`-remap DEAD`](x11vnc_opts.html#opt-remap)" does many of these mappings at once.

*   To complement the above workaround using the [`-remap`](x11vnc_opts.html#opt-remap), an option [`-add_keysyms`](x11vnc_opts.html#opt-add_keysyms) was added. This option instructs **x11vnc** to bind any unknown Keysyms coming in from VNC viewers to unused Keycodes in the X server. This modifies the global state of the X server. When **x11vnc** exits it removes the extra keymappings it created. Note that the `-remap` mappings are applied first, right when the Keysym is received from a VNC viewer, and only after that would `-add_keysyms`, or anything else, come into play.

    _**Update**:_ `-add_keysyms` is now on by default. Use `-noadd_keysyms` to disable.

<a name="faq-repeated-keys"></a><a name="FAQ-92"></a>

**Q-92:** <font color="#007f00">When typing I sometimes get double, triple, or more of my keystrokes repeated. I'm sure I only typed them once, what can I do?</font>

This may be due to an interplay between your X server's key autorepeat delay and the extra time delays caused by **x11vnc** processing.

Short answer: disable key autorepeating by running the command "`xset r off`" on the Xserver where **x11vnc** is run (restore via "`xset r on`") or use the new (Jul/2004) [`-norepeat`](x11vnc_opts.html#opt-norepeat) **x11vnc** option. You will still have autorepeating because that is taken care of on your VNC viewer side.

_**Update**:_ as of Dec/2004 `-norepeat` is now the default. Use `-repeat` to disable it.

**Details**:
suppose you press a key DOWN and it generates changes in large regions of the screen. The CPU and I/O work **x11vnc** does for the large screen change could be longer than your X server's key autorepeat delay. **x11vnc** may not get to processing the key UP event until after the screen work is completed. The X server believes the key has been held down all this time, and applies its autorepeat rules.

Even without inducing changes in large regions of the screen, this problem could arise when accessing **x11vnc** via a dialup modem or otherwise high latency link (e.g. > 250 ms latency.)

Look at the output of "`xset q`" for the "auto repeat delay" setting. Is it low (e.g. < 300 ms)? If you turn off autorepeat completely: "`xset r off`", does the problem go away?

The workaround is to manually apply "`xset r off`" and "`xset r on`" as needed, or to use the [`-norepeat`](x11vnc_opts.html#opt-norepeat) (which has since Dec/2004 been made the default.) Note that with X server autorepeat turned off the VNC viewer side of the connection will (nearly always) do its own autorepeating so there is no big loss here, unless someone is also working at the physical display and misses his autorepeating.

<a name="faq-repeated-keys-still"></a><a name="FAQ-93"></a>

**Q-93:** <font color="#007f00">The **x11vnc** `-norepeat` mode is in effect, but I _still_ get repeated keystrokes!!</font>

Are you using **x11vnc** to _log in to_ an X session via display manager? (as described in [this FAQ](#faq-display-manager)) If so, **x11vnc** is starting before your session and it disables autorepeat when you connect, but then after you log in your session startup (GNOME, KDE, ...) could be resetting the autorepeat to be on. Or it could be something inside your desktop trying to be helpful that decides to turn it back on.

**x11vnc** in `-norepeat` mode will by default reset autorepeat to off 2 times (to help get thru the session startup problem), but it will not continue to battle with things turning autorepeat back on. It will also turn autorepeat off whenever it goes from a state of zero clients to one client. You can adjust the number of resets via "`-norepeat N`", or use "`-norepeat -1`" to have it keep resetting it whenever autorepeat gets turned back on when clients are connected.

In general you can manually turn autorepeating off by typing "`xset r off`", or a using desktop utility/menu, or "`x11vnc -R norepeat`". If something in your desktop is automatically turning it back on you should figure out how to disable that somehow.

<a name="faq-mod-stuck-down"></a><a name="FAQ-94"></a>

**Q-94:** <font color="#007f00">After using **x11vnc** for a while, I find that I cannot type some (or any) characters or my mouse clicks and drags no longer have any effect, or they lead to strange effects. What happened?</font>

Probably a modifier key, e.g. Control or Alt is "stuck" in a pressed down state.

This happens for VNC in general by the following mechanism. Suppose on the Viewer side desktop there is some hot-key to switch desktops/rooms/spaces, etc. E.g. suppose Alt+LeftArrow moves to the left desktop/room/space. Or suppose an Alt+hotkey combination iconifies a window. This can leave the Alt key pressed down on the remote side.

Consider the sequence that happens. The Alt_L key and then the LeftArrow key go down. Since you are inside the viewer the Alt_L key press is sent to the other side (**x11vnc**) and so it is pressed down in the remote desktop as well. (by "Alt_L" we mean the Alt key on the left-hand side of the keyboard.) Your local desktop (where the VNC Viewer is running) then warps to the new desktop/room/space: **_Leaving the Alt_L key still pressed down in the remote desktop._**

If someone is sitting at the desktop, or when you return in the viewer it may be very confusing because the Alt_L is still pressed down but you (or the person sitting at the desktop) do not realize this. Depending on which remote desktop (**x11vnc** side) is used, it can act very strangely.

A quick workaround when you notice this is to press and release all of the Alt, Shift, Control, Windows-Flag, modifier keys to free the pressed one. You need to do this for **both the left and right** Shift, Alt, Control, etc. keys to be sure.

Note that many VNC Viewers try to guard against this when they are notified by the window system that the viewer app has "lost focus". When it receives the "lost focus" event, the viewer sends VNC Key-Release events for all modifier keys that are currently pressed down. This does not always work, however, since it depends on how the desktop manages these "warps". If the viewer is not notified it cannot know it needs to release the modifiers.

You can also use the [`-clear_mods`](x11vnc_opts.html#opt-clear_mods) option to try to clear all of the modifier keys at **x11vnc** startup. You will still have to be careful that you do not leave the modifier key pressed down during your session. It is difficult to prevent this problem from occurring (short of using `[-remap](x11vnc_opts.html#opt-remap)` to prevent sending **all** of the problem modifier keys, which would make the destkop pretty unusable.)

During a session these **x11vnc** remote control commands can also help:

<pre>   x11vnc -R clear_mods
   x11vnc -R clear_keys
   x11vnc -R clear_locks
   x11vnc -R clear_all
</pre>

A similar problem can occur if you accidentally press the Caps_Lock or Num_Lock down. When these are locked on the remote side it can sometimes lead to strange desktop behavior (e.g. cannot drag or click on windows.) As above you may not notice this because the lock isn't down on the local (Viewer) side. See [this FAQ](#faq-remap-capslock) on lock keys problem. These options may help avoid the problem: `[-skip_lockkeys](x11vnc_opts.html#opt-skip_lockkeys)` and `[-capslock](x11vnc_opts.html#opt-capslock)`. See also `[-clear_all](x11vnc_opts.html#opt-clear_all)`.

<a name="faq-remap-opt"></a><a name="FAQ-95"></a>

**Q-95:** <font color="#007f00">The machine where I run **x11vnc** has an `AltGr` key, but the local machine where I run the VNC viewer does not. Is there a way I can map a local unused key to send an `AltGr`? How about a `Compose` key as well?</font>

Something like "[`-remap Super_R-Mode_switch`](x11vnc_opts.html#opt-remap)" **x11vnc** option may work. Note that `Super_R` is the "Right Windoze(tm) Flaggie" key; you may want to choose another. The `-debug_keyboard` option comes in handy in finding keysym names (so does `xev(1)`.)

For `Compose` how about "`-remap Menu-Multi_key`" (note that `Multi_key` is the official name for `Compose`.) To do both at the same time: "`-remap Super_R-Mode_switch,Menu-Multi_key`" or use "`-remap filename`" to specify remappings from a file.

<a name="faq-sun-alt-meta"></a><a name="FAQ-96"></a>

**Q-96:** <font color="#007f00">I have a Sun machine I run **x11vnc** on. Its Sun keyboard has just one `Alt` key labelled "Alt" and two `Meta` keys labelled with little diamonds. The machine where I run the VNC viewer only has `Alt` keys. How can I send a `Meta` keypress? (e.g. emacs needs this)</font>

Here are a couple ideas. The first one is to simply use `xmodmap(1)` to adjust the Sun X server. Perhaps `xmodmap -e "keysym Alt_L = Meta_L Alt_L"` will do the trick. (there are other ways to do it, one user used: `xmodmap -e "keycode 26 = Meta_L"` for his setup.)

Since `xmodmap(1)` modifies the X server mappings you may not want to do this (because it affects local work on that machine.) Something like the [`-remap Alt_L-Meta_L`](x11vnc_opts.html#opt-remap) to **x11vnc** may be sufficient for ones needs, and does not modify the X server environment. Note that you cannot send `Alt_L` in this case, maybe `-remap Super_L-Meta_L` would be a better choice if the `Super_L` key is typically unused in Unix.

<a name="faq-hpux-multi-key"></a><a name="FAQ-97"></a>

**Q-97:** <font color="#007f00">Running **x11vnc** on HP-UX I cannot type "#" I just get a "3" instead.</font>

One user reports this problem on HP-UX Rel_B.11.23\. The problem was traced to a strange keyboard mapping for the machine (e.g. `xmodmap -pk` output) that looked like:

<pre>  ...
  039  2                  at                 at               at
  ...
  047  3                  numbersign         numbersign       numbersign
</pre>

and similar triple mappings (with two in the AltGr/Mode_switch group) of a keysum to a single keycode.

Use the [-nomodtweak](x11vnc_opts.html#opt-nomodtweak) option as a workaround. You can also use `xmodmap` to correct these mappings in the server, e.g.:

<pre>  xmodmap -e "keycode 47 = 3 numbersign"
</pre>

Also, as of Feb/2007, set the environment variable `MODTWEAK_LOWEST=1` (either in your shell or via "`-env MODTWEAK_LOWEST=1`" option) to handle these mappings better.<a name="faq-remap-button-click"></a><a name="FAQ-98"></a>

**Q-98:** <font color="#007f00">Can I map a keystroke to a mouse button click on the remote machine?</font>

This can be done directly in some X servers using AccessX and Pointer_EnableKeys, but is a bit awkward. It may be more convenient to have **x11vnc** do the remapping. This can be done via the [`-remap`](x11vnc_opts.html#opt-remap) option using the fake "keysyms" `Button1`, `Button2`, etc. as the "to" keys (i.e. the ones after the "-")

As an example, consider a laptop where the VNC viewer is run that has a touchpad with only two buttons. It is difficult to do a middle button "paste" because (using XFree86/Xorg Emulate3Buttons) you have to click both buttons on the touch pad at the same time. This remapping:

<pre>  [-remap Super_R-Button2](x11vnc_opts.html#opt-remap)
</pre>

maps the `Super_R` "flag" key press to the Button2 click, thereby making X pasting a bit easier.

Note that once the key goes down, the button down and button up events are generated immediately on the **x11vnc** side. When the key is released (i.e. goes up) no events are generated.

<a name="faq-remap-capslock"></a><a name="FAQ-99"></a>

**Q-99:** <font color="#007f00">How can I get Caps_Lock to work between my VNC viewer and **x11vnc**?</font>

This is a little tricky because it is possible to get the Caps_Lock state out of sync between your viewer-side machine and the x11vnc-side X server. For best results, we recommend not ever letting the Caps_Lock keypresses be processed by **x11vnc**. That way when you press Caps_Lock in the viewer your local machine goes into the Caps_Lock on state and sends keysym "A" say when you press "a". **x11vnc** will then fake things up so that Shift is held down to generate "A". The [-skip_lockkeys](x11vnc_opts.html#opt-skip_lockkeys) option should help to accomplish this. For finer grain control use something like: "[-remap](x11vnc_opts.html#opt-remap) Caps_Lock-None".

Also try the [-nomodtweak](x11vnc_opts.html#opt-nomodtweak) and [-capslock](x11vnc_opts.html#opt-capslock) options.

Another useful option that turns off any Lock keys on the remote side at startup and end is the [-clear_all](x11vnc_opts.html#opt-clear_all) option. During a session you can run these remote control commands to modify the Lock keys:

<pre>   x11vnc -R clear_locks
   x11vnc -R clear_all
</pre>

the former will try to unset any Lock keys, the latter will do same and also try to make it so no key is pressed down (e.g. "stuck" Alt_L, etc.) 
<font size="-0">**[Screen Related Issues and Features]**</font>
<a name="faq-scrollbars"></a><a name="FAQ-100"></a>

**Q-100:** <font color="#007f00">The remote display is larger (in number of pixels) than the local display I am running the **vncviewer** on. I don't like the **vncviewer** scrollbars, what I can do?</font>

**vncviewer** has a option (usually accessible via `F8` key or `-fullscreen` option) for **vncviewer** to run in full screen, where it will automatically scroll when the mouse is near the edge of the current view. For quick scrolling, also make sure Backing Store is enabled on the machine **vncviewer** is run on. (XFree86/Xorg disables it by default for some reason, add Option "backingstore" to XF86Config on the **vncviewer** side.)

BTW, contact me if you are having problems with **vncviewer** in fullscreen mode with your window manager (i.e. no keyboard response.) I have a workaround for **vncviewer** using `XGrabServer()`.

There may also be scaling viewers out there (e.g. TightVNC or UltraVNC on Windows) that automatically shrink or expand the remote framebuffer to fit the local display. Especially for hand-held devices. See also [the next FAQ on x11vnc scaling](#faq-scaling).

<a name="faq-scaling"></a><a name="FAQ-101"></a>

**Q-101:** <font color="#007f00">Does **x11vnc** support server-side framebuffer scaling? (E.g. to make the desktop smaller.)</font>

As of Jun/2004 **x11vnc** provides basic server-side scaling. It is a global scaling of the desktop, not a per-client setting. To enable it use the "[`-scale fraction`](x11vnc_opts.html#opt-scale)" option. "fraction" can either be a floating point number (e.g. `-scale 0.75`) or the alternative m/n fraction notation (e.g. `-scale 3/4`.) Note that if fraction is greater than one the display is magnified.

Extra resources (CPU, memory I/O, and memory) are required to do the scaling. If the machine is slow where **x11vnc** is run with scaling enabled, the interactive response can be unacceptable. OTOH, if run with scaling on a fast machine the performance degradation is usually not a big issue or even noticeable.

It may help to compile **x11vnc** with compiler option `-O3` or `-O4` to speed up the scaling code. Set the `CFLAGS` env. var. before running `configure`.

Also, if you just want a quick, rough "thumbnail" of the display you can append ":nb" to the fraction to turn on "no blending" mode. E.g.: "`-scale 1/3:nb`" Fonts will be difficult to read, but the larger features will be recognizable. BTW, "no blending" mode is forced on when scaling 8bpp PseudoColor displays (because blending an indexed colormap is a bad idea and leads to random colors, use `:fb` to force it on.)

One can also use the ":nb" with an integer scale factor (say "`-scale 2:nb`") to use **x11vnc** as a screen magnifier for vision impaired [applications](http://people.pwf.cam.ac.uk/ssb22/setup/vnc-magnification.html). Since with integer scale factors the framebuffers become huge and scaling operations time consuming, be sure to use ":nb" for the fastest response.

In general for a scaled display if you are using a TightVNC viewer you may want to turn off jpeg encoding (e.g. `vncviewer -nojpeg host:0`.) There appears to be a noise enhancement effect, especially for regions containing font/text: the scaling can introduce some pixel artifacts that evidently causes the tight encoding algorithm to incorrectly detect the regions as image data and thereby introduce additional pixel artifacts due to the lossiness of the jpeg compression algorithm. Experiment to see if `-nojpeg` vncviewer option improves the readability of text when using `-scale` to shrink the display size. Also note that scaling may actually slow down the transfer of text regions because after being scaled they do not compress as well. (this can often be a significant slowdown, e.g. 10X.)

Another issue is that it appears VNC viewers require the screen width to be a multiple of 4\. When scaling **x11vnc** will round the width to the nearest multiple of 4\. To disable this use the ":n4" sub option (like ":nb" in the previous paragraph; to specify both use a comma: ":nb,n4", etc.)

If one desires per-client scaling for something like 1:1 from a workstation and 1:2 from a smaller device (e.g. handheld), currently the only option is to run two (or more) **x11vnc** processes with different scalings listening on separate ports ([`-rfbport`](x11vnc_opts.html#opt-rfbport) option, etc.)

_**Update**_: As of May/2006 **x11vnc** also supports the UltraVNC server-side scaling. This is a per-client scaling by factors 1/2, 1/3, ... and so may be useful for PDA's ("`-scale 1/2`", etc. will give similar results except that it applies to all clients.) You may need to supply "`-rfbversion 3.6`" for this to be recognized by UltraVNC viewers.

<a name="infaq_multiple-x11vncs"></a>BTW, whenever you run two or more **x11vnc**'s on the same X display _and_ use the [GUI](x11vnc_opts.html#opt-gui), then to avoid all of the **x11vnc**'s simultaneously answering the gui you will need to use something like ["`-connect file1 -gui ...`"](x11vnc_opts.html#opt-connect) with different connect files for each **x11vnc** you want to control via the gui (or remote-control.) The "`-connect file1`" usage gives separate communication channels between a x11vnc process and the gui process. Otherwise they all share the same X property channels: `VNC_CONNECT` and `X11VNC_REMOTE`.

_**Update**_: As of Mar/2005 **x11vnc** now scales the mouse cursor with the same scale factor as the screen. If you don't want that, use the ["`-scale_cursor frac`"](x11vnc_opts.html#opt-scale_cursor) option to set the cursor scaling to a different factor (e.g. use "`-scale_cursor 1`" to keep the cursor at its natural unscaled size.)

<a name="faq-xinerama"></a><a name="FAQ-102"></a>

**Q-102:** <font color="#007f00">Does **x11vnc** work with Xinerama? (i.e. multiple monitors joined together to form one big, single screen.)</font>

Yes, it should generally work because it simply polls the big effective screen.

If the viewing-end monitor is not as big as the remote Xinerama display, then the **vncviewer** scrollbars, etc, will have to be used to pan across the large area. However one user started two **x11vnc**'s, one with "`-clip 1280x1024+0+0`" and the other with "`-clip 1280x1024+1280+0`" to split the big screen into two and used two VNC viewers to access them.

As of Jun/2008: Use "`-clip xinerama0`" to clip to the first xinerama sub-screen (if xinerama is active.) xinerama1 for the 2nd sub-screen, etc. This way you don't need to figure out the WxH+X+Y of the desired xinerama sub-screen. screens are sorted in increasing distance from the (0,0) origin (I.e. not the Xserver's order.)

There are a couple potential issues with Xinerama however. If the screen is not rectangular (e.g. 1280x1024 and 1024x768 monitors joined together), then there will be "non-existent" areas on the screen. The X server will return "garbage" image data for these areas and so they may be distracting to the viewer. The [`-blackout`](x11vnc_opts.html#opt-blackout) **x11vnc** option allows you to blacken-out rectangles by manually specifying their WxH+X+Y geometries. If your system has the `libXinerama` library, the [`-xinerama`](x11vnc_opts.html#opt-xinerama) **x11vnc** option can be used to have it automatically determine the rectangles to be blackened out. (Note on 8bpp PseudoColor displays the fill color may not be black.) _**Update**_: [`-xinerama`](x11vnc_opts.html#opt-xinerama) is now on by default.

Some users have reported that the mouse does not behave properly for their Xinerama display: i.e. the mouse cannot be moved to all regions of the large display. If this happens try using the [`-xwarppointer`](x11vnc_opts.html#opt-xwarppointer) option. This instructs **x11vnc** to fake mouse pointer motions using the `XWarpPointer` function instead of the `XTestFakeMotionEvent` XTEST function. (This may be due to a bug in the X server for XTEST when Xinerama is enabled.) _**Update**_: As of Dec/2006 [`-xwarppointer`](x11vnc_opts.html#opt-xwarppointer) will be applied automatically if Xinerama is detected. To disable use: `-noxwarppointer`

<a name="faq-multi-screen"></a><a name="FAQ-103"></a>

**Q-103:** <font color="#007f00">Can I use **x11vnc** on a multi-headed display that is not Xinerama (i.e. separate screens `:0.0`, `:0.1`, ... for each monitor)?</font>

You can, but it is a little bit awkward: you must start separate **x11vnc** processes for each screen, and on the viewing end start up separate VNC viewer processes connecting to them. e.g. on the remote end:

<pre>  x11vnc -display :0.0 -bg -q -rfbport 5900
  x11vnc -display :0.1 -bg -q -rfbport 5901
</pre>

(this could be automated in the display manager `Xsetup` for example) and then on the local machine where you are sitting:

<pre>  vncviewer somehost:0 &
  vncviewer somehost:1 &
</pre>

_**Update**:_ Since about 2009 (Xorg 7.4?) there appears to be a bug in the Xorg X server where the XTestFakeMotionEvent() interface ignores the screen argument passed to it. This makes it impossible to switch the mouse between the multiple screens via the vncviewers. A workaround for this Xorg bug is to call x11vnc with the [`-xwarppointer`](x11vnc_opts.html#opt-xwarppointer) option.

Note: if you are running on Solaris 8 or earlier you can easily hit up against the maximum of 6 shm segments per process (for `Xsun` in this case) from running multiple **x11vnc** processes. You should modify `/etc/system` as mentioned in another [FAQ](#faq-solshm) to increase the limit. It is probably also a good idea to run with the [`-onetile`](x11vnc_opts.html#opt-onetile) option in this case (to limit each **x11vnc** to 3 shm segments), or even [`-noshm`](x11vnc_opts.html#opt-noshm) to use no shm segments.

<a name="faq-clip-screen"></a><a name="FAQ-104"></a>

**Q-104:** <font color="#007f00">Can **x11vnc** show only a portion of the display? (E.g. for a special purpose application or a very large screen.)</font>

As of Mar/2005 **x11vnc** has the "[`-clip WxH+X+Y`](x11vnc_opts.html#opt-clip)" option to select a rectangle of width `W`, height `H` and offset `(X, Y)`. Thus the VNC screen will be the clipped sub-region of the display and be only `WxH` in size. One user used `-clip` to split up a large [Xinerama screen](#faq-xinerama) into two more managable smaller screens.

This also works to view a sub-region of a single application window if the [`-id`](x11vnc_opts.html#opt-id) or [`-sid`](x11vnc_opts.html#opt-id) options are used. The offset is measured from the upper left corner of the selected window.

<a name="faq-xrandr"></a><a name="FAQ-105"></a>

**Q-105:** <font color="#007f00">Does **x11vnc** support the XRANDR (X Resize, Rotate and Reflection) extension? Whenever I rotate or resize the screen **x11vnc** just seems to crash.</font>

As of Dec/2004 **x11vnc** supports XRANDR. You enable it with the [`-xrandr`](x11vnc_opts.html#opt-xrandr) option to make **x11vnc** monitor XRANDR events and also trap X server errors if the screen change occurred in the middle of an X call like `XGetImage`. Once it traps the screen change it will create a new framebuffer using the new screen.

If the connected vnc viewers support the NewFBSize VNC extension (Windows TightVNC viewer and RealVNC 4.0 windows and Unix viewers do) then the viewer will automatically resize. Otherwise, the new framebuffer is fit as best as possible into the original viewer size (portions of the screen may be clipped, unused, etc.) For these viewers you can try the [`-padgeom`](x11vnc_opts.html#opt-padgeom) option to make the region big enough to hold all resizes and rotations. We have fixed this problem for the TightVNC Viewer on Unix: [SSVNC](ssvnc.html)

If you specify "`-xrandr newfbsize`" then vnc viewers that do not support NewFBSize will be disconnected before the resize. If you specify "`-xrandr exit`" then all will be disconnected and **x11vnc** will terminate.

<a name="faq-rotate"></a><a name="FAQ-106"></a>

**Q-106:** <font color="#007f00">Independent of any XRANDR, can I have **x11vnc** rotate and/or reflect the screen that the VNC viewers see? (e.g. for a handheld whose screen is rotated 90 degrees.)</font>

As of Jul/2006 there is the [`-rotate`](x11vnc_opts.html#opt-rotate) option allow this. E.g's: "`-rotate +90`", "`-rotate -90`", "`-rotate x`", etc.

<a name="faq-black-screen"></a><a name="FAQ-107"></a>

**Q-107:** <font color="#007f00">Why is the view in my VNC viewer completely black? Or why is everything flashing around randomly?</font>

See the next FAQ for a possible explanation.

<a name="faq-linuxvc"></a><a name="FAQ-108"></a>

**Q-108:** <font color="#007f00">I use Linux **Virtual Terminals** (VT's) to implement 'Fast User Switching' between users' sessions (e.g. Betty is on `Ctrl-Alt-F7`, Bobby is on `Ctrl-Alt-F8`, and Sid is on `Ctrl-Alt-F1`: they use those keystrokes to switch between their sessions.)   How come the view in a VNC viewer connecting to **x11vnc** is either completely black, doesn't update, or pixels messed up unless the X session **x11vnc** is attached to is in **the active VT**?</font>

This seems to have to do with how applications (the X server processes in this case) must "play nicely" if they are not on the active VT (sometimes called VC for virtual console.) That is, they should not read from the keyboard or mouse or manage the video display unless they have the active VT. Given that it appears the `XGetImage()` call must ultimately retrieve the framebuffer data from the video hardware itself, it would make sense **x11vnc**'s polling wouldn't work unless the X session had active control of the VT.

There does not seem to be an easy way to work around this. Even `xwd(1)` doesn't work in this case (try it.) Something would need to be done at a lower level, say in the XFree86/Xorg X server. Also, using the Shadow Framebuffer (a copy of the video framebuffer is kept in main memory) does not appear to fix the problem (last checked 2007.)

If no one is sitting at the workstation and you just want to remotely switch the VT over to the one associated with your X session (so **x11vnc** can poll it correctly), one can use the `chvt(1)` command, e.g. "`chvt 7`" for VT #7.

<a name="faq-hidden-taskbars"></a><a name="FAQ-109"></a>

**Q-109:** <font color="#007f00">I am using **x11vnc** where my local machine has "popup/hidden taskbars" and the remote display where **x11vnc** runs also has "popup/hidden taskbars" and they interfere and fight with each other. What can I do?</font>

When you move the mouse to the edge of the screen where the popups happen, the taskbars interfere with each other in strange ways. This sometimes happens where the local machine is GNOME or Mac OS X and the remote machine is GNOME. Is there a way to temporarily disable one or both of these magic desktop taskbars?

One **x11vnc** user suggests: it should be straightforward to right mouse click on the task bar panel, and uncheck "enable auto-hide" from the panel properties dialog box. This will make the panel always visible.

<a name="faq-kde-screensaver"></a><a name="FAQ-110"></a>

**Q-110:** <font color="#007f00">Help! **x11vnc** and my KDE screensaver keep switching each other on and off every few seconds.</font>

This is a new (Jul/2006) problem seen, say, on the version of KDE that is shipped with SuSE 10.1\. It is not yet clear what is causing this... If you move the mouse through **x11vnc** the screensaver shuts off like it should but then a second or two after you stop moving the mouse the screensaver snaps back on.

This may be a bug in `kdesktop_lock`. For now the only workaround is to disable the screensaver. You can try using another one such as straight `xscreensaver` (see the instructions [here](http://www.jwz.org/xscreensaver/man1.html) for how to disable `kdesktop_lock`.) If you have more info on this or see it outside of KDE please let us know.

_**Update**:_ It appears this is due to `kdesktop_lock` enabling the screen saver when the Monitor is in DPMS low-power state (e.g. standby, suspend, or off.) In Nov/2006 the **x11vnc** [`-nodpms`](x11vnc_opts.html#opt-nodpms) option was added as a workaround. Normally it is a good thing that the monitor powers down (since **x11vnc** can still poll the framebuffer in this state), but if you experience the `kdesktop_lock` problem you can specify the "`-nodpms`" option to keep the Monitor out of low power state while VNC clients are connected. This is basically the same as typing "`xset dpms force on`" periodically. (if you don't want to do these things just disable the screensaver.) Feel free to file a bug against `kdesktop_lock` with KDE.

<a name="faq-beryl"></a><a name="FAQ-111"></a>

**Q-111:** <font color="#007f00">I am running the compiz 3D window manager (or beryl, MythTv, Google Earth, or some other OpenGL app) and I do not get screen updates in **x11vnc**.</font>

This appears to be because the 3D OpenGL/GLX hardware screen updates do not get reported via the XDAMAGE mechanism. So this is a bug in compiz/beryl or XDAMAGE/Xorg or the (possibly 3rd party) video card driver.

As a workaround apply the [`-noxdamage`](x11vnc_opts.html#opt-noxdamage) option. As of Feb/2007 **x11vnc** will try to autodetect the problem and disable XDAMAGE if is appears to be missing a lot of updates. But if you know you are using compiz you might as well always supply `-noxdamage`. Thanks to [this user](http://www.dslinux.org/blogs/pepsiman/?p=73) who reported the problem and discovered the workaround.

A developer for [MiniMyth](http://minimyth.org/) reports that the 'alphapulse' tag of the theme G.A.N.T. can also cause problems, and should be avoided when using VNC.

Please report a bug or complaint to Beryl/Compiz and/or Xorg about this: running x11vnc with `-noxdamage` disables a nice improvement in responsiveness (especially for typing) and also leads to unnecessary CPU and memory I/O load due to the extra polling.

_**Update**:_ as of May/2010 NVIDIA may have fixed this problem in their proprietary drivers. See the [NVIDIA Release Notes.](http://www.nvnews.net/vbulletin/showthread.php?t=151186) (look for 'x11vnc'.)

<a name="faq-vmware"></a><a name="FAQ-112"></a>

**Q-112:** <font color="#007f00">Can I use **x11vnc** to view my VMWare session remotely?</font>

Yes, since VMWare usually runs as an X application you can view it via **x11vnc** in the normal way.

Note that VMWare has several viewing modes:

*   Normal X application window  (with window manager frame)
*   Quick-Switch mode  (with no window manager frame)
*   Fullscreen mode

The way VMWare does Fullscreen mode on Linux is to display the Guest desktop in a separate Virtual Terminal (e.g. VT 8) (see [this FAQ on VT's](#faq-linuxvc) for background.) Unfortunately, this Fullscreen VT is not an X server. So **x11vnc** cannot access it (however, [see this discussion of `-rawfb`](#faq-rawfb) for a possible workaround.) **x11vnc** works fine with "Normal X application window" and "Quick-Switch mode" because these use X.

_**Update**:_ It appears the in VMWare 5.x the Fullscreen mode is X, so **x11vnc** access does work.

One user reports he left his machine with VMWare in the Fullscreen mode, and even though his X session wasn't in the active VT, he could still connect **x11vnc** to the X session and pass the keystrokes `Ctrl-Alt` (typing "blind") to the VMWare X app. This induced VMWare to switch out of Fullscreen into Normal X mode and he could continue working in the Guest desktop remotely.

_Aside:_ Sometimes it is convenient (for performance, etc.) to start VMWare in its own X session using `startx(1)`. This can be used to have a minimal window manger (e.g. `twm` or even no window manager), to improve response. One can also cut the display depth (e.g. to 16bpp) in this 2nd X session to improve video performance. This 2nd X session emulates Fullscreen mode to some degree and can be viewed via **x11vnc** as long as the VMWare X session [is in the active VT](#faq-linuxvc).

Also note that with a little bit of playing with "`xwininfo -all -children`" output one can extract the (non-toplevel) window-id of the of the Guest desktop only when VMWare is running as a normal X application. Then one can export just the guest desktop (i.e. without the VMWare menu buttons) by use of the [`-id windowid`](x11vnc_opts.html#opt-id) option. The caveats are the X session VMWare is in must be in the active VT and the window must be fully visible, so this mode is not terribly convenient, but could be useful in some circumstances (e.g. running VMWare on a very powerful server machine in a server room that happens to have a video card, (but need not have a monitor, Keyboard or mouse).)

<font size="-0">**[Exporting non-X11 devices via VNC]**</font>
<a name="faq-rawfb"></a><a name="FAQ-113"></a>

**Q-113:** <font color="#007f00">Can non-X devices (e.g. a raw framebuffer) be viewed (and even controlled) via VNC with **x11vnc**?</font>

As of Apr/2005 there is support for this. Two options were added: "[`-rawfb string`](x11vnc_opts.html#opt-rawfb)" (to indicate the raw frame buffer device, file, etc. and its parameters) and "[`-pipeinput command`](x11vnc_opts.html#opt-pipeinput)" (to provide an external program that will inject or otherwise process mouse and keystroke input.) Some useful [`-pipeinput`](x11vnc_opts.html#opt-pipeinput) schemes, `VID`, `CONSOLE`, and `UINPUT`, have since been built into **x11vnc** for convenience.

This non-X mode for **x11vnc** is somewhat experimental because it is so removed in scope from the intended usage of the tool. Incomplete attempt is made to make all of the other options consistent with non-X framebuffer polling. So all of the X-related options (e.g. `-add_keysyms`, `-xkb`) are just ignored or may cause an error if used. Be careful applying such an option via remote control.

The format for the `-rawfb` string is:

     -rawfb <type>:<object>@<W>x<H>x<bpp>[-<BPL>][:<R>/<G>/<B>][+<offset>]


There are also some useful aliases (e.g. "`console`".) Some examples:

<pre>    -rawfb shm:210337933@800x600x32:ff/ff00/ff0000

    -rawfb map:/dev/fb0@1024x768x16

    -rawfb map:/tmp/Xvfb_screen0@640x480x8+3232

    -rawfb file:/tmp/my.pnm@250x200x24+37

    -rawfb file:/dev/urandom@128x128x8

    -rawfb snap:/dev/video0@320x240x24 -24to32

    -rawfb console

    -rawfb vt2

    -rawfb video

    -rawfb setup:mycmd.sh

</pre>

So the type can be "`shm`" for shared memory objects, and "`map`" or "`file`" for file objects. "`map`" uses `mmap(2)` to map the file into memory and is preferred over "`file`" (that uses the slower `lseek(2)` access method.) Only use `file` if `map` isn't working. BTW, "`mmap`" is an alias for "`map`" and if you do not supply a type and the file exists, `map` is assumed (see the -help output and below for some exceptions to this.) The "`snap:`" setting applies the [`-snapfb`](x11vnc_opts.html#opt-snapfb) option with "`file:`" type reading (this is useful for exporting webcams or TV tuner video; see [the next FAQ](#faq-video) for more info.)

Also, if the string is of the form "`setup:cmd`" then `cmd` is run and the first line of its output retrieved and used as the rawfb string. This allows initializing the device, determining WxHxB, etc.

The object will be the numerical shared memory id for the case of `shm`. The idea here is some other program has created this shared memory segment and periodically updates it with new framebuffer data. **x11vnc** polls the area for changes. See `shmat(2)` and `ipcs(8)` for more info. The `ipcs` command will list current shared memory segments on the system. Sometimes you can snoop on a program's framebuffer it did not expect you would be polling!

The object will be the path to the regular or character special file for the cases of `map` and `file`. The idea here is that in the case of a regular file some other program is writing/updating framebuffer image data to it. In the case of a character special (e.g. `/dev/fb0`) it is the kernel that is "updating" the framebuffer data.

In most cases **x11vnc** needs to be told the width, height, and number of bits per pixel (bpp) of the framebuffer. This is the `@WxHxB` field. For the case of the Linux framebuffer device, `/dev/fb0`, the `fbset(8)` may be of use (but may not always be accurate for what is currently viewable.) In general some guessing may be required, especially for the bpp. _**Update**:_ in "`-rawfb console`" mode **x11vnc** will use the linuxfb API to try to guess (it is still not always accurate.) Also try "`-rawfb vtN`" (on x11vnc 0.9.7 and later) for the N-th Linux text console (aka virtual terminal.) If the number of Bytes Per Line is not WxHxB/8 (i.e. the framebuffer lines are padded) you can specify this information after WxHxB via "-BPL", e.g. @800x600x16-2048

Based on the bpp **x11vnc** will try to guess the red, green, and blue masks (these indicate which bits correspond to each color.) It if gets it wrong you can specify them manually via the optional "`:R/G/B`" field. E.g. "`:0xff0000/0x00ff00/0x0000ff`" (this is the default for 32bpp.)

Finally, the framebuffer may not begin at the beginning of the memory object, so use the optional "`+offset`" parameter to indicate where the framebuffer information starts. So as an example, the `Xvfb` virtual framebuffer has options `-shmem` and `-fbdir` for exporting its virtual screen to either shm or a mapped file. The format of these is XWD and so the initial header should be skipped. BTW, since XWD is not strictly RGB the view will only be approximate, but usable. Of course for the case of `Xvfb` **x11vnc** can poll it much better via the [X API](#faq-xvfb), but you get the idea.

By default in `-rawfb` mode **x11vnc** will actually _close_ any X display it happened to open. This is basically to shake out bugs (e.g it will crash rather than mysteriously interacting with the X display.) If you want **x11vnc** to keep the X display open while polling the raw framebuffer prefix a "+" sign at the beginning of the string (e.g. `+file:/dev/urandom@64x64x8`) This could be convenient for keeping the remote control channel active (it uses X properties.) The "`-connect /path/to/file`" mechanism could also be used for remote control to avoid the X property channel. Rare usage, but if you also supply `-noviewonly` in this "+" mode then the mouse and keyboard input are still sent to the X display, presumably for doing something amusing with `/dev/fb`...

_Interesting Devices:_. Here are some aliases for interesting device files that can be polled via `-rawfb`:

<pre>   -rawfb console               /dev/fb0        Linux Console
   -rawfb vt2                   /dev/vcsa2      Linux Console (e.g. virtual terminal #2)
   -rawfb video                 /dev/video0     Video4Linux Capture device
   -rawfb rand                  /dev/urandom    Random Bytes
   -rawfb null                  /dev/zero       Zero Bytes (black screen)
</pre>

The Linux console, `/dev/fb0`, etc needs to have its driver enabled in the kernel. Some of the drivers are video card specific and accelerated. The console is either the Text consoles (usually `tty1-tty6`), or X graphical display (usually starting at `tty7`.) In addition to the text console other graphical ones may be viewed and interacted with as well, e.g. DirectFB or SVGAlib apps, VMWare non-X fullscreen, or [Qt-embedded](#faq-qt-embedded) apps (PDAs/Handhelds.) By default the pipeinput mechanisms `UINPUT` and `CONSOLE` (keystrokes only) are automatically attempted in this mode under "`-rawfb console`".

The Video4Linux Capture device, `/dev/video0`, etc is either a Webcam or a TV capture device and needs to have its driver enabled in the kernel. See [this FAQ](#faq-video) for details. If specified via "`-rawfb Video`" then the pipeinput method "`VID`" is applied (it lets you change video parameters dynamically via keystrokes.)

The last two, `/dev/urandom` and `/dev/zero` are just for fun, but are also useful in testing.

All of the above [`-rawfb`](x11vnc_opts.html#opt-rawfb) options are just for viewing the raw framebuffer (although some of the aliases do imply keystroke and mouse pipeinput methods.) That may be enough for certain applications of this feature (e.g. suppose a [video camera](#faq-video) mapped its framebuffer into memory and you just wanted to look at it via VNC.)

To handle the pointer and keyboard input from the viewer users the "`-pipeinput cmd`" option was added to indicate a helper program to process the user input. The input is streamed to it and looks something like this:

<pre>   Pointer 1 205 257 0 None
   Pointer 1 198 253 0 None
   Pointer 1 198 253 1 ButtonPress-1
   Pointer 1 198 253 0 ButtonRelease-1
   Pointer 1 198 252 0 None
   Keysym 1 1 119 w KeyPress
   Keysym 1 0 119 w KeyRelease
   Keysym 1 1 65288 BackSpace KeyPress
   Keysym 1 0 65288 BackSpace KeyRelease
   Keysym 1 1 112 p KeyPress
   Keysym 1 0 112 p KeyRelease
</pre>

Run "`-pipeinput tee:/bin/cat`" to get a description of the format. Note that the `-pipeinput` option is independent of `-rawfb` mode and so may have some other interesting uses. The "`tee:`" prefix means **x11vnc** will both process the user input and pipe it to the command. The default is to just pipe it to the `-pipeinput` command.

Note the `-pipeinput` helper program could actually control the raw framebuffer. In the libvncserver CVS a simple example program `x11vnc/misc/slide.pl` is provided that demonstrates a simple jpeg "slideshow" application. Also the builtin "`-pipeinput VID`" mode does this for webcams and TV capture devices (`/dev/video0`.)

The `-pipeinput` program is run with these environment variables set: `X11VNC_PID`, `X11VNC_PROG`, `X11VNC_CMDLINE`, `X11VNC_RAWFB_STR` to aid its knowing what is up.

Another example provided in libvncserver CVS is a script to inject keystrokes into the Linux console (e.g. the virtual consoles: `/dev/tty1`, `/dev/tty2`, etc) in `x11vnc/misc/vcinject.pl`. It is based on the `vncterm/LinuxVNC.c` program also in the libvncserver CVS. So to view and interact with VT #2 (assuming it is the [active VT](#faq-linuxvc)) one can run something like:

<pre>  x11vnc -rawfb map:/dev/fb0@1024x768x16 -pipeinput './vcinject.pl 2'
</pre>

This assumes your Linux framebuffer device (`/dev/fb0`) is properly configured. See `fbset(8)` and other documentation. Try "`file:/dev/fb0@WxHxB`" as a last resort. Starting with **x11vnc** 0.8.1, the above VT injection is built in, as well as WxHxB determination. Just use something like:

<pre>  x11vnc -rawfb console
</pre>

this will try to guess the active virtual console (via `/dev/tty0`) and also the `/dev/fb0` WxHxB and rgb masks automatically. Use, e.g., "`-rawfb console3`" to force the VT number. This input method can be used generally via "`-pipeinput CONSOLE`". Also starting with **x11vnc** 0.8.2 the "`-pipeinput UINPUT`" mode is tried first (it does both keyboard and mouse input) and then falls back to `CONSOLE` mode if it is not available. Here is the -help output for this mode:

> If the rawfb string begins with "console" the framebuffer device /dev/fb0 is opened (this requires the appropriate kernel modules to be installed) and so is /dev/tty0. The latter is used to inject keystrokes (not all are supported, but the basic ones are.) You will need to be root to inject keystrokes. /dev/tty0 refers to the active VT, to indicate one explicitly, use "console2", etc. using the VT number.
> 
> If the Linux version seems to be 2.6 or later and the "uinput" module appears to be present, then the uinput method will be used instead of /dev/ttyN. uinput allows insertion of BOTH keystrokes and mouse input and so it preferred when accessing graphical (e.g. Qt-embedded) linux console apps. See -pipeinput UINPUT below for more information on this mode (you may want to also use the -nodragging and -cursor none options.) Use "console0", etc or -pipeinput CONSOLE to force the /dev/ttyN method.
> 
> Note you can change VT remotely using the chvt(1) command. Sometimes switching out and back corrects the framebuffer state.
> 
> To skip input injecting entirely use "consolex".
> 
> The string "/dev/fb0" (1, etc) can be used instead of "console". This can be used to specify a different framebuffer device, e.g. /dev/fb1\. As a shortcut the "/dev/" can be dropped. If the name is something nonstandard, use "console:/dev/foofb"
> 
> If you do not want x11vnc to guess the framebuffer's WxHxB and masks automatically (sometimes the kernel gives inaccurate information), specify them with a @WxHxB at the end of the string.

The above is just an example of what can be done. Note that if you really want to view and interact with the Linux Text console it is better to use the more accurate and faster `LinuxVNC` program. The advantage `x11vnc -rawfb` might have is that it can allow interaction with a non-text application, e.g. one based on SVGAlib or [Qt-embedded](#faq-qt-embedded) Also, for example the [VMWare Fullscreen mode](#faq-vmware) is actually viewable under `-rawfb` and can be interacted with if `uinput` is enabled.

If the Linux `uinput` driver is available then full keystroke and mouse input into the Linux console can be performed. You may be able to enable `uinput` via commands like these:

<pre>  modprobe uinput
  mknod /dev/input/uinput c 10 223
</pre>

The `-rawfb` and `-pipeinput` features are intended to help one creatively "get out of a jam" (say on a legacy or embedded device) where X is absent or doesn't work properly. Feedback and bug reports are welcome. For more control and less overhead use `libvncserver` in your own C program that passes the framebuffer to libvncserver.

<a name="faq-linux-vt"></a><a name="FAQ-114"></a>

**Q-114:** <font color="#007f00">Can I export the Linux Console (Virtual Terminals) via VNC using **x11vnc**?</font>

Yes, you may need to be root to access the devices that make up the linux console.

To access the active Linux console via the computer's framebuffer try something like:

<pre>  x11vnc -rawfb console
  x11vnc -rawfb console2
</pre>

These will try to access the framebuffer through `/dev/fb` (or `/dev/fb0`, etc.) and if it succeeds it will show any text or graphics that is currently displayed. Keystrokes will be injected via the device `/dev/tty0` (to force an explicit virtual terminal append a number, e.g. "`console2`" to select `/dev/tty2`.)

If your Linux system does not have a framebuffer device (`/dev/fb`) you can get one by adding, e.g., `vga=0x31B` boot parameter. This enables the VGA framebuffer device at 1280x1024x24\. 0x317 gives 1024x768x16, etc. You can also enable a Linux framebuffer device by modprobing a framebuffer driver specific to your video card.

Note that this "`-rawfb console`" mode shows the contents of the hardware framebuffer, and so will show whatever is on the screen. It has no concept of Virtual Terminals WRT what there is to view, it always shows the active virtual terminal.

Another mode is specific to the Linux text Virtual Terminals, it shows their text and colors (but no graphics) regardless of whether it is the active VT or not. It is available on **x11vnc** 0.9.7 and later. Enable this mode like this:

<pre>  x11vnc -rawfb vt
  x11vnc -rawfb vt2
</pre>

The former will select the active one, the latter the 2nd VT. **x11vnc** implements this mode by opening the current console text file "`/dev/vcsa2`" instead of "`/dev/fb`". In this way it provides the basic functionality of the LibVNCServer `LinuxVNC` program.

The `vt` mode can be a useful way to try to get a machine's X server working remotely, e.g. you edit `/etc/X11/xorg.conf` and then type `startx` (or similar, e.g. gdm) in the virtual terminal. A 2nd x11vnc could be used to see if the X server is now working correctly.

<a name="faq-video"></a><a name="FAQ-115"></a>

**Q-115:** <font color="#007f00">Can I export via VNC a Webcam or TV tuner framebuffer using **x11vnc**?</font>

Yes, this is possible to some degree with the [`-rawfb`](x11vnc_opts.html#opt-rawfb) option. There is no X11 involved: snapshots from the video capture device are used for the screen image data. See the [previous FAQ on -rawfb](#faq-rawfb) for background. For best results, use **x11vnc** version 0.8.1 or later.

Roughly, one would do something like this:

<pre>  x11vnc -rawfb snap:/dev/video@320x240x32
</pre>

This requires that the system allows simple `read(2)` access to the video device. This is true for video4Linux on Linux kernel 2.6 and later (it won't work for 2.4, you'll need a separate program to snapshot to a file that you point `-rawfb` to; ask me if it is not clear what to do.)

The "snap:" enforces [`-snapfb`](x11vnc_opts.html#opt-snapfb) mode which appears to be necessary. The read pointer for video capture devices cannot be repositioned (which would be needed for scanline polling), but you can read a full frame of data from the device.

On Linux, if the Video4Linux API is present or the `v4l-info(1)` program (related to `xawtv`) exists in in `PATH`, then **x11vnc** can be instructed to try it to determine the `-rawfb` WxHxB parameters for you automatically. In this case one would just type:

<pre>  x11vnc -rawfb video
</pre>

or "`-rawfb video1`" for the 2nd video device, etc.

**x11vnc** has also been extended to use the Video4Linux API over `v4l-info` if it is available at build time. This enables setting parameters (e.g. size and brightness) via **x11vnc**. See the description below. Without Video4Linux you will need to initialize the settings of the video device using something like `xawtv` or `spcaview` (and then hope the settings persist until **x11vnc** reopens the device.)

Many video4linux drivers tend to set the framebuffer to be 24bpp (as opposed to 32bpp.) Since this can cause problems with VNC viewers, etc, the [`-24to32`](x11vnc_opts.html#opt-24to32) option will be automatically imposed when in 24bpp.

Note that by its very nature, video capture involves rapid change in the framebuffer. This is especially true for cameras where slight wavering in brightness is always happening. This can lead to much network bandwidth consumption for the VNC traffic and also local CPU and I/O resource usage. You may want to experiment with "dialing down" the framerate via the [`-wait`](x11vnc_opts.html#opt-wait), [`-slow_fb`](x11vnc_opts.html#opt-slow_fb), or [`-defer`](x11vnc_opts.html#opt-defer) options. Decreasing the window size and bpp also helps.

_Setting Camera/Tuner parameters via **x11vnc**_:

There is also some support for setting parameters of the capture device. This is done via "`-rawfb video:<settings>`". This could be useful for unattended startup at boottime, etc. Here is the -help description:

> A more sophisticated video device scheme allows initializing the device's settings using:
> 
> <pre>           -rawfb video:<settings>
> </pre>
> 
> The prefix could also be, as above, e.g. "video1:" to specify the device file. The v4l API must be available for this to work. Otherwise, you will need to try to initialize the device with an external program, e.g. xawtv, spcaview, and hope they persist when x11vnc re-opens the device.
> 
> <settings> is a comma separated list of key=value pairs. The device's brightness, color, contrast, and hue can be set to percentages, e.g. br=80,co=50,cn=44,hu=60.
> 
> The device filename can be set too if needed (if it does not start with "video"), e.g. fn=/dev/qcam.
> 
> The width, height and bpp of the framebuffer can be set via, e.g., w=160,h=120,bpp=16.
> 
> Related to the bpp above, the pixel format can be set via the fmt=XXX, where XXX can be one of: GREY, HI240, RGB555, RGB565, RGB24, and RGB32 (with bpp 8, 8, 16, 16, 24, and 32 respectively.) See http://www.linuxtv.org for more info (V4L api.)
> 
> For TV/rf tuner cards one can set the tuning mode via tun=XXX where XXX can be one of PAL, NTSC, SECAM, or AUTO.
> 
> One can switch the input channel by the inp=XXX setting, where XXX is the name of the input channel (Television, Composite1, S-Video, etc.) Use the name that is in the information about the device that is printed at startup.
> 
> For input channels with tuners (e.g. Television) one can change which station is selected by the sta=XXX setting. XXX is the station number. Currently only the ntsc-cable-us (US cable) channels are built into x11vnc. See the -freqtab option below to supply one from xawtv. If XXX is greater than 500, then it is interpreted as a raw frequency in KHz.
> 
> Example:
> 
> -rawfb video:br=80,w=320,h=240,fmt=RGB32,tun=NTSC,sta=47
> 
> one might need to add inp=Television too for the input channel to be TV if the card doesn't come up by default in that one.
> 
> Note that not all video capture devices will support all of the above settings.
> 
> See the -pipeinput VID option below for a way to control the settings through the VNC Viewer via keystrokes.
> 
> As above, if you specify a "@WxHxB..." after the <settings> string they are used verbatim: the device is not queried for the current values. Otherwise the device will be queried.

Also, if you supply the "`-pipeinput VID`" (or use "`-rawfb Video`") option you can control the settings to some degree via keystroke mappings, e.g. B to increase the brightness or Up arrow to change the TV station:

> For "-pipeinput VID" and you are using the -rawfb for a video capture device, then an internal list of keyboard mappings is used to set parameters of the video. The mappings are:
> 
>     "B" and "b" adjust the brightness up and down.
>     "H" and "h" adjust the hue.
>     "C" and "c" adjust the colour.
>     "N" and "n" adjust the contrast.
>     "S" and "s" adjust the size of the capture screen.
>     "I" and "i" cycle through input channels.
>     Up and Down arrows adjust the station (if a tuner)
>     F1, F2, ..., F6 will switch the video capture pixel
>     format to HI240, RGB565, RGB24, RGB32, RGB555, and
>     GREY respectively. See -rawfb video for details.

See also the [`-freqtab`](x11vnc_opts.html#opt-freqtab) option to supply your own xawtv channel to frequency mappings for your country (only ntsc-cable-us is built into x11vnc.)<a name="faq-qt-embedded"></a><a name="FAQ-116"></a>

**Q-116:** <font color="#007f00">Can I connect via VNC to a Qt-embedded/Qt-enhanced/Qtopia application running on my handheld, cell phone, or PC using the Linux console framebuffer (i.e. not X11)?</font>

Yes, the basic method for this is the [-rawfb](#faq-rawfb) scheme where the Linux console framebuffer (usually `/dev/fb0`) is polled and the `uinput` driver is used to inject keystrokes and mouse input. Often you will just have to type:

<pre>  x11vnc -rawfb console
</pre>

(you may need to enable the `uinput` driver on the system via "`modprobe uinput; mknod /dev/input/uinput c 10 223`") If this does not find the correct frame buffer properties figure them out or guess them and use something like:

<pre>  x11vnc -rawfb /dev/fb0@640x480x16
</pre>

Also, to force usage of the `uinput` injection method use "`-pipeinput UINPUT`". See the [`-pipeinput`](x11vnc_opts.html#opt-pipeinput) description for tunable parameters, etc.

One problem with the **x11vnc** `uinput` scheme is that it cannot guess the mouse motion "acceleration" used by the windowing application (e.g. QWS or X11.) For X11 and Qt-embedded the acceleration is usually 2 (i.e. a dx of 1 from the mouse yields a 2 pixel displacement of the mouse cursor.) The default **x11vnc** uses is 2, since that is often used. However for one Qt-embedded system we needed to do:

<pre>  x11vnc -rawfb console  -pipeinput UINPUT:accel=4.0
</pre>

to get reasonable positioning of the mouse.

Even with the correct acceleration setting there is still some drift (probably because of the mouse threshold where the acceleration kicks in) and so **x11vnc** needs to reposition the cursor from 0,0 about 5 times a second. See the [`-pipeinput UINPUT`](x11vnc_opts.html#opt-pipeinput) option for tuning parameters that can be set (there are some experimental thresh=N tuning parameters as well)

Currently, one can expect mouse input to be a little flakey. All in all, the Linux framebuffer input mechanism for Qt-embedded framebuffer apps is not perfect, but it is usable.

If you need to create a smaller **x11vnc** binary for a handheld environment be sure to run `strip(1)` on it and also consider configuring with, e.g. "`env CPPFLAGS='-DSMALL_FOOTPRINT=1' ./configure ...`" to remove rarely used features and large texts (use 2 or 3 instead of 1 to remove more.) Currently (Jul/2006) this can lower the size of the **x11vnc** from 1.1MB to 0.6-0.7MB.

The **x11vnc** `uinput` method applies to nearly anything on the Linux framebuffer console, not just Qt-embedded/Qtopia. DirectFB, SDL using `fbcon` driver, SVGAlib applications can also be viewed and interacted with. Even a Linux X session can be viewed and interacted with without using X11 (and **x11vnc** does not have to terminate when the X server restarts!) The Linux Text consoles (F1-F6) also work.

Note that Qt-embedded supplies its own VNC graphics driver, but it cannot do _both_ the Linux console framebuffer and VNC at the same time, which is often what is desired from VNC.

_**Update**:_ We are finding some setups like Qtopia on the IPAQ do not allow mouse input via `uinput`. Please help us debug this problem by trying **x11vnc** on your device and letting us know what does and does not work. See the [next FAQ](#faq-qtmoko) for a possible workaround for touchscreens.

<a name="faq-qtmoko"></a><a name="FAQ-117"></a>

**Q-117:** <font color="#007f00">How do I inject touch screen input into an Qt-embedded/Qt-enhanced/Qtopia cell phone such as openmoko/qtmoko Neo Freerunner?</font>

The qtmoko project does not use X11 for the graphical display. Unfortunately the Linux uinput method described in the previous FAQ does not work because Qt is using TSLIB (touch screen library) to process the input and it only reads from one device (often `/dev/input/event1`) and **not** from the new UINPUT device that **x11vnc** creates (under `-pipeinput UINPUT`)

So something else needs to be done. It was discovered that by simply writing the touchscreen events _directly_ to `/dev/input/event1` then input can be injected into the system. There is no **x11vnc** builtin mode for this yet (until we understand it better), but there is a working script provided in `x11vnc/misc/qt_tslib_inject.pl`. So one could use it this way for example:

<pre>  x11vnc ... -rawfb console -pipeinput path/to/qt_tslib_inject.pl -env INJECT_OPTIONS=clickonly,cal=/etc/pointercal
</pre>

Read the script for how to enable other options and what the above options mean (e.g. `/etc/pointercal` contains TSLIB's calibration parameters and are necessary to achieve accurate pointing.)

The `x11vnc/misc/qt_tslib_inject.pl` script can potentially be modified to handle other devices where the uinput method fails. It could also be modified to create 'hot keys', etc.

Please let us know how things go if you try this out; there is much to learn about synthetic input injection in handhelds and cell phones. As we learn more we can develop a builtin **x11vnc** mode for this sort of injection.

_**Update Dec/2010**:_ There is experimental built-in UINPUT support in the x11vnc development tarball for qtmoko with touchpad managed by tslib. See [`-pipeinput UINPUT`](x11vnc_opts.html#opt-pipeinput) for more info. Here is an example:

<pre>   x11vnc -rawfb console -pipeinput UINPUT:touch,tslib_cal=/etc/pointercal,direct_abs=/dev/input/event1,nouinput,dragskip=3
</pre>

<a name="faq-no-x11"></a><a name="FAQ-118"></a>

**Q-118:** <font color="#007f00">Now that non-X11 devices can be exported via VNC using **x11vnc**, can I build it with no dependencies on X11 header files and libraries?</font>

Yes, as of Jul/2006 **x11vnc** enables building for [`-rawfb`](x11vnc_opts.html#opt-rawfb) only support. Just do something like when building:

<pre>  ./configure --without-x    (plus any other flags)
  make
</pre>

You can then test via "`ldd x11vnc`" that the binary does not depend on `libX11.so`, etc. See the previous FAQ's for non-X11 framebuffer usage. If you use this for an interesting non-X11 application please let us know what you did.<a name="faq-cross-compile"></a><a name="FAQ-119"></a>

**Q-119:** <font color="#007f00">How do I cross compile **x11vnc** for a different architecture than my Linux i386 or amd64 PC?</font>

You will need a cross-compiling toolchain. Perhaps your distro provides these or you can find a HOWTO for your distro. We found a nice one at qtmoko.org for building armel binaries on Debian Linux i386 machines. It includes most of the libraries that **x11vnc** needs. We use that example here.

We ran this script to set PATH, configure, and build:

<pre>#!/bin/sh

# toolchain from: qtmoko-debian-toolchain-armv4t-eabi.tar.gz

export PATH=/opt/toolchains/arm920t-eabi/bin:$PATH

env CC=arm-linux-gcc ./configure --host=arm-linux --without-avahi

make

arm-linux-strip ./x11vnc/x11vnc
ls -l ./x11vnc/x11vnc
</pre>

Note we had to include `--without-avahi` due to lack of `libavahi-client.so.3` supplied by the toolchain we used. One would need to add it if it was desired on the target machine. We also stripped the binary to make it smaller.

For an embedded system one may also want to add `--without-x` if the embedded system does not use X11 and the [`-rawfb`](x11vnc_opts.html#opt-rawfb) mechanism must be used.

<a name="faq-macosx"></a><a name="FAQ-120"></a>

**Q-120:** <font color="#007f00">Does **x11vnc** support Mac OS X Aqua/Quartz displays natively (i.e. no X11 involved)?</font>

Yes, since Nov/2006 in the development tree (x11vnc-0.8.4 tarball) there is support for native Mac OS X Aqua/Quartz displays using the [`-rawfb`](x11vnc_opts.html#opt-rawfb) mechanism described above. The mouse and keyboard input is achieved via Mac OS X API's.

So you can use **x11vnc** as an alternative to [OSXvnc](http://www.testplant.com/products/vine_server/OS_X) (aka Vine Server), or [Apple Remote Desktop (ARD)](http://www.apple.com/remotedesktop/). Perhaps there is some **x11vnc** feature you'd like to use on Mac OS X, etc. For a number of activities (e.g. window drags) it seems to be faster than OSXvnc.

**Notes:**

_X11:_  **x11vnc** will also work (as it has for years) with a X11 server (XDarwin) running on Mac OS X (people often install this software to display remote X11 apps on their Mac OS X system, or use some old favorites locally such as `xterm`.) However in this case **x11vnc** will only work reasonably in single window [`-id windowid`](x11vnc_opts.html#opt-id) mode (and the window may need to have mouse focus.)

If you do not have the `DISPLAY` env. variable set, **x11vnc** will assume native Aqua/Quartz on Mac OS X, however if `DISPLAY` is set it will assume an X11 connection. Use "`-rawfb console`" to force the native display (or unset `DISPLAY`.)

_Update:_ Leopard sets `DISPLAY` by default in all sessions. Since it starts with the string "`/tmp/`" **x11vnc** will use that to know if it should ignore it. Use "`-display :0.0`" to force it.

_Building:_  If you don't have the X11 build and runtime packages installed you will need to build it like this:

<pre>   (cd to the e.g. x11vnc-0.9, source directory)
   ./configure --without-x
   make
</pre>

_Win2VNC/x2vnc:_  One handy use is to use the [`-nofb`](x11vnc_opts.html#opt-nofb) mode to redirect mouse and keyboard input to a nearby Mac (i.e. one to the side of your desk) via [x2vnc](http://fredrik.hubbe.net/x2vnc.html) or Win2VNC. See [this FAQ](#faq-win2vnc) for more info.

_Options:_  Here are the Mac OS X specific **x11vnc** options:

<pre>   -macnodim              For the native Mac OS X server, disable dimming. 
   -macnosleep            For the native Mac OS X server, disable display sleep.
   -macnosaver            For the native Mac OS X server, disable screensaver.
   -macnowait             For the native Mac OS X server, do not wait for the
                          user to switch back to his display.
   -macwheel n            For the native Mac OS X server, set the mouse wheel
                          speed to n (default 5.)
   -macnoswap             For the native Mac OS X server, do not swap mouse
                          buttons 2 and 3.
   -macnoresize           For the native Mac OS X server, do not resize or reset
                          the framebuffer even if it is detected that the screen
                          resolution or depth has changed.
   -maciconanim n         For the native Mac OS X server, set n to the number
                          of milliseconds that the window iconify/deiconify
                          animation takes.  In -ncache mode this value will be
                          used to skip the animation if possible. (default 400)
   -macmenu               For the native Mac OS X server, in -ncache client-side
                          caching mode, try to cache pull down menus (not perfect
                          because they have animated fades, etc.)
</pre>

_PasteBoard/Clipboard:_   There is a bug that the Clipboard (called PasteBoard on Mac it appears) exchange will not take place unless **x11vnc** was started from **inside** the Aqua display (e.g. started inside a Terminal app window.) Otherwise it cannot connect to the PasteBoard server. So Clipboard exchange won't work for our standard "ssh in" startup scheme.

Hopefully this deficiency can be removed, but until then for Clipboard exchange to work you will need to start **x11vnc** inside the desktop session (i.e. either start it running before you leave, or start up a _2nd_ **x11vnc** inside from a _1st_ one started outside, or use the apple script below)

Here also is a `osascript` trick that seems to work (it opens the Terminal app and instructs it to start **x11vnc**):


	#!/bin/sh
	#
	# start_x11vnc: start x11vnc in a Terminal window
	# (this will allow Clipboard/Pasteboard exchange to work)

	tmp=/tmp/start_x11vnc.$

	cat > $tmp <<END

	tell application "Terminal"
		activate
		do script with command "$HOME/x11vnc -rfbauth .vnc/passwd -ssl SAVE"
	end tell

	END

	osascript $tmp
	rm -f $tmp



where you should customize the **x11vnc** command line to your needs and the full path to the binary. Save it in a file e.g. "`start_x11vnc`" and then after you SSH in just type "`./start_x11vnc`" (or have ssh run the command for you.) Then once you are connected via VNC, iconify the Terminal windows (you can't delete them since that will kill **x11vnc**.)

_**Update Aug/2010:**_ A user reports the following useful information:

<pre>This is not a problem on Mac OS X 10.6.x (Snow Leopard) when connecting
via ssh to start x11vnc.  And, on Mac OS X 10.5.x (Leopard), the problem
can be permanently eliminated by doing this:

sudo /usr/libexec/PlistBuddy -c 'delete :LimitLoadToSessionType' \
   -c 'add :LimitLoadToSessionType string Background' \
   /System/Library/LaunchAgents/com.apple.pboard.plist
# ignore any 'Delete: Entry, ":LimitLoadToSessionType", Does Not Exist' message

and then restarting (yes, you must restart not just log off).  But  
ONLY do that for Mac OS X 10.5.x and NOT for 10.6.x (which doesn't  
need it anyway).
</pre>

We recently got access to a MacOSX 10.6.4 (Snow Leopard) macbook and have confirmed that the above is correct.<a name="faq-reflect"></a><a name="FAQ-121"></a>

**Q-121:** <font color="#007f00">Can **x11vnc** be used as a VNC reflector/repeater to improve performance for the case of a large number of simultaneous VNC viewers (e.g. classroom broadcasting or a large demo)?</font>

Yes, as of Feb/2007 there is the "[`-reflect host:N`](x11vnc_opts.html#opt-reflect)" option to connect to the VNC server "`host:N`" (either another **x11vnc** or any other VNC server) and re-export it. VNC viewers then connect to the **x11vnc**(s) running `-reflect`.

The `-reflect` option is the same as: "`-rawfb vnc:host:N`". See the [`-rawfb`](x11vnc_opts.html#opt-rawfb) description under "VNC HOST" for more details.

You can replace "`host:N`" with "`listen`" or "`listen:port`" for reverse connections.

One can set up a number of such reflectors/repeaters to spread the resource usage around, e.g.:

<pre>       C -------<-------|                           
       C -------<-------|                           
       C -------<-------|---- R -----|                          
       C -------<-------|            |              
       C -------<-------|            |              
                                     |
       C -------<-------|            |              
       C -------<-------|            |              
       C -------<-------|---- R -----|                          
       C -------<-------|            |              
       C -------<-------|            |              
                                     |====== S 
       C -------<-------|            |
       C -------<-------|            |              
       C -------<-------|---- R -----|                          
       C -------<-------|            |              
       C -------<-------|            |              
                                     |
       C -------<-------|            |              
       C -------<-------|            |              
       C -------<-------|---- R -----|                          
       C -------<-------|                           
       C -------<-------|
</pre>

Where "S" is the original VNC Server, "C" denote VNC viewer clients, and "R" denotes an **x11vnc** running `-reflect` to "S".

Ideally, a client "C" will be fairly close network-wise to its "R". It is fine to run the "R" on the same machine as one of its "C's". A nice setup for a large, (e.g. 64-128) viewer classroom broadcast case would be to run R's on areas isolated by network switches, e.g. one R per switch.

In an extreme case (e.g. 1000 viewers) one might actually need a 2nd layer of R's in the tree. If you try something like that let us know!

There are many resource savings in doing something like the above. The first obvious one is network bandwidth savings. Another is less CPU load on "S" since it handles many fewer simultaneous connections. Also, if there are a few clients C on very slow links, their presence does not slow down every other client, just the clients on their "R". One way a slow client affects things is if there are some large framebuffer writes (e.g. jpeg image region) then the repeater may block waiting for that large write to finish before going onto the next client (however, if the write is small enough, the kernel will buffer it and the server can go on to service the next client.)

The **x11vnc** `-reflect` implementation uses the `libvncclient` library in the LibVNCServer project to handle the connection to "S". It is not currently very efficient since it simply does its normal framebuffer polling scheme on the `libvncclient` framebuffer (which it then re-exports via VNC to its clients C.) However, CopyRect and CursorShape encodings are preserved in the reflection and that helps. Dragging windows with the mouse can be a problem (especially if S is not doing wireframing somehow, consider [`-nodragging`](x11vnc_opts.html#opt-nodragging) if the problem is severe) For a really fast reflector/repeater it would have to be implemented from scratch with performance in mind. See these other projects:

<pre>    [http://sourceforge.net/projects/vnc-reflector/](http://sourceforge.net/projects/vnc-reflector/),
    [http://www.tightvnc.com/projector/](http://www.tightvnc.com/projector/)                (closed source?),
</pre>

_Automation via Reverse Connections:_   Instead of having the R's connect directly to S and then the C's connect directly to the R they should use, some convenience can be achieved by using reverse connections (the **x11vnc** "["`-connect host1,host2,...`"](x11vnc_opts.html#opt-connect) option.) Suppose all the clients "C" are started up in Listen mode:

<pre>    client1>  vncviewer -listen
    client2>  vncviewer -listen
    client3>  vncviewer -listen
    ...
    client64> vncviewer -listen
</pre>

(e.g. `client1>` is the cmdline prompt on machine `client1` ... etc) and all the repeaters R are started like this:

<pre>    repeater1> x11vnc -reflect listen -connect client1,client2,...client8
    repeater2> x11vnc -reflect listen -connect client9,client10,...client16
    ...
    repeater8> x11vnc -reflect listen -connect client57,client58,...client64
</pre>

and finally the main server is started to kick the whole thing into motion:

<pre>    vncserver> x11vnc -display :0 -connect repeater1,repeater2,...repeater8
</pre>

(or instruct a non-x11vnc VNC server to reverse connect to the repeaters.) For a classroom broadcasting setup one might have the first two sets of commands start automatically at bootup or when someone logs in, and then start everything up with the S server. One may even be able to script the forward connection bootstrap case, let us know what you did. A really nice thing would be some sort of auto-discovery of your repeater, etc...<a name="faq-os-install"></a><a name="FAQ-122"></a>

**Q-122:** <font color="#007f00">Can **x11vnc** be used during a Linux, Solaris, etc. system Installation so the Installation can be done remotely?</font>

This can be done, but it doesn't always work because it depends on how the OS does its install. We have to "sneak in" somehow. Note that some OS's have a remote install (ssh etc.) built in and so you might want to use that instead.

Usually the OS install will have to be a network-install in order to have networking up during the install. Otherwise, you may have a (slim) chance to configure the networking manually (`ifconfig(8)` and `route(8)`.)

To avoid library dependencies problems in the typical minimal (e.g. busybox) installation OS it is a good idea to build a statically linked **x11vnc** binary. A way that often works is to do a normal build and then paste the final **x11vnc** link line into a shell script. Then change the "`gcc`" to "`gcc -static`" and run the shell script. You may need to disable features (e.g. "`--without-xfixes`") if there is not a static library for the feature available. You may also need to add extra link options (e.g. "`-lXrender`") to complete library dependencies manually.

Let's call the binary `x11vnc.static`. Place it on a webserver somewhere. It may be possible to retrieve it via `scp(1)` too.

During the install you need to get a shell to retreive `x11vnc.static` and run it.

If the Solaris install is an older X-based one, there will be a menu for you to get a terminal window. From that window you might be able to retrieve `x11vnc.static` via `wget`, `scp`, or `ftp`. Remember to do "`chmod 755 ./x11vnc.static`" and then find the `-auth` file as in [this FAQ](#faq-display-manager).

If it is a Linux install that uses an X server (e.g. SuSE and probably Fedora), then you can often get a shell by pressing `Ctrl-Alt-F2` or similar. Then get the x11vnc binary via something like this:

<pre>   cd /tmp
   wget http://192.168.0.22/x11vnc.static
   chmod 755 ./x11vnc.static
</pre>

Find the name of the auth file as in [this FAQ](#faq-display-manager). (maybe run "`ps wwaux | grep auth`".) Then run it like this:

<pre>   ./x11vnc.static -forever -nopw -display :0 -auth /tmp/wherever/the/authfile
</pre>

then press `Alt-F7` to go back to the X install. You should now be able to connect via a vnc viewer and continue the install. Watch out for the display being :1, etc.

If there is a firewall blocking incoming connections during the install, use the ["`-connect hostname`"](x11vnc_opts.html#opt-connect) option option for a reverse connection to the hostname running the VNC viewer in listen mode.

Debian based installs are either console-text or console-framebuffer based. These are `install` (or `expert`) and `installgui` (or `expertgui`) boot lines, respectively. For the console-text based installs you probably need to add a boot cmd line option like `vga=0x314` (which is 800x600x16) to get the console-text to use the linux framebuffer device properly.

For a Debian console-text based install after the network is configured press `Ctrl-Alt-F2` to get a shell. Retrieve the binary via `wget` as above and `chmod 755` it. Then run it something like this:

<pre>   sleep 10; ./x11vnc.static -forever -nopw -rawfb console
</pre>

then before the sleep is over press `Alt-F1` to get back to the install virtual console. You should be able to connect via a VNC viewer and continue with the install.

For a recent (2009) Debian install we booted with "`expert vga=0x301`" and "`expert vga=0x311`" to get console text based installs at 640x480x8 and 640x480x16, respectively (replace "expert" with "install" if you like.) Otherwise it was giving a 16 color 640x480x4 (4 bit per pixel) display which x11vnc could not handle.

For Debian console-framebuffer GUI based installs (`installgui` or `expertgui`) we have not be able to enter keystrokes or mouse motions. This may be resolved if the install had the Linux kernel module `uinput`, but it doesn't; one can wget `uinput.ko` and then run `insmod` on it, but the module must match the installation kernel. So, failing that, you can only do the GUI view-only, which can be handy to watch a long network install from your desk instead of in front of the machine being installed. For these, after the network is configured press `Ctrl-Alt-F2` to get a shell. Retrieve the binary via `wget` as above and `chmod 755` it. Then run it something like this:

<pre>   sleep 10; ./x11vnc.static -forever -nopw -rawfb console
</pre>

then before the sleep is over press `Alt-F5` to get back to the GUI install console. You should be able to connect via a VNC viewer and watch the install. 
<font size="-0">**[Misc: Clipboard, File Transfer/Sharing, Printing, Sound, Beeps, Thanks, etc.]**</font>
<a name="faq-clipboard"></a><a name="FAQ-123"></a>

**Q-123:** <font color="#007f00">Does the Clipboard/Selection get transferred between the vncviewer and the X display?</font>

As of Jan/2004 **x11vnc** supports the "CutText" part of the RFB (aka VNC) protocol. When text is selected/copied in the X session that x11vnc is polling it will be sent to connected VNC viewers. And when CutText is received from a VNC viewer then x11vnc will set the X11 selections PRIMARY, CLIPBOARD, and CUTBUFFER0 to it. **x11vnc** is able to hold the PRIMARY and CLIPBOARD selections (**Xvnc** does not seem to do this.)

The X11 selections can be confusing, especially to those coming from Windows or MacOSX where there is just a single 'Clipboard'. The X11 CLIPBOARD selection is a lot like that of Windows and MacOSX, e.g. highlighted text is sent to the clipboard when the user activates "Edit -> Copy" or presses "Control+C" (and pasting it via "Edit -> Paste" or "Control+V".) The X11 PRIMARY selection has been described as 'for power users' or 'an Easter Egg'. As soon as text is highlighted it is set to the PRIMARY selection and so it is immediately ready for pasting, usually via the Middle Mouse Button or "Shift+Insert". See [this jwz link](http://www.jwz.org/doc/x-cut-and-paste.html) for more information.

**x11vnc**'s default behavior is to watch both CLIPBOARD and PRIMARY and whenever one of them changes, it sends the new text to connected viewers. Note that since the RFB protocol only has a single "CutText" then both selections are "merged" to some degree (and this can lead to confusing results.) One user was confused why x11vnc was "forgetting" his CLIPBOARD selection and the reason was he also changed PRIMARY _some time after_ he copied text to the clipboard. Usually an app will set PRIMARY as soon as any text is highlighted so it easy to see how CLIPBOARD was forgotten. Use the `-noprimary` described below as a workaround. Similarly, by default when x11vnc receives CutText it sets _both_ CLIPBOARD and PRIMARY to it (this is probably less confusing, but could possibly lead to some failure modes as well.)

You may not like these defaults. Here are ways to change the behavior:

*   If you don't want the Clipboard/Selection exchanged at all use the [`-nosel`](x11vnc_opts.html#opt-nosel) option.
*   If you want changes in PRIMARY to be ignored use the [`-noprimary`](x11vnc_opts.html#opt-noprimary) option.
*   If you want changes in CLIPBOARD to be ignored use the [`-noclipboard`](x11vnc_opts.html#opt-noclipboard) option.
*   If you don't want x11vnc to set PRIMARY to the "CutText" received from viewers use the [`-nosetprimary`](x11vnc_opts.html#opt-nosetprimary) option.
*   If you don't want x11vnc to set CLIPBOARD to the "CutText" received from viewers use the [`-nosetclipboard`](x11vnc_opts.html#opt-nosetclipboard) option.

You can also fine-tune it a bit with the [`-seldir dir`](x11vnc_opts.html#opt-seldir) option and also [`-input`](x11vnc_opts.html#opt-input).

You may need to watch out for desktop utilities such as KDE's "Klipper" that do odd things with the selection, clipboard, and cutbuffers.

<a name="faq-record-swf"></a><a name="FAQ-124"></a>

**Q-124:** <font color="#007f00">Can I use **x11vnc** to record a Shock Wave Flash (or other format) video of my desktop, e.g. to record a tutorial or demo?</font>

Yes, it is possible with a number of tools that record VNC and transform it to `swf` format or others. One such popular tool is [pyvnc2swf](http://www.unixuser.org/~euske/vnc2swf/). There are a number of [tutorials](http://wolphination.com/linux/2006/06/30/how-to-record-videos-of-your-desktop/) (broken link?) on how to do this. Another option is to use the `vnc2mpg` that comes in the LibVNCServer package.

An important thing to remember when doing this is that tuning parameters should be applied to **x11vnc** to speed up its polling for this sort of application, e.g. "`-wait 10 -defer 10`".<a name="faq-filexfer"></a><a name="FAQ-125"></a>

**Q-125:** <font color="#007f00">Can I transfer files back and forth with **x11vnc**?</font>

As of Oct/2005 and May/2006 **x11vnc** enables, respectively, the TightVNC and UltraVNC file transfer implementations that were added to libvncserver. This currently works with TightVNC and UltraVNC viewers (and Windows viewers only support filetransfer it appears... but they do work to some degree under Wine on Linux.)

The [SSVNC](ssvnc.html) Unix VNC viewer supports UltraVNC file transfer by use of a Java helper program.

TightVNC file transfer is off by default, if you want to enable it use the [`-tightfilexfer`](x11vnc_opts.html#opt-tightfilexfer) option.

UltraVNC file transfer is off by default, to enable it use something like "`-rfbversion 3.6 -permitfiletransfer`" options (UltraVNC incorrectly uses the RFB protocol version to determine if _its_ features are available, so **x11vnc** has to pretend to be version 3.6.) As of Sep/2006 "`-ultrafilexfer`" is an alias for these two options. Note that running as RFB version 3.6 may confuse other VNC Viewers.

Sadly you cannot do both `-tightfilexfer` and `-ultrafilexfer` at the same time because the latter requires setting the version to 3.6 and tightvnc will not do filetransfer when it sees that version number.

Also, because of the way the LibVNCServer TightVNC file transfer is implemented, you cannot do Tightvnc file transfer in `-unixpw` mode. However, UltraVNC file transfer does work in `-unixpw` (but if a client tries it do a filetransfer during the login process it will be disconnected.)

**IMPORTANT**: please understand if `-ultrafilexfer` or `-tightfilexfer` is specified and you run x11vnc as root for, say, inetd or display manager (gdm, kdm, ...) access and you do not have it switch users via the [`-users`](x11vnc_opts.html#opt-users) option, then VNC Viewers that connect are able to do filetransfer reads and writes as ***root***.

The UltraVNC and TightVNC settings can be toggled on and off inside the gui or by `-R` remote control. However for TightVNC the changed setting only applies for NEW clients, current clients retain their TightVNC file transfer ability. For UltraVNC it works better, however if an UltraVNC client has initiated a file transfer dialog it will remain in effect until the dialog is closed. If you want to switch between UltraVNC and TightVNC file transfer in the gui or by remote control you will probably be foiled by the "`-rfbversion 3.6`" issue.

<a name="faq-ultravnc"></a><a name="FAQ-126"></a>

**Q-126:** <font color="#007f00">Which UltraVNC extensions are supported?</font>

Some of them are supported. To get UltraVNC Viewers to attempt to use these extensions you will need to supply this option to **x11vnc**:

<pre>   -rfbversion 3.6
</pre>

Or use [`-ultrafilexfer`](x11vnc_opts.html#opt-ultrafilexfer) which is an alias for the above option and "`-permitfiletransfer`". UltraVNC evidently treats any other RFB version number as non-UltraVNC.

Here are a list of the UltraVNC extensions supported by **x11vnc**:

*   ServerInput: "Toggle Remote Input and Remote Blank Monitor"
*   FileTransfer: "Open File Transfer..."
*   SingleWindow: "Select Single Window..."
*   TextChat: "Open Chat..."
*   1/n Server Scaling

The [SSVNC](ssvnc.html) Unix VNC viewer supports these UltraVNC extensions.

To disable SingleWindow and ServerInput use [`-noultraext`](x11vnc_opts.html#opt-noultraext) (the others are managed by LibVNCServer.) See this option too: [`-noserverdpms`](x11vnc_opts.html#opt-noserverdpms).

Also, the [`UltraVNC repeater proxy`](http://www.uvnc.com/addons/repeater.html) is supported for use with reverse connections: "[`-connect repeater://host:port+ID:NNNN`](x11vnc_opts.html#opt-connect)". Use it for both plaintext and SSL connections. This mode can send any string before switching to the VNC protocol, and so could be used with other proxy/gateway tools. Also, a perl repeater implemention is here: [`ultravnc_repeater.pl`](ultravnc_repeater.pl)

<a name="faq-singleclick"></a><a name="FAQ-127"></a>

**Q-127:** <font color="#007f00">Can **x11vnc** emulate UltraVNC's Single Click helpdesk mode for Unix? I.e. something very simple for a naive user to initiate a reverse vnc connection from their Unix desktop to a helpdesk operator's VNC Viewer.</font>

Yes, UltraVNC's [Single Click (SC)](http://www.uvnc.com/addons/singleclick.html) mode can be emulated fairly well on Unix.

We use the term "helpdesk" below, but it could be any sort of remote assistance you want to set up, e.g. something for Unix-using friends or family to use. This includes [Mac OS X](#faq-macosx).

Assume you create a helpdesk directory "`hd`" on your website: `http://www.mysite.com/hd` (any website that you can upload files to should work, although remember the user will be running the programs you place there.)

In that "`hd`" subdirectory copy an **x11vnc** binary to be run on the Unix user's machine (e.g. Linux, etc) and also create a file named "`vnc`" containing the following:

<pre>#!/bin/sh

webhost="http://www.mysite.com/hd"  # Your helpdesk dir URL.

vnchost="ip.someplace.net"          # Your host running 'vncviewer -listen' 
                                    # It could also be your IP number. If it is
                                    # a router/firewall, you will need to 
                                    # configure it to redirect port 5500 to your
                                    # workstation running 'vncviewer -listen'

dir=/tmp/vnc_helpdesk.$            # Make a temporary working dir.
mkdir $dir || exit 1
cd $dir || exit 1

trap "cd /tmp; rm -rf $dir" 0 2 15  # Cleans up on exit.

wget $webhost/x11vnc                # Fetch x11vnc binary.  If multi-
chmod 755 ./x11vnc                  # platform, use $webhost/`uname`/x11vnc
                                    # or similar.

./x11vnc -connect_or_exit $vnchost -rfbport 0 -nopw
</pre>

with the hostnames / IP addresses customized to your case.

On the helpdesk VNC viewer machine (`ip.someplace.net` in this example) you have the helpdesk operator running VNC viewer in listen mode:

<pre>   vncviewer -listen
</pre>

or if on Windows, etc. somehow have the VNC viewer be in "listen" mode.

Then, when the naive user needs assistance you instruct him to open up a terminal window on his Unix desktop and paste the following into the shell:

<pre>   wget -qO - http://www.mysite.com/hd/vnc | sh -
</pre>

and then press Enter. You could have this instruction on a web page or in an email you send him, etc. This requires that the `wget` is installed on the user's Unix machine (he might only have `curl` or `lynx`, see below for more info.)

So I guess this is about 3-4 clicks (start a terminal and paste) and pressing "Enter" instead of "single click"...

See [this page](single-click.html) for some variations on this method, e.g. how to add a password, SSL Certificates, etc.

If you don't have a website (there are many free ones) or don't want to use one you will have to email him all of the ingredients (x11vnc binary and a launcher script) and tell him how to run it. This could be easy or challenging depending on the skill of the naive unix user...

A bit of obscurity security could be put in with a `-passwd`, `-rfbauth` options, etc. (note that **x11vnc** will require a password even for reverse connections.) More info [here](single-click.html).

**Firewalls:** If the helpdesk (you) with the vncviewer is behind a NAT/Firewall/Router the [router](index.html#firewalls) will have to be configured to redirect a port (i.e. 5500 or maybe different one if you like) to the vncviewer machine. If the vncviewer machine also has its own host-level firewall, you will have to open up the port there as well.

**NAT-2-NAT:** There is currently no way to go "NAT-2-NAT", i.e. both User and Helpdesk workstations behind NAT'ing Firewall/Routers without configuring a router to do a port redirection (i.e. on your side, the HelpDesk.) To avoid modifying either firewall/router, one would need some public (IP address reachable on the internet) redirection/proxy service. Perhaps such a thing exists. [http://sc.uvnc.com](http://sc.uvnc.com) provides this service for their UltraVNC Single Click users.

_Update:_ It may be possible to do "NAT-2-NAT" with a UDP tunnel such as [http://samy.pl/pwnat/](http://samy.pl/pwnat/). All that is required is that both NAT firewalls allow in UDP packets from an IP address to which a UDP packet has recently been sent to. If you try it out let us know how it went.

**_Very Naive Users:_**

If it is beyond the user how to open a terminal window and paste in a command (you have my condolences...) you would have to somehow setup his Web browser to download the "`vnc`" file (or a script containing the above `wget` line) and prompt the user if he wants to run it. This may be tricky to set up (which is probably a good thing to not have the web browser readily run arbitrary programs downloaded from the internet...)

One command-line free way, tested with KDE, is to name the file `vnc.sh` and then instruct the user to right-click on the link and do "Save Link As" to his Desktop. It will appear as an icon, probably one that looks like a terminal or a command line prompt. He next should right-click on the icon and select "Properties" and go to the "Permissions" tab. Then in that dialog select the checkbox "Is executable". He should then be able to click on the icon to launch it. Another option is to right-click on the icon and select "Open With -> Other ..." and for the name of the application type in "`/bin/sh`". Unfortunately in both cases the command output is lost and so errors cannot be debugged as easily. A similar thing appears to work in GNOME if under "Properties -> Permissions" they click on "Execute" checkbox for "Owner". Then when they click on the icon, they will get a dialog where they can select "Run in Terminal". In general for such cases, if it is feasible, it might be easier to `ssh` to his machine and set things up yourself...

**_SSL Encrypted Helpdesk Connections:_** 

As of Apr/2007 **x11vnc** supports reverse connections in SSL and so we can do this. On the Helpdesk side (Viewer) you will need STUNNEL or better use the [Enhanced TightVNC Viewer (SSVNC)](ssvnc.html) package we provide that automates all of the SSL for you.

To do this create a file named "`vncs`" in the website "`hd`" directory containing the following:

<pre>#!/bin/sh

webhost="http://www.mysite.com/hd"  # Your helpdesk dir URL.

vnchost="ip.someplace.net"          # Your host running 'vncviewer -listen' 
                                    # It could also be your IP number. If it is
                                    # a router/firewall, you will need to 
                                    # configure it to redirect port 5500 to your
                                    # workstation running 'vncviewer -listen'

dir=/tmp/vnc_helpdesk.$            # Make a temporary working dir.
mkdir $dir || exit 1
cd $dir || exit 1

trap "cd /tmp; rm -rf $dir" 0 2 15  # Cleans up on exit.

wget $webhost/x11vnc                # Fetch x11vnc binary.  If multi-
chmod 755 ./x11vnc                  # platform, use $webhost/`uname`/x11vnc
                                    # or similar.

./x11vnc -connect_or_exit $vnchost -rfbport 0 -nopw -ssl    # Note -ssl option.
</pre>

with the hostnames or IP addresses customized to your case.

The only change from the "`vnc`" above is the addition of the [`-ssl`](x11vnc_opts.html#opt-ssl) option to **x11vnc**. This will create a temporary SSL cert: `openssl(1)` will need to be installed on the user's end. A fixed SSL cert file could be used to avoid this (and provide some authentication; more info [here](single-click.html).)

The naive user will be doing this:

<pre>   wget -qO - http://www.mysite.com/hd/vncs | sh -
</pre>

(or perhaps even use https:// if available.)

But before that, the helpdesk operator needs to have "`vncviewer -listen`" running as before, however he needs an SSL tunnel at his end. The easiest way to do this is use [Enhanced TightVNC Viewer (SSVNC)](ssvnc.html). Start it, and select Options -> 'Reverse VNC Connection (-listen)'. Then **UN-**select 'Verify All Certs' (this can be enabled later if you want; you'll need the x11vnc SSL certificate), and click 'Listen'.

If you don't want to use SSVNC for the viewer, but rather set up STUNNEL manually instead, make a file "`stunnel.cfg`" containing:

<pre>foreground = yes
pid =

[vnc]
accept = 5500
connect = localhost:5501
</pre>

and run:

<pre>  stunnel ./stunnel.cfg
</pre>

and then start the "`vncviewer -listen 1`" (i.e. 1 to correspond to the 5501 port.) Note that this assumes the stunnel install created a Server SSL cert+key, usually `/etc/stunnel/stunnel.pem` (not all distros will do this.) Also, that file is by default only readable by root, so stunnel needs to be run as root. If your system does not have a key installed or you do not want to run stunnel as root (or change the permissions on the file), you can use **x11vnc** to create one for you for example:

<pre>  x11vnc -sslGenCert server self:mystunnel
</pre>

answer the prompts with whatever you want; you can take the default for all of them if you like. The `openssl(1)` package must be installed. See [this link](single-click.html) and [this one too](ssl.html) for more info on SSL certs. This creates `$HOME/.vnc/certs/server-self:mystunnel.pem`, then you would change the "`stunnel.cfg`" to look something like:

<pre>foreground = yes
pid =
cert = /home/myusername/.vnc/certs/server-self:mystunnel.pem

[vnc]
accept = 5500
connect = localhost:5501
</pre>

In any event, with stunnel having been setup, the naive user is instructed to paste in and run:

<pre>   wget -qO - http://www.mysite.com/hd/vncs | sh -
</pre>

to pick up the `vncs` script this time.

Of course if a man-in-the-middle can alter what the user **_downloads_** then all bets are off!.

More SSL variations and info about certificates can be found [here](single-click.html).

<a name="infaq_libssl-problems"></a> 
**_OpenSSL libssl.so.0.9.7 problems:_**

If you build your own stunnel or x11vnc for deployment, you may want to _statically link_ `libssl.a` and `libcrypto.a` into it because Linux distros are currently a bit of a mess regarding which version of `libssl` is installed.

You will find the [details here](single-click.html#libssl-problems).

<a name="faq-smb-shares"></a><a name="FAQ-128"></a>

**Q-128:** <font color="#007f00">Can I (temporarily) mount my local (viewer-side) Windows/Samba File share on the machine where **x11vnc** is running?</font>

You will have to use an external network redirection for this. Filesystem mounting is not part of the VNC protocol.

We show a simple **[Samba](http://www.samba.org/)** example here.

First you will need a tunnel to redirect the SMB requests from the remote machine to the one you sitting at. We use an `ssh` tunnel:

<pre>  sitting-here> ssh -C -R 1139:localhost:139 far-away.east
</pre>

Or one could combine this with the VNC tunnel at the same time, e.g.:

<pre>  sitting-here> ssh -C -R 1139:localhost:139 -t -L 5900:localhost:5900 far-away.east 'x11vnc -localhost -display :0'
</pre>

Port 139 is the Windows Service port. For Windows systems instead of Samba, you may need to use the actual IP address of the Window machine instead of "localhost" in the -R option (since the Windows service does not listen on localhost by default.)

Note that we use 1139 instead of 139 on the remote side because 139 would require root permission to listen on (and you may have a samba server running on it already.)

The ssh `-C` is to enable compression, which might speed up the data transfers.

Depending on the remote system side configuration, it may or may not be possible to mount the SMB share as a non-root user. Try it first as a non-root user and if that fails you will have to become root.

We will assume the user name is "fred" and we will try to mount the viewer-side Windows SMB share "`//haystack/pub`" in `/home/fred/smb-haystack-pub`.

<pre>  far-away> mkdir -p /home/fred/smb-haystack-pub
  far-away> smbmount //haystack/pub /home/fred/smb-haystack-pub -o username=fred,ip=127.0.0.1,port=1139
</pre>

(The 2nd command may need to be run as root.) Then run "`df`" or "`ls -l /home/fred/smb-haystack-pub`" to see if it is mounted properly. Consult the `smbmount(8)` and related documentation (it may require some fiddling to get write permissions correct, etc.) To unmount:

<pre>  far-away> smbumount /home/fred/smb-haystack-pub
</pre>

At some point we hope to fold some automation for SMB ssh redir setup into the [Enhanced TightVNC Viewer (SSVNC)](ssvnc.html) package we provide (as of Sep 2006 it is there for testing.)

<a name="faq-cups"></a><a name="FAQ-129"></a>

**Q-129:** <font color="#007f00">Can I redirect CUPS print jobs from the remote desktop where **x11vnc** is running to a printer on my local (viewer-side) machine?</font>

You will have to use an external network redirection for this. Printing is not part of the VNC protocol.

We show a simple Unix to Unix **[CUPS](http://www.cups.org/)** example here. Non-CUPS port redirections (e.g. LPD) should also be possible, but may be a bit more tricky. If you are viewing on Windows SMB and don't have a local cups server it may be trickier still (see below.)

First you will need a tunnel to redirect the print requests from the remote machine to the one you sitting at. We use an `ssh` tunnel:

<pre>  sitting-here> ssh -C -R 6631:localhost:631 far-away.east
</pre>

Or one could combine this with the VNC tunnel at the same time, e.g.:

<pre>  sitting-here> ssh -C -R 6631:localhost:631 -t -L 5900:localhost:5900 far-away.east 'x11vnc -localhost -display :0'
</pre>

Port 631 is the default CUPS port. The above assumes you have a Cups server running on your viewer machine (`localhost:631`), if not, use something like `my-cups-srv:631` (the viewer-side Cups server) in the `-R` instead.

Note that we use 6631 instead of 631 on the remote side because 631 would require root permission to listen on (and you likely have a cups server running on it already.)

Now the tricky part: to get applications to _notice_ your cups server/printer on `localhost:6631`.

If you have administrative privilege (i.e. root password) on the **x11vnc** side where the desktop is running, it should be easy to add the printer through some configuration utility (e.g. in KDE: Utilities -> Printing -> Printing Manager, and then supply admin password, and then Add Printer/Class, and then fill in the inquisitive wizard. Most important is the "Remote IPP server" panel where you put in localhost for Host and 6631 for Port.) The main setting you want to convey is the host is localhost and the port is non-standard (e.g. 6631.) Some configuration utilities will take an Internet Printing Protocol (IPP) URI, e.g. `http://localhost:6631/printers/`, `ipp://localhost:6631/printers/printer-name`, `ipp://localhost:6631/ipp/printer-name`, etc. Check your CUPS documentation and admin interfaces to find what the syntax is and what the "`printer name`" is.

If you do not have root or print admin privileges, but are running a recent (version 1.2 or greater) of the Cups client software, then an easy way to temporarily switch Cups servers is to create the directory and file: `$HOME/.cups/client.conf` on the remote side with a line like:

<pre>  ServerName localhost:6631
</pre>

When not using **x11vnc** for remote access you can comment the above line out with a '#' (or rename the client.conf file), to have normal cups operation.

Unfortunately, running applications may need to be restarted to notice the new printers (libcups does not track changes in client.conf.) Depending on circumstances, a running application may actually notice the new printers without restarting (e.g. no print dialog has taken place yet, or there are no CUPS printers configured on the remote side.)

Cups client software that is older (1.1) does not support appending the port number, and for newer ones there is a bug preventing it from always working (fixed in 1.2.3.) Kludges like these at the command line will work:

<pre>  far-away> env CUPS_SERVER=localhost IPP_PORT=6631 lpstat -p -d
  far-away> env CUPS_SERVER=localhost IPP_PORT=6631 lpr -P myprinter file.ps
  far-away> env CUPS_SERVER=localhost IPP_PORT=6631 firefox
</pre>

but are somewhat awkward since you have to retroactively set the env. var `IPP_PORT`. Its value cannot be broadcast to already running apps (like the `$HOME/.cups/client.conf` trick sometimes does.) A common workaround for an already running app is to somehow get it to "Print To File", e.g. `file.ps` and then use something like the `lpr` example above. Also, the option "`-h host:port`" works with CUPS `lp(1)` and `lpr(1)`.

You can also print to Windows shares printers in principle. You may do this with the `smbspool(8)` command, or configure the remote CUPS via `lpadmin(8)`, etc, to use a printer URI something like `smb://machine:port/printer` (this may have some name resolution problems WRT localhost.) Also, as with SMB mounting, the port redir (-R) to the Windows machine must use the actual IP address instead of "localhost".

At some point we hope to fold some automation for CUPS ssh redir setup into the [Enhanced TightVNC Viewer (SSVNC)](ssvnc.html) package we provide (as of Sep 2006 it is there for testing.)

<a name="faq-sound"></a><a name="FAQ-130"></a>

**Q-130:** <font color="#007f00">How can I hear the sound (audio) from the remote applications on the desktop I am viewing via **x11vnc**?</font>

You will have to use an external network audio mechanism for this. Audio is not part of the VNC protocol.

We show a simple Unix to Unix **esd** example here (**artsd** should be possible too, we have also verified the esd Windows port works for the method described below.)

First you will need a tunnel to redirect the audio from the remote machine to the one you sitting at. We use an `ssh` tunnel:

<pre>  sitting-here> ssh -C -R 16001:localhost:16001 far-away.east
</pre>

Or one could combine this with the VNC tunnel at the same time, e.g.:

<pre>  sitting-here> ssh -C -R 16001:localhost:16001 -t -L 5900:localhost:5900 far-away.east 'x11vnc -localhost -display :0'
</pre>

Port 16001 is the default ESD uses. So when an application on the remote desktop makes a sound it will connect to this tunnel and be redirected to port 16001 on the local machine (`sitting-here` in this example.) The `-C` option is an attempt to compress the audio a little bit.

So we next need a local (`sitting-here`) esd daemon running that will receive those requests and play them on the local sound device:

<pre>  sitting-here> esd -promiscuous -port 16001 -tcp -bind 127.0.0.1
</pre>

See the `esd(1)` man page for the meaning of the options (the above are not very secure.) (This method also works with the EsounD windows port esd.exe)

To test this sound tunnel, we use the `esdplay` program to play a simple .wav file:

<pre>  far-away> esdplay -s localhost:16001 im_so_happy.wav
</pre>

If you hear the sound (Captain Kirk in this example), that means you are in great shape.

To run individual audio applications you can use the `esddsp(1)` command:

<pre>  far-away> esddsp -s localhost:16001 xmms
</pre>

Then you could try playing some sounds inside xmms. You could also set the environment variable `ESPEAKER=localhost:16001` to not need to supply the `-s` option all the time. (for reasons not clear, sometimes `esddsp` can figure it out on its own.) All the script `esddsp` does is to set `ESPEAKER` and `LD_PRELOAD` for you so that when the application opens the sound device (usually `/dev/dsp`) its interactions with the device will be intercepted and sent to the `esd` daemon running on `sitting-here` (that in turn writes them to the real, local `/dev/dsp`.)

_Redirecting All sound:_

It does not seem to be possible to switch all of the sound of the remote machine from its sound device to the above `esd+ssh` tunnel without some preparation. But it can be done reasonably well if you prepare (i.e. restart) the desktop with this in mind.

Here is one way to redirect all sound. The idea is we run the _entire_ desktop with sound directed to `localhost:16001`. When we are sitting at `far-away.east` we run "`esd -promiscuous -port 16001 -tcp -bind 127.0.0.1`" on `far-away.east` (to be able to hear the sound.) However, when we are sitting at `sitting-here.west` we kill that `esd` process and run that same `esd` command on `sitting-here.west` and start up the above `ssh` tunnel. This is a little awkward, but with some scripts one would probably kill and restart the esd processes automatically when **x11vnc** is used.

So next we have to run the whole desktop pointing toward our `esd`. Here is a simple way to test. Log in to the machine via the "FailSafe" desktop. Then in the lone terminal type something like:

<pre>  esddsp -s localhost:16001 gnome-session
or:
  esddsp -s localhost:16001 startkde
</pre>

where the last part is whatever command starts your desktop (even `fvwm2`.) This causes the environment variables `ESPEAKER` and `LD_PRELOAD` to be set appropriately and _every_ application (processes with the desktop as an ancestor) will use them. If this scheme works well you can make it less klunky by adding the command to your `~/.xsession`, etc. file that starts your default desktop. Or you may be able to configure your desktop to use `localhost:16001`, or whatever is needed, via a gui configuration panel._Some Notes:_

*   Not all audio applications are compatible with the **esd** and **artsd** mechanisms, but many are.
*   The audio is not compressed so you probably need a broadband or faster connection. Listening to music may not be very pleasant... (Although we found streaming music from across the US over cable modem worked OK, but took 200 KB/sec, to use less bandwidth consider something like "`ssh far-away.east 'cat favorite.mp3' | mpg123 -b 4000 -`")
*   Linux does not seem to have the concept of `LD_PRELOAD_64` so if you run on a mixed 64- and 32-bit ABI system (e.g. AMD `x86_64`) some of the applications will fail to run because `LD_PRELOAD` will point to libraries of the wrong wordsize.
*   At some point we hope to fold some automation for esd or artsd ssh redir setup into the [Enhanced TightVNC Viewer (SSVNC)](ssvnc.html) package we provide (as of Sep/2006 it is there for testing.)

<a name="faq-beeps"></a><a name="FAQ-131"></a>

**Q-131:** <font color="#007f00">Why don't I hear the "Beeps" in my X session (e.g. when typing `tput bel` in an xterm)?</font>

As of Dec/2003 "Beep" XBell events are tracked by default. The X server must support the XKEYBOARD extension (this is not on by default in Solaris, see `Xserver(1)` for how to turn it on via `+kb`), and so you won't hear them if the extension is not present.

If you don't want to hear the beeps use the [`-nobell`](x11vnc_opts.html#opt-nobell) option. If you want to hear the audio from the remote applications, consider trying a [redirector such as **esd**](#faq-sound).

<a name="faq-ipv6"></a><a name="FAQ-132"></a>

**Q-132:** <font color="#007f00">Does **x11vnc** work with IPv6?</font>

_**Update**:_ as of Apr/2010 in the 0.9.10 **x11vnc** development tarball, there is now built-in support for IPv6 (128 bit internet addresses.) See the [`-6`](x11vnc_opts.html#opt-6) and [`-connect`](x11vnc_opts.html#opt-connect) options for details.

The remainder of this FAQ entry shows how to do with this with pre 0.9.10 x11vnc using IPv6 helper tools.

* * *

_Using an external IPv6 helper:_

A way to do this is via a separate helper program such as [inetd](#faq-inetd) (or for encrypted connections: ssh or stunnel.) For example, you configure **x11vnc** to be run from inetd or xinetd and instruct it to listen on an IPv6 address. For xinetd the setting "`flags = IPv6`" will be needed. For inetd.conf, an example is:

<pre>  5900 stream tcp6 nowait root /usr/sbin/tcpd /usr/local/bin/x11vnc_wrapper.sh
</pre>

We also provide a transitional tool in "[`x11vnc/misc/inet6to4`](inet6to4)" that acts as a relay for any IPv4 application to allow connections over IPv6\. For example:

<pre>  inet6to4 5900 localhost:5900
</pre>

where **x11vnc** is listening on IPv4 port 5900.

Also note that not all VNC Viewers are IPv6 enabled, so a redirector may also be needed for them. The tool "`inet6to4 -r ...`" can do this as well. SSVNC (see below) supports IPv6 without need for the helper.

<pre>  # ./inet6to4 -help

  inet6to4:  Act as an ipv6-to-ipv4 relay for tcp applications that
             do not support ipv6.

  Usage:     inet6to4    <ipv6-listen-port> <ipv4-host:port>
             inet6to4 -r <ipv4-listen-port> <ipv6-host:port>Examples:  inet6to4 5900 localhost:5900
             inet6to4 8080 web1:80
             inet6to4 -r 5900 fe80::217:f2ff:fee6:6f5a%eth0:5900

  The -r option reverses the direction of translation (e.g. for ipv4
  clients that need to connect to ipv6 servers.)  Reversing is the default
  if this script is named 'inet4to6' (e.g. by a symlink.)

  Use Ctrl-C to stop this program.

  You can also set env. vars INET6TO4_LOOP=1 or INET6TO4_LOOP=BG
  to have an outer loop restarting this program (BG means do that
  in the background), and INET6TO4_LOGFILE for a log file.
  Also set INET6TO4_VERBOSE to verbosity level and INET6TO4_WAITTIME
  and INET6TO4_PIDFILE (see below.)</ipv6-host:port> </ipv4-listen-port></ipv4-host:port></ipv6-listen-port></pre>

The "`INET6TO4_LOOP=BG`" and "`INET6TO4_LOGFILE=...`" env. variables make the tool run reliably as a daemon for very long periods. Read the top part of the script for more information.

* * *

_Encrypted Tunnels with IPv6 Support:_

For SSH tunnelled encrypted VNC connections, one can of course use the IPv6 support in ssh(1).

For SSL encrypted VNC connections, one possibility is to use the IPv6 support in stunnel(1). This includes the built-in support via the [`-stunnel`](x11vnc_opts.html#opt-stunnel) option. For example:

<pre>  x11vnc -stunnel SAVE -env STUNNEL_LISTEN=:: -env STUNNEL_DEBUG=1 ...
</pre>

* * *

_SSH IPv6 Tricks:_

It is interesting to note that ssh(1) can do basically the same thing as inet6to4 above by:

<pre>  ssh -g -L 5900:localhost:5901 localhost "printf 'Press Enter to Exit: '; read x"
</pre>

(where we have x11vnc running via "`-rfbport 5901`" in this case.)

Note that one can also make a home-brew SOCKS5 ipv4-to-ipv6 gateway proxy using ssh like this:

<pre>  ssh -D '*:1080' localhost "printf 'Press Enter to Exit: '; read x"
</pre>

then specify a proxy like `socks://hostname:1080` where hostname is the machine running the above ssh command (add -v to ssh for connection logging info.)

* * *

_IPv6 SSVNC Viewer:_

Our [SSVNC VNC Viewer](ssvnc.html) is basically a wrapper for ssh(1) and stunnel(1), and so it already has good IPv6 support because these two commands do. On Unix, MacOSX, and Windows nearly all of the the remaining parts of SSVNC (e.g. the built-in proxying and un-encrypted connections) have been modified to support IPv6 in SSVNC 1.0.26.

#### Contributions:

<a name="faq-thanks"></a><a name="FAQ-133"></a>

**Q-133:** <font color="#007f00">Thanks for your program or for your help! Can I make a donation?</font>

Please do (any amount is appreciated; very few have donated) and thank you for your support! Click on the PayPal button below for more info.

<form action="https://www.paypal.com/cgi-bin/webscr" method="post" target="_blank"><input name="cmd" value="_donations" type="hidden"> <input name="business" value="runge at-sign karlrunge.com" type="hidden"> <input name="item_name" value="x11vnc Donation" type="hidden"> <input name="no_shipping" value="1" type="hidden"> <input name="no_note" value="0" type="hidden"> <input name="currency_code" value="USD" type="hidden"> <input name="tax" value="0" type="hidden"> <input src="http://www.karlrunge.com/x11vnc/x-click-but04.gif" name="submit" alt="" type="image" border="0"> ![](https://www.paypal.com/en_US/i/scr/pixel.gif)</form>


-----
http://www.karlrunge.com/x11vnc/chainingssh.html:


* * *

<a name="gateway_double_ssh"></a>**_Chaining ssh's:_** Note that for use of a `ssh` gateway and `-L` redirection to an internal host (e.g. "`-L 5900:otherhost:5900`") the VNC traffic inside the firewall is not encrypted and you have to manually log into `otherhost` to start **x11vnc**. Kyle Amon shows a method where you chain two ssh's together that encrypts all network traffic and also automatically starts up **x11vnc** on the internal workstation:

<pre>#!/bin/sh
#
gateway="example.com"	# or "user@example.com"
host="labyrinth"	# or "user@hostname"
user="kyle"

# Need to sleep long enough for all of the passwords and x11vnc to start up.
# The </dev/null below makes the vncviewer prompt for passwd via popup window. 
#
(sleep 10; vncviewer -encodings "copyrect tight zrle zlib hextile" \
    localhost:0 </dev/null >/dev/null) &

# Chain the vnc connection thru 2 ssh's, and connect x11vnc to user's display:
#
exec /usr/bin/ssh -t -L 5900:localhost:5900 $gateway \
     /usr/bin/ssh -t -L 5900:localhost:5900 $host \
     sudo /usr/bin/x11vnc -localhost -auth /home/$user/.Xauthority \
         -rfbauth .vnc/passwd -display :0
</pre>

Also note the use of `sudo(1)` to switch to root so that the different user's `.Xauthority` file can be accessed. See the `visudo(8)` manpage for details on how to set this up (remove the sudo if you do not want to do this). One can also chain together ssh's for _reverse_ connections with vncviewers using the `-listen` option. For this case `-R` would replace the `-L` (and 5500 the 5900, see the **#2** example script above). If the gateway machine's `sshd` is configured with `GatewayPorts=no` (the default) then the double chaining of "`ssh -R ...`" will be required for reverse connections to work.

A user reports that SSVNC works properly in remote helpdesk mode using UltraVNC Single-click in Windows Vista.

	
-----
http://www.karlrunge.com/x11vnc/miscbuild.html:

* * *

<a name="miscbuildproblems"></a>**Misc. Build problems:**   We collect here rare build problems some users have reported and the corresponding workarounds. See also the [FAQ's on building](faq.html#faq-build).

* * *

**ENV parameter:** One user had a problem where the build script below was failing because his work environment had the `ENV` variable set to a script that was resetting his `PATH` so that `gcc` could no longer be found. Make sure you do not have any `ENV` or `BASH_ENV` in your environment doing things like that. Typing "`unset ENV`", etc. before configuring and building should clear it.

* * *

**Bash xpg:** One user had his `bash` shell compiled with `--enable-xpg-echo-default` that causes some strange behavior with things like `echo "\\1 ..."` the `configure` script executes. In particular instead of getting "`\1`" the non-printable character "`^A`" is produced, and causes failures at compile time like:

<pre>  ../rfb/rfbconfig.h:9:22: warning: extra tokens at end of #ifndef directive
</pre>

The workaround is to configure like this:

<pre>  env CONFIG_SHELL=/bin/sh /bin/sh ./configure
</pre>

i.e. avoid using the bash with the misbehavior. A bug has been filed against autoconf to guard against this.

* * *

**AIX:** one user had to add the "X11.adt" package to AIX to get build header files like `XShm.h`, etc.

* * *

**Ubuntu Feisty Fawn 7.04:** In May/2007 one user said he needed to add these packages to compile **x11vnc** on that Linux distro and version:

<pre>  apt-get install build-essential make bin86 libjpeg62-dev libssl-dev libxtst-dev
</pre>

Note that Ubuntu is based on Debian, so perhaps this is the list needed on Debian (testing?) as well. To build in Avahi (mDNS service advertising) support it would appear that `libavahi-client-dev` is needed as well.

* * *

**Exceedingly slow compilation:** **x11vnc** has a couple of files which contain very large "case statements" (over 100 cases) that on some platforms can take a _**very**_ long time to compile (in extreme cases over an hour). However on 32bit Linux with intel/amd processor and gcc these files usually take less than 10 seconds to compile. For 64bit systems using gcc the problem appears to be much worse.

The two files with the large number of cases, `remote.c` and `x11vnc.c`, have no real need to be optimized (the code is used only very infrequently). So it is fine to supply "`-O0`" (disables optimization) to `CFLAGS` when compiling them. However, it is tricky with autoconf/automake to do this (especially since both the compiler and make versions have a big effect).

So if the compile times are getting too long for you for these two files you will need to manually change some things. First, run `configure` and when it has finished, edit the generated file `x11vnc/Makefile` and put these lines at the very top:

<pre>x11vnc-x11vnc.o :  CFLAGS += -O0
x11vnc-remote.o :  CFLAGS += -O0
</pre>

Those lines assume gnu make (`gmake`) is being used. If you are using another make, say Solaris make, insert these instead:

<pre>x11vnc-x11vnc.o := CFLAGS += -O0
x11vnc-remote.o := CFLAGS += -O0
</pre>

You could write a build shell script that modified the Makefile this way before running `make`.

The "`-O0`" (note it is "capital Oh" followed by "zero") assumes the `gcc` compiler. If you are using a different compiler you will need to find the command line option to disable optimization, or otherwise have the lines set `CFLAGS` to the empty string.

* * *

**Broken Thread Local Storage on SuSE 9.2:** Starting with **x11vnc** 0.9.8 the bundled libvncserver uses the `__thread` keyword to make some of the encodings (i.e. tight) thread safe (multiple VNC clients can be using tight at the same time in x11vnc `[-threads](x11vnc_opts.html#opt-threads)` mode.) Evidently on the old SuSE 9.2 system the compiler does not support the thread local storage properly. Here is an example build failure:

<pre>tight.c:1126: error: unrecognizable insn:
(insn:HI 11 10 13 0 (nil) (set (reg/f:SI 59)
        (const:SI (plus:SI (symbol_ref:SI ("%lpalette"))
                (const_int 2048 [0x800])))) -1 (nil)
    (expr_list:REG_EQUAL (const:SI (plus:SI (symbol_ref:SI ("%lpalette"))
                (const_int 2048 [0x800])))
        (nil)))
tight.c:1126: internal compiler error: in extract_insn, at recog.c:2175
Please submit a full bug report,
with preprocessed source if appropriate.
See URL:http://www.suse.de/feedback for instructions.
</pre>

The workaround is to disable thread local storage at configure time like this:

<pre>env CPPFLAGS="-DTLS=''" ./configure
</pre>

and then build it.

* * *
	
-----
http://www.karlrunge.com/x11vnc/sunray.html:

#### Sun Ray Notes:

You can run **x11vnc** on your (connected or disconnected) [SunRay session](http://www.sun.com/sunray/index.html) (Please remember to use settings like [`-wait 200`](x11vnc_opts.html#opt-wait), [`-sb 15`](x11vnc_opts.html#opt-sb), and not running a screensaver animation (blank instead) to avoid being a resource hog! **x11vnc** does induce a lot of memory I/O from polling the X server. It also helps to have a solid background color, e.g. [`-solid`](x11vnc_opts.html#opt-solid)).

**News:** _Sun Ray Remote Control Toolkit:_ See the nice set of tools in the [Sun Ray Remote Control Toolkit](http://wiki.sun-rays.org/index.php/Remote_Control_Toolkit) that launch **x11vnc** automatically for you for certain usage modes.

You have to know the name of the machine your SunRay session X server is running on (so you can `ssh` into it and start **x11vnc**). You also need to know the X11 `DISPLAY` number for the session: on a SunRay it could be a large number, e.g. `:137`, since there are many people with X sessions (**Xsun** processes) on the same machine. If you don't know it, you can get it by running `who(1)` in a shell on the SunRay server and looking for the `dtlocal` entry with your username (and if you don't even know which server machine has your session, you could login to all possible ones looking at the `who` output for your username...).

I put some code in my `~/.dtprofile` script that stores `$DISPLAY` (including the hostname) in a `~/.sunray_current` file at session startup (and deletes it when the X session ends) to make it easy to get at the hostname and X11 display number info for my current X sessions when I ssh in and am about to start x11vnc.

**SunRay Gotcha #1:**   Note that even though your SunRay X11 `DISPLAY` is something like `:137`, **x11vnc** _still_ tries for port 5900 as its listening port if it can get it, in which case the _VNC display_ (<it>i.e.</it> the information you supply to the VNC viewer) is something like `sunray-server:0`   (note the `:0` corresponding to port 5900, it is _not_ `:137`). If it cannot get 5900, it tries for 5901, and so on. You can also try to force the port (and thereby the VNC display) using the [`-rfbport NNNN`](x11vnc_opts.html#opt-rfbport) option.

Especially on a busy Sun Ray server it is often difficult to find free ports for both VNC and the HTTP Java applet server to listen on. This script, [vnc_findports](vnc_findports) may be of use for doing this automatically. It suggests x11vnc command line options based on `netstat` output that lists the occupied ports. It is even more difficult to start `vncserver/Xvnc` on a busy Sun Ray because then 3 ports (HTTP, VNC, and X11), all separated by 100 are needed! This script, [findvncports](findvncports) may be helpful as well. Both scripts start at VNC display :10 and work their way up.

**SunRay Gotcha #2:**   If you get an error like:

<pre>	shmget(tile) failed.
	shmget: No space left on device
</pre>

when starting up **x11vnc** that most likely means all the shared memory (shm) slots are filled up on your machine. The Solaris default is only 100, and that can get filled up in a week or so on a SunRay server with lots of users. If the shm slot is orphaned (_e.g._ creator process dies) the slot is not reclaimed. You can view the shm slots with the "`ipcs -mA`" command. If there are about 100 then you've probably hit this problem. They can be cleaned out (by the owner or by root) using the `ipcrm` command. I wrote a script [shm_clear](shm_clear) that finds the orphans and lists or removes them. Longer term, have your SunRay sysadmin add something like this to `/etc/system`:

<pre>        set shmsys:shminfo_shmmax = 0x2000000
        set shmsys:shminfo_shmmni = 0x1000
</pre>

**SunRay Gotcha #3:**   Some SunRay installations have implemented suspending certain applications when a SunRay session is in a disconnected state (e.g. Java Badge pulled out, `utdetach`, etc). This is a good thing because it limits hoggy or runaway apps from wasting the shared CPU resource. Think how much CPU and memory I/O is wasted by a bunch of Firefox windows running worthless Flash animations while your session is disconnected!

So some sites have implemented scripts to suspend (e.g. `kill -STOP`) certain apps when your badge is removed from the SunRay terminal. When you reattach, it `kill -CONT` them. This causes problems for viewing the detached SunRay session via **x11vnc**: those suspended apps will not respond (their windows will be blank or otherwise inactive).

What to do? Well, since you are going to be using the application you might as well unfreeze it rather than starting up a 2nd instance. Here is one way to do it using the `kill -CONT` mechanism:

<pre>   kill -CONT `ps -ealf | grep ' T ' | grep $LOGNAME | awk '{print $4}'`
</pre>

If you want to be a good citizen and re-freeze them before you exit **x11vnc** this script could be of use:

<pre>#!/bin/sh
#
# kill -STOP/-CONT script for x11vnc (or other) SunRay usage ("freezes"
# certain apps from hogging resources when disconnected).
#
# Put here a pattern that matches the apps that are frozen:
#
appmatch="java_vm|jre|netscape-bin|firefox-bin|realplay|acroread|mozilla-bin"

if [ "X$1" = "Xfreeze" ]; then
	pkill -STOP -U $LOGNAME "$appmatch"
elif [ "X$1" = "Xthaw" ]; then
	pkill -CONT -U $LOGNAME "$appmatch"

elif [ "$RFB_MODE" = "afteraccept" -a "$RFB_STATE" = "NORMAL" ]; then
	# a valid x11vnc login.
	if [ "$RFB_CLIENT_COUNT" = "1" ]; then
		# only one client present.
		pkill -CONT -U $LOGNAME "$appmatch"
	fi
elif [ "$RFB_MODE" = "gone" -a "$RFB_STATE" = "NORMAL" ]; then
	# a valid x11vnc login.
	if [ "$RFB_CLIENT_COUNT" = "0" ]; then
		# last client present has just left.
		pkill -STOP -U $LOGNAME "$appmatch"
	fi
fi
exit 0
</pre>

If you called the script "`goodcitizen`" you could type "`goodcitizen thaw`" to unfreeze them, and then "`goodcitizen freeze`" to refreeze them. One could also use these **x11vnc** options "`-afteraccept goodcitizen -gone goodcitizen`" to do it automatically.

**SunRay Gotcha #4:**   Recent versions of the Sun Ray Server Software SRSS (seems to be version 3.0 or 3.1) have a "misfeature" that when the session is disconnected (i.e. badge/smartcard out) the screen locker (`xscreensaver`) will freeze the X server just when the "Enter Password" dialog box appears. So you cannot unlock the screen remotely via **x11vnc**!

_**Update**_: please see Bob Doolittle's detailed description of the this issue at the [bottom](#doolittle) of this section.

Here "freeze" means "stop other X clients from inserting keyboard and mouse input and from viewing the current contents of the screen". Or something like that; the upshot is **x11vnc** can't do its normal thing.

There are several workarounds for this.

1) The easiest one by far is to put these lines in your `$HOME/.dtprofile` file:

<pre>SUN_SUNRAY_UTXLOCK_PREF="/usr/openwin/bin/xlock -mode blank"
export SUN_SUNRAY_UTXLOCK_PREF
</pre>

One might argue that `xlock` isn't particularly "pretty". (Just IMHO, but if something like this not being pretty actually gets in the way of your work I think some introspection may be in order. :-)

2) The problem has been traced to the `pam_sunray.so` PAM module. Evidently `xscreensaver` invokes this pam module and it communicates with `utsessiond` who in turn instructs the `Xsun` server to not process any synthetic mouse/keyboard input or to update the screen framebuffer. It is not clear if this is by design (security?) or something else.

In any event, the problem can be avoided, somewhat drastically, by commenting out the corresponding line in `/etc/pam.conf`:

<pre>#xscreensaver auth sufficient /opt/SUNWut/lib/pam_sunray.so syncondisplay
</pre>

Leave the other xscreensaver pam authentication lines unchanged. The `dtsession-SunRay` line may also need to be commented out to avoid the problem for CDE sessions. N.B. it is possible the application of a SSRS patch, etc, may re-enable that `/etc/pam.conf` line. It may be difficult to convince a sysadmin to make this change.

3) A more forceful way is to `kill` the `xscreensaver` process from a shell prompt whenever you connect via **x11vnc** and the screen is in a locked state:

<pre>pkill -U $LOGNAME '^xscreensaver/pre>
</pre>

And then after you are in be sure to restart it by typing something like:

<pre>xscreensaver &
</pre>

You may want to avoid restarting it until you are about to disconnect your VNC viewer (since if it locks the screen while you are working you'll be stuck again).

3') The above idea can be done a bit more cleanly by having **x11vnc** do it. Suppose we called the following script `xss_killer`:

<pre>#!/bin/sh
#
# xss_killer: kill xscreensaver after a valid x11vnc client logs in.
#             Restart xscreensaver and lock it when the last client
#             disconnects.

PATH=/usr/openwin/bin:/usr/bin:$PATH
export PATH

if [ "$RFB_MODE" = "afteraccept" -a "$RFB_STATE" = "NORMAL" ]; then
	# a valid x11vnc login.
	if [ "$RFB_CLIENT_COUNT" = "1" ]; then
		# only one client present.
		pkill -U $LOGNAME '^xscreensaver/pre>
		pkill -KILL -U $LOGNAME -f xscreensaver/hacks
	fi
elif [ "$RFB_MODE" = "gone" -a "$RFB_STATE" = "NORMAL" ]; then
	# a valid x11vnc login.
	if [ "$RFB_CLIENT_COUNT" = "0" ]; then
		# last client present has just left.
		xscreensaver -nosplash &
		sleep 1
		xscreensaver-command -lock &
	fi
fi
</pre>

Then we would run **x11vnc** with these options: "`-afteraccept xss_killer -gone xss_killer`". The [`-afteraccept`](x11vnc_opts.html#opt-afteraccept) option (introduced in version 0.8) is used to run a command _after_ a vncviewer has successfully logged in (note that this is a VNC login, not a Unix login, so you may not want to do this if you are really paranoid...)

Note if you use the above script and also plan to Ctrl-C (SIGINT) **x11vnc** you have to run the xscreensaver in a new process group to avoid killing it as well. One way to do this is via this kludge:

<pre>perl -e 'setpgrp(0,0); exec "xscreensaver -nosplash &"'
</pre>

in the above script.

4) There appears to be a bug in `pam_sunray.so` in that it doesn't seem to honor the convention that, say, `DISPLAY=unix:3` means to use Unix sockets to connect to display 3 on the local machine (this is a bit faster than TCP sockets). Rather, it thinks the display is a non-local one to a machine named "unix" (that usually does not resolve to an IP address).

Amusingly, this can be used to bypass the `pam_sunray.so` blocking of Xsun that prevents one from unlocking the screen remotely via **x11vnc**. One could put something like this in `$HOME/.dtprofile` to kill any existing xscreensavers and then start up a fresh xscreensaver using `DISPLAY=unix:N`

<pre># stop/kill any running xscreensavers (probably not running yet, but to be sure)
xscreensaver-command -exit
pkill -U $LOGNAME '^xscreensaver/pre>
env DISPLAY=`echo $DISPLAY | sed -e 's/^.*:/unix:/'` xscreensaver &
</pre>

**Important:** Note that all of the above workarounds side-step the `pam_sunray.so` PAM module in one way or another. You'll need to see if that is appropriate for your site's SunRay / smartcard usage. Also, these hacks may break other things and so you may want to test various scenarios carefully. E.g. check corner cases like XDMCP/dtremote, NSCM, etc.

<a name="doolittle">**Update May 2008:** Here is a useful description of this issue from Bob Doolittle who is a developer for Sun Ray at Sun. I don't have the time to digest and distill it and then adjust the above methods to provide a clearer description, so I just include below the description he sent me with the hope that it will help some users:</a>

<a name="doolittle">

> In SRSS 4.0 and earlier, the purpose of pam_sunray.so in the "auth" PAM stack of screensavers is to enable NSCM (and, although this is much less commonly used, "SC", which is configured when 3rd-party software is installed to allow smartcards to be used as part of the authentication process) to work. It should have no effect with smartcards. Currently, however, it does block the PAM stack for all sessions, which causes xscreensaver, when it locks a disconnected session, to not process any mouse or keyboard events as you describe (unless xscreensaver does an X server grab, however, other applications should still be able to draw in the session although xscreensaver may be playing tricks like putting a black window on top of everything). In both of the NSCM and SC models, authentication occurs in a separate session before SRSS will reconnect to the user session, in which case pam_sunray.so causes xscreensaver to just unlock the screen without prompting the user to enter their password again. To do this, pam_sunray.so has to block until the session becomes reconnected, so it can query SRSS at that time to determine whether the user has already authenticated or not. In SRSS 4.0 and earlier releases, pam_sunray.so could have been optimized to not block smartcard sessions, although since the session is disconnected this typically isn't important (except in the x11vnc case, as you've observed).

> In SRSS 4.1, however, for increased security the out-of-session authentication model has been extended to *all* session types, so pam_sunray.so will be required in all cases unless users are willing to authenticate twice upon hotdesking (e.g. when their card is inserted). In future, we may do away with pam_sunray.so, and in fact with any traditional screen locker in the user session, since SRSS itself will be providing better security than a screen locker running entirely within the user's X session is capable of providing.

> Your trick of setting DISPLAY to unix:DPY will effectively disable pam_sunray.so (I'm not sure I'd call that a bug - you're going out of your way to do something that wouldn't occur in the normal course of events, and really provides no useful value other than to tickle this behavior in pam_sunray.so). This will mean that, in SRSS 4.0 and earlier releases, users will be prompted for their passwords twice when reconnecting to their sessions for NSCM and SC session types. In 4.1, disabling pam_sunray.so in this way will cause this double-authentication to occur for *all* sessions, including simple smartcard sessions. Users may be willing to pay that price in order to be able to use x11vnc in disconnected sessions. I like this hack, personally. It's a little less convenient than some of the other approaches you describe, but it's lighter-weight and more secure than most of the other approaches, and provides the value of being able to use x11vnc in locked sessions.

> Here are some other minor notes: - I wouldn't recommend storing your display in your .dtprofile, unless you're willing to live with a single session at a time. Personally, I often find myself using several sessions, in several FoGs, for short periods of time so this would certainly break. IMO it's pretty easy to use $DISPLAY to do what you want on the fly, as needed, so I don't think the price of breaking multiple-session functionality would be worth the convenience, to me at least. Here's some ksh/bash syntax to extract the hostname and display number on the fly which you may find useful:
> 
> <pre>HOSTNAME=${DISPLAY%:*}
> FULLDPY=${DISPLAY#*:}
> DPYNUM=${FULLDPY%.*}
> </pre>

> A final note may give you some insight into other clever hacks in this area: - Check out utaction. It's a very handy little utility that can be run as a daemon in the user session which will invoke a specified command upon session connects and/or disconnects. Personally, I start one up in my .dtprofile as follows:
> 
> <pre>utaction -c $HOME/.srconnectrc -d $HOME/.srdisconnectrc &
> </pre>

> This then allows me to construct a .srconnectrc script containing useful commands I'd like to have run every time I insert my smartcard, and a .srdisconnectrc script of commands to be run every time I remove my smartcard (or, connect/disconnect to my session via NSCM or SC). This can be used for things like notifying a chat client of away status, as well as some of the hacks you've described on your page such as freeze/unfreeze, or perhaps to terminate an xscreensaver and start up a new one with the unix:DPY $DISPLAY specification as you describe (although it probably makes most sense to do this at login time, as opposed to every connect or disconnect event).

</a>

-----
http://www.karlrunge.com/x11vnc/ssl.html:

<a name="ssl-key-management">

* * *

**<font size="+1">Notes on x11vnc SSL Certificates and Key Management:</font>**

The simplest scheme ("`x11vnc -ssl TMP`") is where **x11vnc** generates a temporary, self-signed certificate each time (automatically using `openssl(1)`) and the VNC viewer client accepts the certificate without question (e.g. user clicks "Yes" in a dialog box. Perhaps the dialog allows them to view the certificate too). Also note stunnel's default is to quietly accept all certificates.

The encryption this provides protects against all **_passive_** sniffing of the VNC traffic and passwords on the network and so it is quite good, but it does not prevent a Man-In-The-Middle **_active_** attack: e.g. an attacker intercepts the VNC client stream and sends it his own Public key for SSL negotiation (pretending to be the server). Then it makes a connection to SSL **x11vnc** itself and forwards the data back and forth. He can see all the traffic and modify it as well.

Most people don't seem to worry about Man-In-The-Middle attacks these days; they are more concerned about passive sniffing of passwords, etc. Perhaps someday that will change if attack tools are used more widely to perform the attack. NOTE: There are hacker tools like dsniff/webmitm and cain that implement SSL Man-In-The-Middle attacks. They all rely on the client not bothering to check that the cert is valid.

If you are not worried about Man-In-The-Middle attacks you do not have to read the techniques described in the rest of this document.

</a>

<a name="ssl-key-management">To prevent Man-In-The-Middle attacks, certificates must somehow be verified. This requires the VNC client side have some piece of information that can be used to verify the SSL **x11vnc** server. Alternatively, although rarely done, **x11vnc** can verify VNC Clients' certificates, see the</a> [`-sslverify`](x11vnc_opts.html#opt-sslverify) option that is discussed below.

There are a number of ways to have the client authenticate the SSL x11vnc server. The quickest way perhaps would be to copy (safely) the certificate **x11vnc** prints out:

<pre>26/03/2006 21:12:00 Creating a temporary, self-signed PEM certificate...
...
-----BEGIN CERTIFICATE-----
MIIC4TCCAkqgAwIBAgIJAMnwCaOjvEKaMA0GCSqGSIb3DQEBBAUAMIGmMQswCQYD
VQQGEwJBVTEOMAwGA1UEBxMFTGludXgxITAfBgNVBAsTGGFuZ2VsYS0xMTQzNDI1
NTIwLjQxMTE2OTEPMA0GA1UEChMGeDExdm5jMS4wLAYDVQQDEyV4MTF2bmMtU0VM
(more lines) ...
-----END CERTIFICATE-----
</pre>

to the client machine(s) and have the client's SSL machinery (e.g. stunnel, Web Browser, or Java plugin) import the certificate. That way when the connection to **x11vnc** is made the client can verify that is it the desired server on the other side of the SSL connection.

So, for example suppose the user is using the SSL enabled Java VNC Viewer and has incorporated the **x11vnc** certificate into his Web browser on the viewing side. **If** he gets a dialog that the certificate is not verified he knows something is wrong. It may be a Man-In-The-Middle attack, but more likely **x11vnc** certificate has changed or expired or his browser was reinstalled and/or lost the certificate, etc, etc.

As another example, if the user was using [stunnel](http://stunnel.mirt.net) with his VNC viewer (this is mentioned [in this FAQ](faq.html#faq-ssl-tunnel-ext)), e.g. `STUNNEL.EXE` on Windows, then he would have to set the "`CAfile = path-to-the-cert`" and "`verify = 2`" options in the stunnel.conf file before starting up the tunnel. If a **x11vnc** certificate cannot be verified, stunnel will drop the connection (and print a failure message in its log file).

A third example, using the VNC viewer on Unix with stunnel the wrapper script can be used this way: "`[ss_vncviewer](ss_vncviewer) -verify ./x11vnc.crt far-away.east:0`" where `./x11vnc.crt` is the copied certificate **x11vnc** printed out.

As fourth example, our [SSVNC](ssvnc.html) enhanced tightvnc viewer can also use these certificate files for server authentication. You can load them via the SSVNC 'Certs...' dialog and set 'ServerCert' to the certificate file you safely copied there.

Note that in principle the copying of the certificate to the client machine(s) itself could be altered by a Man-In-The-Middle attack! You can't win; it is very difficult to be completely secure. It is unlikely the attacker could predict how you were going to send it unless you had, say, done it many times before the same way. SSH is a very good way to send it (but of course it too depends on public keys being sent unaltered between the two machines!).

If you are really paranoid, I'm sure you'll figure out a really good way to transport the certificates. See the Certificate Authority scheme below for a way to make this easier (you just have to do it once).

* * *

<a name="saving-certs">_**Saving SSL certificates and keys:**_

Now, it would be very inconvenient to copy the new temporary certificate every time **x11vnc** is run in SSL mode. So for convenience there is the "`SAVE`" keyword to instruct **x11vnc** to save the certificate it creates:

<pre>  x11vnc -ssl SAVE -display :0 ...
</pre>

This behavior is now the default, you must use "`TMP`" for a temporary one. It will save the certificate and private key in these files:

<pre>  ~/.vnc/certs/server.crt
  ~/.vnc/certs/server.pem
</pre>

The ".crt" file contains only the certificate and should be safely copied to the VNC Viewer machine(s) that will be authenticating the **x11vnc** server. The ".pem" file contains both the certificate and the private key and should be kept secret. (If you don't like the default location `~/.vnc/certs`, e.g. it is on an NFS share and you are worried about local network sniffing, use the</a> [`-ssldir dir`](x11vnc_opts.html#opt-ssldir) option to point to a different directory.)

So the next time you run "`x11vnc -ssl SAVE ...`" it will read the `server.pem` file directly instead of creating a new one.

You can manage multiple SSL **x11vnc** server keys in this simple way by using:

<pre>  x11vnc -ssl SAVE-key2 -display :0 ...
</pre>

etc, where you put whatever name you choose for the key after "`SAVE-`". E.g. "`-ssl SAVE-fred`".

Also, if you want to be prompted to possibly change the made up names, etc. that **x11vnc** creates (e.g. "`x11vnc-SELF-SIGNED-CERT-7762`" for the CommonName) for the certificates distinguished name (DN), then use "`x11vnc -ssl SAVE_PROMPT ...`", "`x11vnc -ssl SAVE_PROMPT-fred ...`" etc. when you create the key the first time.

_Tip:_ when prompting, if you choose the CommonName entry to be the full internet hostname of the machine the clients will be connecting to then that will avoid an annoying dialog box in their Web browsers that warn that the CommonName doesn't match the hostname.

* * *

<a name="passphrases">_**Passphrases for server keys:**_

Well, since now with the "`SAVE`" keyword the certificate and key will be longer lived, one can next worry about somebody stealing the private key and pretending to be the **x11vnc** server! How to guard against this?

The first is that the file is created with perms 600 (i.e. `-rw-------`) to make it harder for an untrusted user to copy the file. A better way is to also encrypt the private key with a passphrase. You are prompted whether you want to do this or not when the key is first created under "`-ssl SAVE`" mode ("`Protect key with a passphrase? y/n`"). It is suggested that you use a passphrase. The inconvenience is _every_ time you run "`x11vnc -ssl SAVE ...`" you will need to supply the passphrase to access the private key:

<pre>  06/04/2006 11:39:11 using PEM /home/runge/.vnc/certs/server.pem  0.000s

  A passphrase is needed to unlock an OpenSSL private key (PEM file).
  Enter passphrase>
</pre>

before **x11vnc** can continue.

* * *

</a><a name="certificate-authority">_**Being your own Certificate Authority:**_

A very sophisticated way that scales well if the number of users is large is to use a Certificate Authority (CA) whose public certificate is available to all of the VNC clients and whose private key has been used to digitally sign the **x11vnc** server certificate(s).

The idea is as follows:

</a>

<a name="certificate-authority">*   A special CA cert and key is generated.*   Its private key is always protected by a good passphrase since it is only used for signing.*   The CA cert is (safely) distributed to all machines where VNC clients will run.*   One or more x11vnc server certs and keys are generated.*   The x11vnc server cert is signed with the CA private key.</a>
*   <a name="certificate-authority">x11vnc is run using the server key. (e.g. "</a>[`-ssl SAVE`](x11vnc_opts.html#opt-ssl)")
*   VNC clients (viewers) can now authenticate the x11vnc server because they have the CA certificate.

The advantage is the CA cert only needs to be distributed once to the various machines, that can be done even before x11vnc server certs are generated.

As above, it is important the CA private key and the x11vnc server key are kept secret, otherwise someone could steal them and pretend to be the CA or the x11vnc server if they copied the key. It is recommended that the x11vnc server keys are also protected via a passphrase (see the previous section).

**Optionally**, VNC _**viewer**_ certs and keys could also be generated to enable the **x11vnc** server to authenticate each client. This is not normally done (usually a simple viewer password scheme is used), but this can be useful in some situations. These optional steps go like this:

*   One or more VNC client certs and keys are generated.
*   These VNC client certs are signed with the CA private key.
*   The VNC client certs+keys are safely distributed to the corresponding client machines.
*   x11vnc is told to verify clients by using the CA cert. (e.g. "[`-sslverify CA`](x11vnc_opts.html#opt-sslverify)")
*   When VNC clients (viewers) connect, they must authenticate themselves to x11vnc by using their client key.

Again, it is a good idea if the client private keys are protected with a passphrase, otherwise if stolen they could be used to gain access to the **x11vnc** server. Once distributed to the client machines, there is no need to keep the client key on the CA machine that generated and signed it. You can keep the client certs if you like because they are public.

* * *

<a name="x11vnc-certificate-authority">_**How to do the above CA steps with x11vnc:**_</a>

<a name="x11vnc-certificate-authority">Some utility commands are provided to ease the cert+key creation, signing, and management:</a> [`-sslGenCA`](x11vnc_opts.html#opt-sslGenCA), [`-sslGenCert`](x11vnc_opts.html#opt-sslGenCert), [`-sslDelCert`](x11vnc_opts.html#opt-sslDelCert), [`-sslEncKey`](x11vnc_opts.html#opt-sslEncKey), [`-sslCertInfo`](x11vnc_opts.html#opt-sslCertInfo). They basically run the `openssl(1)` command for you to manage the certs/keys. It is required that `openssl(1)` is installed on the machine and available in `PATH`. All commands can be pointed to an alternate toplevel certificate directory via the [`-ssldir`](x11vnc_opts.html#opt-ssldir) option if you don't want to use the default `~/.vnc/certs`.

1) To generate your Certificate Authority (CA) cert and key run this:

<pre>  x11vnc -sslGenCA
</pre>

Follow the prompts, you can modify any informational strings you care to. You will also be required to encrypt the CA private key with a passphrase. This generates these files:

<pre>  ~/.vnc/certs/CA/cacert.pem             (the CA public certificate)
  ~/.vnc/certs/CA/private/cakey.pem      (the encrypted CA private key)
</pre>

If you want to use a different directory use [`-ssldir`](x11vnc_opts.html#opt-ssldir) It must supplied with all subsequent SSL utility options to point them to the correct directory.

2) To generate a signed **x11vnc** server cert and key run this:

<pre>  x11vnc -sslGenCert server
</pre>

As with the CA generation, follow the prompts and you can modify any informational strings that you care to. This will create the files:

<pre>  ~/.vnc/certs/server.crt             (the server public certificate)
  ~/.vnc/certs/server.pem             (the server private key + public cert)
</pre>

It is recommended to protect the server private key with a passphrase (you will be prompted whether you want to). You will need to provide it whenever you start **x11vnc** using this key.

3) Start up **x11vnc** using this server key:

<pre>  x11vnc -ssl SAVE -display :0 ...
</pre>

(`SAVE` corresponds to `server.pem`, see [`-sslGenCert server somename`](x11vnc_opts.html#opt-ssldir) info on creating additional server keys, `server-somename.crt` ...)

4) Next, safely copy the CA certificate to the VNC viewer (client) machine(s). Perhaps:

<pre>  scp ~/.vnc/CA/cacert.pem clientmachine:.
</pre>

5) Then the tricky part, make it so the SSL VNC Viewer uses this certificate! There are a number of ways this might be done, it depends on what your client and/or SSL tunnel is. Some examples:

For the SSL Java VNC viewer supplied with **x11vnc** in `classes/ssl/VncViewer.jar` or `classes/ssl/SignedVncViewer.jar`:

*   Import the `cacert.pem` cert into your Web Browser (e.g. Edit -> Preferences -> Privacy & Security -> Manage Certificates -> WebSites -> Import)
*   Or Import the `cacert.pem` cert into your Java Plugin (e.g. run ControlPanel, then Security -> Certificates -> Secure Site -> Import)

When importing, one would give the browser/java-plugin the path to the copied `cacert.pem` file in some dialog. Note that the Web browser or Java plugin is used for the server authentication. If the user gets a "Site not verified" message while connecting he should investigate further.

For the use of stunnel (e.g. on Windows) one would add this to the stunnel.conf:

<pre>  # stunnel.conf:
  client = yes
  options = ALL
  CAfile = /path/to/cacert.pem		# or maybe C:\path\to\cacert.pem
  [myvncssl]
  accept = 5901
  connect = far-away.east:5900
</pre>

(then point the VNC viewer to `localhost:1`).

Here is an example for the Unix stunnel wrapper script [ss_vncviewer](ss_vncviewer) in our SSVNC package:

<pre>  ss_vncviewer -verify ./cacert.pem far-away.east:0
</pre>

Our [SSVNC](ssvnc.html) enhanced tightvnc viewer GUI can also use the certificate file for server authentication. You can load it via the SSVNC 'Certs...' dialog and set 'ServerCert' to the `cacert.pem` file you safely copied there.

* * *

<a name="tricks">_**Tricks for server keys:**_

To create additional **x11vnc** server keys do something like this:

<pre>  x11vnc -sslGenCert server myotherkey
</pre>

and use it this way:

<pre>  x11vnc -ssl SAVE-myotherkey ...
</pre>

The files will be `~/.vnc/certs/server-myotherkey.{crt,pem}`

You can also create a self-signed server key:

<pre>  x11vnc -sslGenCert server self:third_key
</pre>

and use it this way:

<pre>  x11vnc -ssl SAVE-self:third_key ...
</pre>

This key is not signed by your CA. This can be handy to have a key set separate from your CA when you do not want to create a 2nd CA cert+key.

* * *

</a><a name="external-ca">_**Using external CA's:**_

You don't have to use your own CA cert+key, you can use a third party's instead. Perhaps you have a company-wide CA or you can even have your **x11vnc** certificate signed by a professional CA (e.g. www.thawte.com or www.verisign.com or perhaps the free certificate service www.startcom.org or www.cacert.org).

The advantage to doing this is that the VNC client machines will already have the CA certificates installed and you don't have to install it on each machine.

To generate an **x11vnc** server cert+key this way you should generate a "request" for a certicate signing something like this (we use the name "external" in this example, it could be anything you want):

<pre>  x11vnc -sslGenCert server req:external
</pre>

This will create the request file:

<pre>  ~/.vnc/certs/server-req:external.req
</pre>

Which you should send to the external CA. When you get the signed certificate back from them, save it in the file:

<pre>  ~/.vnc/certs/server-req:external.crt
</pre>

and create the .pem this way:

<pre>  mv  ~/.vnc/certs/server-req:external.key    ~/.vnc/certs/server-req:external.pem
  chmod 600 ~/.vnc/certs/server-req:external.pem
  cat ~/.vnc/certs/server-req:external.crt >> ~/.vnc/certs/server-req:external.pem
</pre>

You also rename the two files (.crt and .pem) to have a shorter basename if you like. E.g.:

<pre>  mv  ~/.vnc/certs/server-req:external.pem  ~/.vnc/certs/server-ext.pem  
  mv  ~/.vnc/certs/server-req:external.crt  ~/.vnc/certs/server-ext.crt  
</pre>

and the use via "`x11vnc -ssl SAVE-ext ...`", etc.

On the viewer side make sure the external CA's certificate is installed an available for the VNC viewer software you plan to use.

* * *

</a><a name="client-keys">_**Using Client Keys for Authentication:**_

You can optionally create certs+keys for your VNC client machines as well. After distributing them to the client machines you can have **x11vnc** verify the clients using SSL. Here is how to do this:

<pre>  x11vnc -sslGenCert client dilbert
  x11vnc -sslGenCert client wally
  x11vnc -sslGenCert client alice
  ...
</pre>

As usual, follow the prompts if you want to change any of the info field values. As always, it is a good idea (although inconvenient) to protect the private keys with a passphrase. These files are created:

<pre>  ~/.vnc/certs/clients/dilbert.crt
  ~/.vnc/certs/clients/dilbert.pem
  ...
</pre>

Note that these are kept in a `clients` subdirectory.

Next, safely copy the .pem files to each corresponding client machine and incorporate them into the VNC viewer / SSL software (see the ideas mentioned above for the CA and server keys). The only difference is these certificates might be referred to as "My Certificates" or "Client Certificates". They are used for client authentication (which is relatively rare for SSL).

After copying them you can delete the `clients/*.pem` files for extra safety because the private keys are not needed by the **x11vnc** server. You don't really need the `clients/*.crt` files either (because they have been signed by the CA). But they could come in handy for tracking or troubleshooting, etc.

Now start up **x11vnc** and instruct it to verify connecting clients via SSL and the CA cert:

<pre>  x11vnc -ssl SAVE -sslverify CA
</pre>

The "CA" special token instructs **x11vnc** to use its CA signed certs for verification.

For arbitrary self-signed client certificates (no CA) it might be something like this:

<pre>  x11vnc -ssl SAVE -sslverify path/to/client.crt
  x11vnc -ssl SAVE -sslverify path/to/client-hash-dir
  x11vnc -ssl SAVE -sslverify path/to/certs.txt
</pre>

Where `client.crt` would be an individual client certificate; `client-hash-dir` a directory of file names based on md5 hashes of the certs (see</a> [`-sslverify`](x11vnc_opts.html#opt-sslverify)); and `certs.txt` signifies a single file full of client certificates.

Finally, connect with your VNC viewer using the key. Here is an example for the Unix stunnel wrapper script [ss_vncviewer](ss_vncviewer): using client authentication (and the standard server authentication with the CA cert):

<pre>  ss_vncviewer -mycert ./dilbert.pem -verify ./cacert.pem far-away.east:0
</pre>

Our [SSVNC](ssvnc.html) enhanced tightvnc viewer can also use these openssl `.pem` files (you can load them via Certs... -> MyCert dialog).

It is also possible to use [`-sslverify`](x11vnc_opts.html#opt-sslverify) on a per-client key basis, and also using self-signed client keys (`x11vnc -sslGenCert client self:dilbert`)<a name="pkcs12"></a>

<a name="pkcs12">Now a tricky part is to get Web browsers or Java Runtime to import and use the openssl `.pem` cert+key files. See the next paragraph on how to convert them to pkcs12 format. If you find a robust way to import them **and** and get them to use the cert please let us know!</a>

<a name="pkcs12">Here is how to convert our openssl crt/pem files to pkcs12 format (contains both the client certificate and key) that can be read by Web browsers and Java for use in client authentication:</a>

<pre> <a name="pkcs12">openssl pkcs12 -export -in mycert.crt -inkey mycert.pem -out mycert.p12</a> </pre>

<a name="pkcs12">it will ask for a passphrase to protect `mycert.p12`. Some software (e.g. Java ControlPanel) may require a non-empty passphrase. Actually, since our `.pem` contains both the certificate and private key, you could just supply it for the `-in` and remove the `-inkey` option. It appears that for certificates only importing, our `.crt` file is sufficient and can be read by Mozilla/Firefox and Java...</a>

<a name="pkcs12">If you have trouble getting your Java Runtime to import and use the cert+key, there is a workaround for the</a> [SSL-enabled Java applet](faq.html#faq-ssl-tunnel-viewers). On the Web browser URL that retrieves the VNC applet, simply add a "`/?oneTimeKey=...`" applet parameter (see [ssl-portal](ssl-portal.html) for more details on applet parameters; you don't need to do the full portal setup though). The value of the `oneTimeKey` will be the very long string that is output of the `onetimekey` program found in the `classes/ssl` **x11vnc** directory. Or you can set `oneTimeKey=PROMPT` in which case the applet will ask you to paste in the long string. These scheme is pretty ugly, but it works. A nice application of it is to make one time keys for users that have already logged into a secure HTTPS site via password. A cgi program then makes a one time key for the logged in user to use: it is passed back over HTTPS as the applet parameter in the URL and so cannot be sniffed. **x11vnc** is run to use that key via [`-sslverify`](x11vnc_opts.html#opt-sslverify).

_Update:_ as of Apr 2007 in the 0.9.1 **x11vnc** tarball there is a new option setting "[`-users sslpeer=`](x11vnc_opts.html#opt-users)" that will do a switch user much like [`-unixpw`](x11vnc_opts.html#opt-unixpw) does, but this time using the `emailAddress` field of the Certificate subject of the verified Client. This mode requires [`-sslverify`](x11vnc_opts.html#opt-sslverify) turned on to verify the clients via SSL. This mode can be useful in situations using [`-create`](x11vnc_opts.html#opt-create) or [`-svc`](x11vnc_opts.html#opt-svc) where a new X server needs to be started up as the authenticated user (but unlike in `-unixpw` mode, the unix username is not obviously known).

* * *

<a name="revoking-certs">_**Revoking Certificates:**_</a>

<a name="revoking-certs">A large, scaled-up installation may benefit from being able to revoke certificates (e.g. suppose a user's laptop with a vnc client or server key is compromised.) You can use this option with x11vnc:</a> [`-sslCRL`](x11vnc_opts.html#opt-sslCRL). See the info at that link for a guide on what `openssl(1)` commands you will need to run to revoke a certificate.

* * *

<a name="additional-utils">_**Additional utlities:**_</a>

<a name="additional-utils">You can get information about your keys via</a> [`-sslCertInfo`](x11vnc_opts.html#opt-sslCertInfo). These lists all your keys:

<pre>  x11vnc -sslCertInfo list
  x11vnc -sslCertInfo ll
</pre>

(the latter is long format).

These print long output, including the public certificate, for individual keys:

<pre>  x11vnc -sslCertInfo server
  x11vnc -sslCertInfo dilbert
  x11vnc -sslCertInfo all             (every key, very long)
</pre>

If you want to add a protecting passphrase to a key originally created without one:

<pre>  x11vnc -sslEncKey SAVE
  x11vnc -sslEncKey SAVE-fred
</pre>

To delete a cert+key:

<pre>  x11vnc -sslDelCert SAVE
  x11vnc -sslDelCert SAVE-fred
  x11vnc -sslDelCert wally
</pre>

(but `rm(1)` will be just as effective).

* * *

<a name="chained-certificates">_**Chained Certificates:**_

There is increasing interest in using chained CA's instead of a single CA. The merits of using chained CA's are not described here besides to say its use may make some things easier when a certificate needs to be revoked.

**x11vnc** supports chained CA certificates. We describe a basic use case here.

Background: Of course the most straight forward way to use SSL with x11vnc is to use no CA at all (see above): a self-signed certificate and key is used and its certificate needs to be safely copied to the client side. This is basically the same as the SSH style of managing keys. Next level up, one can use a single CA to sign server keys: then only the CA's certificate needs to be safely copied to the client side, this can happen even before any server certs are created (again, see all of the discussion above.)

With a certificate chain there are two or more CA's involved. Perhaps it looks like this:

<pre>  root_CA ---> intermediate_CA ---> server_cert
</pre>

Where the arrow basically means "signs".

In this usage mode the client (viewer-side) will have root_CA's certificate available for verifying (and _nothing_ else.) If the viewer only received server_cert's certificate, it would not have enough info to verify the server. The client needs to have intermediate_CA's cert as well. The way to do this with x11vnc (i.e. an OpenSSL using app) is to concatenate the server_cert's pem and the intermediate_CA's certificate together.

For example, suppose the file `intermediate_CA.crt` had intermediate_CA's certificate. And suppose the file `server_cert.pem` had the server's certificate and private key pair as described above on this page. We need to do this:

<pre>  cat intermediate_CA.crt >> server_cert.pem
</pre>

(Note: the order of the items inside the file matters; intermediate_CA must be after the server key and cert) and then we run x11vnc like this:

<pre>  x11vnc -ssl ./server_cert.pem ...
</pre>

Then, on the VNC viewer client side, the viewer authenticates the x11vnc server by using root_CA's certificate. Suppose that is in a file named `root_CA.crt`, then using the SSVNC wrapper script</a> [`ss_vncviewer`](ss_vncviewer) (which is also included in the [SSVNC](ssvnc.html) package) as our example, we have:

<pre>  ss_vncviewer -verify ./root_CA.crt hostname:0
</pre>

(where "hostname" is the machine where x11vnc is running.) One could also use the SSVNC GUI setting `Certs -> ServerCert` to the `root_CA.crt` file. Any other SSL enabled VNC viewer would use `root_CA.crt` in a similar way.

* * *

_Creating Chained Certificates:_

Here is a fun example using VeriSign's "Trial Certificate" program. Note that VeriSign has a Root CA and also an Intermediate CA and uses the latter to sign customers certificates. So this provides an easy way to test out the chained certificates mechanism with x11vnc.

First we created a test x11vnc server key:

<pre>  openssl genrsa -out V1.key 1024
</pre>

then we created a certificate signing request (CSR) for it:

<pre>  openssl req -new -key V1.key -out V1.csr
</pre>

(we followed the prompts and supplied information for the various fields.)

Then we went to VeriSign's page `http://www.verisign.com/ssl/index.html` and clicked on "FREE TRIAL" (the certificate is good for 14 days.) We filled in the forms and got to the point where it asked for the CSR and so we pasted in the contents of the above `V1.csr` file. Then, after a few more steps, VeriSign signed and emailed us our certificate.

The VeriSign Trial certificates were found here:

<pre>  http://www.verisign.com/support/verisign-intermediate-ca/Trial_Secure_Server_Root/index.html
  http://www.verisign.com/support/verisign-intermediate-ca/trial-secure-server-intermediate/index.html
</pre>

The former was pasted into a file `V-Root.crt` and the latter was pasted into `V-Intermediate.crt`

We pasted our Trial certificate that VeriSign signed and emailed to us into a file named `V1.crt` and then we typed:

<pre>  cat V1.key V1.crt > V1.pem
  cat V1.pem V-Intermediate.crt > V1-combined.pem
  chmod 600 V1.pem V1-combined.pem
</pre>

So now the file `V1-combined.pem `has our private key and (VeriSign signed) certificate **and** VeriSign's Trial Intermediate certificate.

Next, we start x11vnc:

<pre>  x11vnc -ssl ./V1-combined.pem ...
</pre>

and finally, on the viewer side (SSVNC wrapper script example):

<pre>  ss_vncviewer -verify ./V-Root.crt hostname:0
</pre>

One will find that only that combination of certs and keys will work, i.e. allow the SSL connection to be established. Every other combination we tried failed (note that `ss_vncviewer` uses the external `stunnel` command to handle the SSL so we are really testing stunnel's SSL implementation on the viewer side); and so the system works as expected.

* * *

_VNC Client Authentication using Certificate Chains:_

Now, going the other way around with the client authenticating himself via this chain of SSL certificates, x11vnc is run this way:

<pre>  x11vnc -ssl SAVE -sslverify ./V-Root.crt ...
</pre>

(note since the server must always supply a cert, we use its normal self-signed, etc., one via "`-ssl SAVE`" and use the VeriSign root cert for client authentication via [`-sslverify`](x11vnc_opts.html#opt-sslverify). The viewer must now supply the combined certificates, e.g.:

<pre>  ss_vncviewer -mycert ./V1-combined.pem hostname:0
</pre>

* * *

_Using OpenSSL and x11vnc to create Certificate Chains:_

Although the **x11vnc** CA mechanism (`-sslGenCA` and `-sslGenCert`; see above) was designed to only handle a single root CA (to sign server and/or client certs) it can be coerced into creating a certificate chain by way of an extra `openssl(1)` command.

We will first create two CA's via `-sslGenCA`; then use one of these CA to sign the other; create a new (non-CA) server cert; and append the intermediate CA's cert to the server cert to have everything needed in the one file.

Here are the commands we ran to do what the previous paragraph outlines.

First we create the two CA's, called CA_root and CA_Intermediate here, in separate directories via x11vnc:

<pre>  x11vnc -ssldir ~/CA_Root -sslGenCA
     (follow the prompts, we included "CA_Root", e.g. Common Name, to aid identifying it)

  x11vnc -ssldir ~/CA_Intermediate -sslGenCA
     (follow the prompts, we included "CA_Intermediate", e.g. Common Name, to aid identifying it)
</pre>

Next backup CA_Intermediate's cert and then sign it with CA_Root:

<pre>  mv ~/CA_Intermediate/CA/cacert.pem ~/CA_Intermediate/CA/cacert.pem.ORIG
  cd ~/CA_Root
  openssl ca -config ./CA/ssl.cnf -policy policy_anything -extensions v3_ca -notext -ss_cert ~/CA_Intermediate/CA/cacert.pem.ORIG -out ~/CA_Intermediate/CA/cacert.pem
</pre>

Note that it is **required** to cd to the `~/CA_Root` directory and run the `openssl` command from there.

You can print out info about the cert you just modified by:

<pre>  openssl x509 -noout -text -in ~/CA_Intermediate/CA/cacert.pem
</pre>

Now we create an x11vnc server cert named "test_chain" that is signed by CA_Intermediate:

<pre>  x11vnc -ssldir ~/CA_Intermediate -sslGenCert server test_chain
     (follow the prompts)
</pre>

You can print out information about this server cert just created via this command:

<pre>  x11vnc -ssldir ~/CA_Intermediate -sslCertInfo SAVE-test_chain
</pre>

This will tell you the full path to the server certificate, which is needed because we need to manually append the CA_Intermediate cert for the chain to work:

<pre>  cat ~/CA_Intermediate/CA/cacert.pem >> ~/CA_Intermediate/server-test_chain.pem
</pre>

Now we are finally ready to use it. We can run x11vnc using this server cert+key by either this command:

<pre>  x11vnc -ssldir ~/CA_Intermediate -ssl SAVE-test_chain ...
</pre>

or this command:

<pre>  x11vnc -ssl ~/CA_Intermediate/server-test_chain.pem ...
</pre>

since they are equivalent (both load the same pem file.)

Finally we connect via VNC viewer that uses `CA_Root` to verify the server. As before we use `ss_vncviewer`:

<pre>  ss_vncviewer -verify ~/CA_Root/CA/cacert.pem hostname:0
</pre>

Client Certificates (see above) work in a similar manner.

So although it is a little awkward with the extra steps (e.g. appending the CA_Intermediate cert) it is possible. If you want to do this entirely with `openssl(1)` you will have to learn the openssl commands corresponding to `-genCA` and `-genCert`. You may be able to find guides on the Internet to do this. Starting with x11vnc 0.9.10, you can have it print out the wrapper scripts it uses via: [`-sslScripts`](x11vnc_opts.html#opt-sslScripts) (you will still need to fill in a few pieces of information; ask if it is not clear from the source code.)

* * *

_**More info:**_

See also this [article](http://www.securityfocus.com/infocus/1677) for some some general info and examples using stunnel and openssl on Windows with VNC. Also [http://www.stunnel.org/faq/certs.html](http://www.stunnel.org/faq/certs.html) is a very good source of information on SSL certificate creation and management.``

-----
http://www.karlrunge.com/x11vnc/ssl-portal.html:

* * *

**<font size="+1">Using Apache as an SSL Gateway to multiple x11vnc servers inside a firewall:</font>**

**Background:**

The typical way to allow access to **x11vnc** (or any other VNC server) running on multiple workstations inside a firewall is via SSH. The user somewhere out on the Internet logs in to the SSH gateway machine and uses port forwarding (e.g. `ssh -t -L 5900:myworkstation:5900 user@gateway`) to set up the encrypted channel that VNC is then tunneled through. Next he starts up the VNC viewer on the machine where he is sitting directed to the local tunnel port (e.g. `localhost:0`).

The SSH scheme is nice because it is a widely used and well tested login technique for users connecting to machines inside their company or home firewall. For VNC access it is a bit awkward, however, because SSH needs to be installed on the Viewer machine and the user usually has to rig up his own port redirection plumbing (however, see [our other tool](ssvnc.html)).

Also, some users have restrictive work environments where SSH and similar applications are prohibited (i.e. only outgoing connections to standard WWW ports from a browser are allowed, perhaps mediated by a proxy server). These users have successfully used the method described here for remote access.

With the SSL support in **x11vnc** and the SSL enabled Java VNC viewer applet, a convenient and secure alternative exists that uses the Apache webserver as a gateway. The idea is that the company or home internet connection is already running apache as a web server (either SSL or non-SSL) and we add to it the ability to act as a gateway for SSL VNC connections. The only thing needed on the Viewer side is a Java enabled Web Browser: the user simply enters a URL that starts the entire VNC connection process. _No_ VNC or SSH specific software needs to be installed on the viewer side machine.

The stunnel VNC viewer stunnel wrapper script provided ([`ss_vncviewer`](faq.html#ss_vncviewer)) can also take advantage of the method described here with its `-proxy` option.

* * *

_**Simpler Solutions:**_ This apache SSL VNC portal solution may be too much for you. It is mainly intended for automatically redirecting to **_MULTIPLE_** workstations inside the firewall. If you only have one or two inside machines that you want to access, the method described here is overly complicated! See [below](#no-apache) for some simpler (and still non-SSH) encrypted setups.

Also see the recent (Mar/2010) [`desktop.cgi`](faq.html#faq-web-login) x11vnc desktop web login CGI script that achieves much of what the method describes here (especially if its 'port redirection' feature is enabled.)

* * *

There are numerous ways to achieve this with Apache. We present one of the simplest ones here.

_**Important:**_ these sorts of schemes allow incoming connections from anywhere on the Internet to fixed ports on machines _inside_ the firewall. Care must be taken to implement and test thoroughly. If one is paranoid one can (and should) add [extra layers](#precautions) of protection. (e.g. extra passwords, packet filtering, SSL certificate verification, etc).

Also, it is easy to miss the point that **unless** precautions are taken to verify SSL Certificates, then the VNC Viewer is vulnerable to man-in-the-middle attacks (but not to the more common passive sniffing attacks). Note that there are hacker tools like dsniff/webmitm and cain that implement SSL Man-In-The-Middle attacks. They rely on the client not bothering to check the cert.

* * *

**The Holy Grail: a single https port (443)**

Before we discuss the self-contained apache examples here, we want to mention that many **x11vnc** users who read this page and implement the apache SSL VNC portal ask for something that (so far) seems difficult or impossible to do entirely inside apache:

*   A single port, 443 (the default https:// port), is open to the Internet
*   It is HTTPS/SSL encrypted
*   It handles both VNC traffic and Java VNC Applet downloads.
*   **And** the server can also serve normal HTTPS webpages, CGI, etc.

It is the last item that makes it tricky (otherwise the method described on this page will work). If you are interested in such a solution and are willing to run a separate helper program (`connect_switch`) [look here](ssl-single-443.html). Also, see [this apache patch](https://issues.apache.org/bugzilla/show_bug.cgi?id=29744).

* * *

**Example:**

The scheme described here sets up apache on the firewall/gateway as a regular Web proxy _**into**_ the intranet and allows connections to a single fixed port on a limited set of machines.

The configuration described in this section **does not** use the `mod_ssl` apache module (the optional configuration described in the section "Downloading the Java applet to the browser via HTTPS" does take advantage of `mod_ssl`)

In this example suppose the gateway machine running apache is named "`www.gateway.east`" (e.g. it may also provide normal web service). We also choose the Internet-facing port for this VNC service to be port 563\. One could choose any port, including the [default HTTP port 80](#port-variations).

_Detail:_ We choose 563 because it is the rarely used SNEWS port that is often allowed by Web proxies for the CONNECT method. The idea is the user may be coming out of _**another**_ firewall using a proxy (not the one we describe here, that is, the case when two proxies are involved, e.g. one at work and another Apache (described here) at home redirecting into our firewall; the "double proxy" or "double firewall" problem). Using port 563 simplifies things because CONNECT's to it are usually allowed by default.

We also assume all of the **x11vnc** servers on the internal machines are all listening on port 5915 ("`-rfbport 5915`") instead of the default 5900\. This is to limit any unintended proxy redirections to a lesser used port, and also to stay out of the way of normal VNC servers on the same machines. One could obviously implement a scheme that handles different ports, but we just discuss this simple setup here.

So we basically assume **x11vnc** has been started this way on all of the workstations to be granted VNC access:

<pre>  x11vnc -ssl SAVE -http -display :0 -forever -rfbauth ~/.vnc/passwd -rfbport 5915
</pre>

i.e. we force SSL VNC connections, port 5915, serve the Java VNC viewer applet, and require a VNC password (another option would be [`-unixpw`](x11vnc_opts.html#opt-unixpw)). The above command could also be run out of [inetd(8)](#inetd). It can **also** be used to [autodetect](faq.html#faq-userlogin) the user's display and Xauthority data.

These sections are added to the `httpd.conf` apache configuration file on `www.gateway.east`:

<pre>
# In the global section you need to enable these modules.
# Note that the ORDER MATTERS! mod_rewrite must be before mod_proxy
# (so that we can check the allowed host list via rewrite)
#
LoadModule rewrite_module modules/mod_rewrite.so
LoadModule proxy_module modules/mod_proxy.so
LoadModule proxy_connect_module modules/mod_proxy_connect.so
LoadModule proxy_ftp_module modules/mod_proxy_ftp.so
LoadModule proxy_http_module modules/mod_proxy_http.so
<IfDefine SSL>
LoadModule ssl_module modules/mod_ssl.so
</IfDefine>

# Near the bottom of httpd.conf you put the port 563 virtual host:

Listen 563

<VirtualHost *:563>

   # Allow proxy CONNECT requests *only* to port 5915.
   # If the machines use different ports, e.g. 5916 list them here as well:
   #
   ProxyRequests On
   AllowCONNECT 5915

   RewriteEngine On

   # Convenience rules to expand applet parameters.  These do not have a trailing "/"
   #
   # /vnc   for http jar file downloading:
   #
   RewriteRule /vnc/([^/]+)$               /vnc/$1/index.vnc?CONNECT=$1+5915&PORT=563&urlPrefix=_2F_vnc_2F_$1 [R,NE,L]
   RewriteRule /vnc/trust/([^/]+)$         /vnc/$1/index.vnc?CONNECT=$1+5915&PORT=563&urlPrefix=_2F_vnc_2F_$1&trustAllVncCerts=yes [R,NE,L]
   RewriteRule /vnc/proxy/([^/]+)$         /vnc/$1/proxy.vnc?CONNECT=$1+5915&PORT=563&urlPrefix=_2F_vnc_2F_$1&forceProxy=yes [R,NE,L]
   RewriteRule /vnc/trust/proxy/([^/]+)$   /vnc/$1/proxy.vnc?CONNECT=$1+5915&PORT=563&urlPrefix=_2F_vnc_2F_$1&forceProxy=yes&trustAllVncCerts=yes [R,NE,L]

   # Read in the allowed host to vnc display mapping file.  It looks like:
   #
   #   host1     15
   #   host2     15
   #   ...
   #
   # the display "15" means 5815 for http applet download, 5915 for SSL vnc.
   #
   RewriteMap vnchosts txt:/dist/apache/conf/vnc.hosts

   # Proxy: check for the CONNECT hostname and port being in the vnc.hosts list.
   # 
   RewriteCond %{THE_REQUEST} ^CONNECT [NC]
   RewriteCond %{REQUEST_URI} ^(.*):(.*)$
   RewriteCond ${vnchosts:%1|NOTFOUND} NOTFOUND
   RewriteRule ^.*$ /VNCFAIL [F,L]

   RewriteCond %{THE_REQUEST} ^CONNECT [NC]
   RewriteCond %{REQUEST_URI} ^(.*):(.*)$
   RewriteCond 59${vnchosts:%1}=%2 !^(.*)=(\1)$
   RewriteRule ^.*$ /VNCFAIL [F,L]

   # Remap /vnc to the proxy http download (e.g. http://host:5815)
   #
   # First, fail if it starts with the string /vnc0:
   #
   RewriteRule ^/vnc0.*            /VNCFAIL [F,L]
   #
   # Next, map the prefix to /vnc0/host:protocol:port
   #
   RewriteRule ^/vnc/([^/]+)/(.*)  /vnc0/$1:http:58${vnchosts:$1|NOTFOUND}/$2  [NE]
   #
   # Drop any not found:
   #
   RewriteRule ^/vnc0.*NOTFOUND.*  /VNCFAIL [F,L]

   # Construct the proxy URL and retrieve it:
   #
   RewriteRule ^/vnc0/([^/]+):([^/]+):([^/]+)/(.*) $2://$1:$3/$4 [P,NE,L]

</VirtualHost>

</pre>

Then restart apache (perhaps: "`apachectl stop; apachectl start`").

Note that the listing of allowed internal workstations is done in an external file (`/dist/apache/conf/vnc.hosts` in the example above), the format is like this:

<pre># allowed vnc hosts file:
hostname1  15
hostname2  15
...
</pre>

You list the hostname and the VNC display (always 15 in our example). Only to these hosts will the external VNC viewers be able to connect to (via the HTTP CONNECT method).

The above setup requires `mod_rewrite` and `mod_proxy` be enabled in the apache web server. In this example they are loaded as modules (and note that `mod_rewrite` must be listed before `mod_proxy`);

The user at the Java enabled Web browser would simply enter this URL into the browser:

<pre>   http://www.gateway.east:563/vnc/host2
</pre>

to connect to internal workstation `host2`, etc.

**Important:** do _not_ put a trailing "/" on the URL, since that will defeat the RewriteRules that look for the hostname at the very end.

There will be a number of SSL certificate, etc, dialogs he will have to respond to in addition to any passwords he is required to provide (this depends on how you set up user authentication for **x11vnc**).

If a second Web proxy is involved (i.e. the user's browser is inside another firewall and policy requires using a Web proxy server) then use this URL:

<pre>   http://www.gateway.east:563/vnc/proxy/host2
</pre>

This will involve downloading a signed java viewer applet jar file that is able to interact with the internal proxy for the VNC connection. See [this FAQ](faq.html#faq-ssl-java-viewer-proxy) for more info on how this works. _Note:_ sometimes with the Proxy case if you see 'Bad Gateway' error you will have to wait 10 or so seconds and then hit reload. This seems to be due to having to wait for a Connection Keepalive to terminate...

For completeness, the "trust" cases that skip a VNC certificate dialog (discussed below) would be entered as:

<pre>   http://www.gateway.east:563/vnc/trust/host2
   http://www.gateway.east:563/vnc/trust/proxy/host2
</pre>

You can of course choose shorter or more easy to remember URL formats. Just change the Convenience RewriteRules in `httpd.conf`.

<a name="port-variations"></a>

* * *

<a name="port-variations">**Port Variations:**

Note that _you can_ run this on the default HTTP port 80 instead of port 563. If you do not expect to have a browser connecting from inside a proxying firewall (where sometimes only connections to ports 443 and 563 are allowed) this should be fine. Use "80" instead of "563" in the `httpd.conf` config file (you may need to merge it with other default port 80 things you have there).

Then the URL's will be a bit simpler:

<pre>   http://www.gateway.east/vnc/host2
   http://www.gateway.east/vnc/trust/host2
</pre>

etc.

Besides 80 one could use any other random port number (since there are so many port scans on 80, a little obscurity might be useful).

One option is to use port "443" (the default https:// port) instead of "563". In this case Apache is _**not**_ configured for mod_ssl; we just happen to use port "443" in the way any random port would be used. This could be handy if the Viewer side environment is restrictive in that it only allows outgoing connections to ports 80 and 443 (and, say, you didn't want to use port 80, or you wanted to use 80 for something else). Another reason for using 443 would be some web proxy environments only allow the CONNECT method to go to port 443 (and not even the case 563 we use above).

* * *

**Details:**

Let's go through the `httpd.conf` additions in detail from the top.

The `LoadModules` directives load the necessary apache modules. Note that `mod_rewrite` must be listed first. If you are compiling from scratch something like this worked for us:

<pre>  ./configure --enable-proxy=shared --enable-proxy-connect=shared --enable-ssl=shared --enable-rewrite=shared --prefix=/dist/apache

</pre>

Then the `VirtualHost *:563` virtual host section starts.

The "`ProxyRequests On`" and "`AllowCONNECT 5915`" enable the web server to forward proxy requests to port 5915 (and only this port) _**INSIDE**_ the firewall. Think about the implications of this thoroughly and test it carefully.

The RewriteRule's are for convenience only so that the URL entered into the Web browser does not need the various extra parameters, e.g.:

<pre>   http://www.gateway.east:563/vnc/host2/index.vnc?CONNECT=host2+5915&PORT=563,blah,blah...
</pre>

(or otherwise make direct edits to `index.vnc` to set these parameters). The `forceProxy=yes` parameter is passed to the applet to force the use of a outgoing proxy socket connection. Use it only if the Web browser is inside a separate Web proxying environment (i.e. large corporation)</a>

<a name="port-variations">The rewrites with parameter `urlPrefix` are described under</a> [Tricks for Better Response](#tricks). The "trust" ones (also described under Tricks) with `trustAllVncCerts` tell the Java VNC applet to skip a dialog asking about the VNC Certificate. They are a bit faster and more reliable than the original method. In the best situation they lead to being logged in 20 seconds or less (without them the time to login can be much longer since a number of connections must timeout).

All of the x11vnc Java Viewer applet parameters are described in the file `classes/ssl/README`

The external file `/dist/apache/conf/vnc.hosts` containing the allowed VNC server hostnames is read in. Its 2nd column contains the VNC display of the host (always 15 in our example; if you make it vary you will need to adjust some lines in the `httpd.conf` accordingly, e.g. `AllowCONNECT`). This list is used to constrain both the Jar file download URL and the proxy CONNECT the VNC viewer makes to only the intended VNC servers.

Limiting the proxy CONNECT is done with the two sets of `RewriteCond` conditions.

Limiting the Jar file download URL is done in the remaining 4 `RewriteRule`'s.

Note that these `index.vnc` and `VncViewer.jar` downloads to the browser are _not_ encrypted via SSL, and so in principle could be tampered with by a really bad guy. The subsequent VNC connection, however, _is_ encrypted through a single SSL connection (it makes a CONNECT straight to **x11vnc**). [See below](#https-applet) for how to have these initial downloads encrypted as well (if the apache web server has SSL/mod_ssl, i.e. https, enabled and configured).

Unfortunately the Java VNC viewer applet currently is not able to save its own list of Certificates (e.g. the user says trust this VNC certificate 'always'). This is because an applet it cannot open local files, etc. Sadly, the applet cannot even remember certificates in the same browser session because it is completely reinitialized for each connection (see [below](#https-applet")).

* * *

**Too Much?**

If these apache rules are a little too much for you, there is a little bit [simpler scheme](ssl-portal-orig.html) where you have to list each of the individual machines in the `httpd.conf` and `ssl.conf` files. It may be a little more typing to maintain, but perhaps being more straight forward (less RewriteRule's) is desirable.

* * *

**Problems?**

To see example **x11vnc** output for a successful `https://host:5900/ `connection with the Java Applet see [This Page](ssl-output.html).``

``<a name="precautions"></a>``

* * *

``<a name="precautions">**Some Ideas for adding extra authentication, etc.** for the paranoid:</a>

<a name="precautions"></a>
*   <a name="precautions">VNC passwords:</a> [`-rfbauth`](x11vnc_opts.html#opt-rfbauth), [`-passwdfile`](x11vnc_opts.html#opt-passwdfile), or [`-usepw`](x11vnc_opts.html#opt-usepw). Even adding a simple company-wide VNC password helps block unwanted access.
*   Unix passwords: [`-unixpw`](x11vnc_opts.html#opt-unixpw)
*   SSL Client certificates: [`-sslverify`](x11vnc_opts.html#opt-sslverify)
*   Apache AuthUserFile directive: `.htaccess`, etc.
*   Filter connections based on IP address or hostname.
*   Use Port-knocking on your firewall as described in: [Enhanced TightVNC Viewer (ssvnc)](ssvnc.html).
*   Add proxy password authentication (requires Viewer changes?)
*   Run a separate instance of Apache that provides this VNC service so it can be brought up and down independently of the normal web server.
*   How secure is the Client side? Public machines in internet cafes, etc, are often hacked, with backdoors and VNC servers of their own. Prefer using your own firewalled laptop to a public machine.

* * *

**Using non-Java viewers with this scheme:**

The [ss_vncviewer](faq.html#ss_vncviewer) stunnel wrapper script for VNC viewers has the `-proxy` option that can take advantage of this method.

<pre>   ss_vncviewer -proxy www.gateway.east:563   host1:15
</pre>

For the case of the "double proxy" situation (see below) supply both separated by a comma.

<pre>   ss_vncviewer -proxy proxy1.foobar.com:8080,www.gateway.east:563   host1:15
</pre>

For the [Enhanced TightVNC Viewer (ssvnc)](ssvnc.html) GUI (it uses `ss_vncviewer` on Unix) put 'host1:15' into the 'VNC Server' entry box, and here are possible Proxy/Gateway entries

<pre>   Proxy/Gateway:   www.gateway.east:563
   Proxy/Gateway:   proxy1.foobar.com:8080,www.gateway.east:563
</pre>

then click on the 'Connect' button.

<a name="https-applet"></a>

<a name="https-applet"></a>

* * *

<a name="https-applet">**Downloading the Java applet to the browser via HTTPS:**</a>

<a name="https-applet">To have the Java applet downloaded to the user's Web Browser via an encrypted (and evidently safer) SSL connection the Apache webserver should be configured for SSL via</a> [mod_ssl](http://httpd.apache.org/docs/2.0/mod/mod_ssl.html).

`

`It is actually possible to use the **x11vnc** [Key Management utility](ssl.html)` ["](ssl.html)[`-sslGenCert`](x11vnc_opts.html#opt-sslGenCert)" to generate your Apache/SSL `.crt` and `.key` files. (In brief, run something like "`x11vnc -sslGenCert server self:apache`" then copy the resulting `self:apache.crt` file to `conf/ssl.crt/server.crt` and extract the private key part from `self:apache.pem` and paste it into `conf/ssl.key/server.key`). Setting the env var `REQ_ARGS='-days 1095'` before running **x11vnc** will bump up the expiration date (3 years in this case).

Or you can use the standard methods described in the [Apache `mod_ssl` documentation](http://httpd.apache.org/docs/2.0/ssl/ssl_faq.html#selfcert) to create your keys. Then restart Apache, usually something like "`apachectl stop`" followed by "`apachectl startssl`"

In addition to the above sections in `httpd.conf` one should add the following to `ssl.conf`:

<pre>   SSLProxyEngine  On

   RewriteEngine On

   # Convenience rules to expand applet parameters.  These do not have a trailing "/"
   #
   # /vnc   http jar file downloading:
   #
   RewriteRule /vnc/([^/]+)$                        /vnc/$1/index.vnc?CONNECT=$1+5915&PORT=563&httpsPort=443&GET=1&urlPrefix=_2F_vnc_2F_$1 [R,NE,L]
   RewriteRule /vnc/proxy/([^/]+)$                  /vnc/$1/proxy.vnc?CONNECT=$1+5915&PORT=563&httpsPort=443&GET=1&urlPrefix=_2F_vnc_2F_$1&forceProxy=yes [R,NE,L]
   #
   # (we skipped the "trust" ones above, put them in if you like)
   #
   # /vncs  https jar file downloading:
   #
   RewriteRule /vncs/([^/]+)$                      /vncs/$1/index.vnc?CONNECT=$1+5915&PORT=563&httpsPort=443&GET=1&urlPrefix=_2F_vncs_2F_$1 [R,NE,L]
   RewriteRule /vncs/proxy/([^/]+)$                /vncs/$1/proxy.vnc?CONNECT=$1+5915&PORT=563&httpsPort=443&GET=1&urlPrefix=_2F_vncs_2F_$1&forceProxy=yes [R,NE,l]
   RewriteRule /vncs/trust/([^/]+)$                /vncs/$1/index.vnc?CONNECT=$1+5915&PORT=563&httpsPort=443&GET=1&urlPrefix=_2F_vncs_2F_$1&trustAllVncCerts=yes [R,NE,L]
   RewriteRule /vncs/trust/proxy/([^/]+)$          /vncs/$1/proxy.vnc?CONNECT=$1+5915&PORT=563&httpsPort=443&GET=1&urlPrefix=_2F_vncs_2F_$1&forceProxy=yes&trustAllVncCerts=yes [R,NE,L]

   # Convenience rules used for the connect_switch helper (requires Listen 127.0.0.1:443 above):
   #
   RewriteRule /vnc443/([^/]+)$                    /vncs/$1/index.vnc?CONNECT=$1+5915&PORT=443&httpsPort=443&GET=1&urlPrefix=_2F_vncs_2F_$1 [R,NE,L]
   RewriteRule /vnc443/proxy/([^/]+)$              /vncs/$1/proxy.vnc?CONNECT=$1+5915&PORT=443&httpsPort=443&GET=1&urlPrefix=_2F_vncs_2F_$1&forceProxy=yes [R,NE,L]
   RewriteRule /vnc443/trust/([^/]+)$              /vncs/$1/index.vnc?CONNECT=$1+5915&PORT=443&httpsPort=443&GET=1&urlPrefix=_2F_vncs_2F_$1&trustAllVncCerts=yes [R,NE,L]
   RewriteRule /vnc443/trust/proxy/([^/]+)$        /vncs/$1/proxy.vnc?CONNECT=$1+5915&PORT=443&httpsPort=443&GET=1&urlPrefix=_2F_vncs_2F_$1&forceProxy=yes&trustAllVncCerts=yes [R,NE,L]

   # Read in the allowed host to vnc display mapping file.  It looks like:
   #
   #   host1     15
   #   host2     15
   #   ...
   #
   # the display "15" means 5915 for SSL VNC and 5815 for http applet download.
   #
   RewriteMap vnchosts txt:/dist/apache/conf/vnc.hosts

   # Remap /vnc and /vncs to the proxy http download (e.g. https://host:5915)
   #
   # First, fail if it starts with the string /vnc0:
   #
   RewriteRule ^/vnc0.*            /VNCFAIL [F,L]
   #
   # Next, map the prefix to /vnc0:host:protocol:port
   #
   RewriteRule ^/vnc/([^/]+)/(.*)  /vnc0/$1:http:58${vnchosts:$1|NOTFOUND}/$2  [NE]
   RewriteRule ^/vncs/([^/]+)/(.*) /vnc0/$1:https:59${vnchosts:$1|NOTFOUND}/$2 [NE]
   #
   # Drop any not found:
   #
   RewriteRule ^/vnc0.*NOTFOUND.*  /VNCFAIL [F,L]

   # Construct the proxy URL and retrieve it:
   #
   RewriteRule ^/vnc0/([^/]+):([^/]+):([^/]+)/(.*) $2://$1:$3/$4 [P,NE,L]

</pre>

This is all in the "`<VirtualHost _default_:443>`" section of `ssl.conf`.

The user could then point the Web Browser to:

<pre>   https://www.gateway.east/vnc/host2
</pre>

or

<pre>   https://www.gateway.east/vnc/proxy/host2
</pre>

for the "double proxy" case. (**Important:** do _not_ put a trailing "/" on the URL, since that will defeat the RewriteRules.)

As with the `httpd.conf` case, the external file (`/dist/apache/conf/vnc.hosts` in the above example) contains the hostnames of the allowed VNC servers.

Note that _inside_ the firewall the Java applet download traffic is not encrypted (only over the Internet is SSL used) for these cases:

<pre>   https://www.gateway.east/vnc/host2
   https://www.gateway.east/vnc/proxy/host2
</pre>

However for the special "vncs" rules above:

<pre>   https://www.gateway.east/vncs/host2
</pre>

the Java applet download _is_ encrypted via SSL for both legs. Note that the two legs are two _separate_ SSL sessions. So the data is decrypted inside an apache process and reencrypted by the apache process for the 2nd SSL session inside the same apache process (a very small gap one might overlook).

The "vncs/trust" ones are like the "trust" ones described earlier

<pre>   https://www.gateway.east/vncs/trust/mach2
</pre>

and similarly for the `httpsPort` ones. See [Tricks for Better Response](#tricks).

In all of the above cases the _**VNC**_ traffic from Viewer to **x11vnc** is encrypted end-to-end in a single SSL session, even for the "double proxy" case because the CONNECT method is used (there are actually two CONNECT's for the "double proxy" case). This part (the VNC traffic) is the most important part to have encrypted.

Note that the Certificate dialogs the user has in his web browser will be for the Apache Certificate, while for the Java applet it will be the **x11vnc** certificate.

Note also that you can have Apache serve up the Jar file `VncViewer.jar` and/or `index.vnc`/`proxy.vnc` instead of each **x11vnc** if you want to.

The rules in `ssl.conf` are similar to the ones in `httpd.conf` and so are not discussed in detail. The only really new thing is the `/vncs` handling to download the applet jar via HTTPS on port 5915.

The special entries "`/vnc443`" are only used for the special helper program (`connect_switch`) for the https port 443 only mode [discussed here](ssl-single-443.html).

<a name="inetd"></a>

* * *

<a name="inetd">**INETD automation:**

The "single-port" (i.e. 5915) HTTPS applet download and VNC connection aspect shown here is convenient and also enables having **x11vnc** run out of `inetd`. That way **x11vnc** is run on demand instead of being run all the time (the user does not have to remember to start it). The first connections to `inetd` download `index.vnc` and the Jar file (via https) and the the last connection to `inetd` establishes the SSL VNC connection. Since **x11vnc** is restarted for each connection, this will be a bit slower than the normal process.

For example, the `/etc/inetd.conf` line could be:

<pre>  5915 stream tcp nowait root /usr/sbin/tcpd /usr/local/bin/x11vnc_ssl.sh
</pre>

where the script `x11vnc_ssl.sh` looks something like this:

<pre>#!/bin/sh

/usr/local/bin/x11vnc -inetd -oa /var/log/x11vnc-15.log \
        -ssl SAVE -http -unixpw -localhost \
        -display :0 -auth /home/THE_USER/.Xauthority
</pre>

where, as usual, the `inetd` launching needs to know which user is typically using the display on that machine. One could imagine giving different users different ports, 5915, 5916, etc. to distinguish (then the script would need to be passed the username). mod_rewrite could be used to automatically map username in the URL to his port number.

_**A better way**_ is to use the "`-display WAIT:cmd=FINDDISPLAY`" feature to autodetect the user and Xauthority data:

<pre>#!/bin/sh

/usr/local/bin/x11vnc -inetd -oa /var/log/x11vnc-15.log \
        -ssl SAVE -http -unixpw -localhost -users unixpw= \
        -find
</pre>

(we have used the alias</a> [-find](x11vnc_opts.html#opt-find) for "`-display WAIT:cmd=FINDDISPLAY`".) This way the user must supply his Unix username and password and then his display and Xauthority data on that machine will be located and returned to **x11vnc** to allow it to attach. If he doesn't have a display running on that machine or he fails to log in correctly, the connection will be dropped.

The variant "[`-display WAIT:cmd=FINDCREATEDISPLAY`](x11vnc_opts.html#opt-display_WAIT)" (aliased by "[-create](x11vnc_opts.html#opt-create)") will actually create a (virtual or real) X server session for the user if one doesn't already exist. See [`here for details`](faq.html#faq-userlogin).

To enable inetd operation for the non-HTTPS Java viewer download (port 5815 in the above httpd.conf example) you will need to run **x11vnc** in HTTPONCE mode on port 5815: For example, the `/etc/inetd.conf` line could be:

<pre>  5815 stream tcp nowait root /usr/sbin/tcpd /usr/local/bin/x11vnc \
       -inetd -prog /usr/local/bin/x11vnc -oa /var/log/x11vnc-15.log \
       -http_ssl -display WAIT:cmd=HTTPONCE
</pre>

where the long `inetd.conf` line has been split. Note how the [`-http_ssl`](x11vnc_opts.html#opt-http_ssl) tries to automatically find the `.../classes/ssl` subdirectory. This requires the [`-prog`](x11vnc_opts.html#opt-prog) option available in **x11vnc** 0.8.4 (a shell script wrapper, e.g. `/usr/local/bin/x11vnc_http.sh` can be used to work around this).

Also note the use of "`-ssl SAVE`" above. This way a saved `server.pem` is used for each inetd invocation (rather generating a new one each time as happens for "`-ssl TMP`"). Note that it cannot have a protecting passphrase because inetd will not be able to supply it.

Another option is:

<pre>  5815 stream tcp nowait root /usr/sbin/tcpd /usr/local/bin/x11vnc \
       -inetd -httpdir /usr/local/share/x11vnc/classes/ssl \
       -oa /var/log/x11vnc-15.log -display WAIT:cmd=HTTPONCE
</pre>

(this also requires a feature found in **x11vnc** 0.8.4).  

* * *

<a name="no-apache">**Other Ideas:**

- The above schemes work, but they are a bit complicated with all of the rigging. There should be more elegant ways to configure Apache to do these, but we have not found them (please let us know if you discover something nice). However, once this scheme has been set up and is working it is easy to maintain and add/delete workstations, etc.

- In general Apache is not required, but it makes things convenient. The firewall itself could do the port redirection via its firewall rules. Evidently different Internet-facing ports would be required for each workstation. This could be set up using `iptables` rules for example. If there were just one or two machines this would be the easiest method. For example:

<pre>  iptables -t nat -A PREROUTING -p tcp -d 24.35.46.57 --dport 5901 -j DNAT --to-destination 192.168.1.2:5915
  iptables -t nat -A PREROUTING -p tcp -d 24.35.46.57 --dport 5902 -j DNAT --to-destination 192.168.1.3:5915
</pre>

Where `24.35.46.57` is the internet IP address of the gateway. In this example `24.35.46.57:5901` is redirected to the internal machine `192.168.1.2:5915` and `24.35.46.57:5902` is redirected to another internal machine `192.168.1.3:5915`, both running `x11vnc -ssl ...` in SSL mode. For this example, the user would point the web browser to, e.g.:

<pre>  https://24.35.46.57:5901/?PORT=5901
</pre>

or using the stunnel wrapper script:

<pre>  ss_vncviewer 24.35.46.57:1
</pre>

One can achieve similar things with dedicated firewall/routers (e.g. Linksys) using the device's web or other interface to configure the firewall.

If the user may be coming out of a firewall using a proxy it may be better to redirect ports 443 and 563 (instead of 5901 and 5902) to the internal machines so that the user's proxy will allow CONNECTing to them.

</a>

<a name="no-apache">- The redirection could also be done at the application level using a TCP redirect program (e.g. ip_relay or fancier ones). Evidently more careful internal hostname checking, etc., could be performed by the special purpose application to add security. See</a> [connect_switch](ssl-single-443.html) which is somewhat related.

- One might imagine the `ProxyPass` could be done for the VNC traffic as well (for the `ssl.conf` case) to avoid the CONNECT proxying completely (which would be nice to avoid). Unfortunately we were not able to get this to work. Since HTTP is a request-response protocol (as opposed to a full bidirectional link required by VNC that CONNECT provides) this makes it difficult to do. It may be possible, but we haven't found out how yet.

All of the x11vnc Java Viewer applet parameters are described in the file `classes/ssl/README`

<a name="tricks"></a>

* * *

<a name="tricks">**Tricks for Better Response and reliability:**

The "original scheme" using `httpd.conf` and `ssl.conf` rewrites without `urlPrefix` and `trustAllVncCerts` above should work OK, but may lead to slow and/or unreliable loading of the applet and final connection to **x11vnc**. The following are what I do now to get better response and reliability. YMMV.

The problem with the "original scheme" is that there is a point where the VNC Viewer applet can try up to 3 times to retrieve the **x11vnc** certificate, since it needs to get it to show it to you and ask you if you accept it. This can add about 45 seconds to the whole process (which takes 1 to 1.5 minutes with all the dialogs) since a couple of those connections must time out. The "trust" items in the config add a parameter `trustAllVncCerts=yes` similar to the `forceProxy=yes` parameter. This can cut the total time to the VNC password prompt down to 15 seconds which is pretty good. (Note by ignoring the certificate this does not protect against man-in-the-middle attacks which are rare, but maybe the won't be so rare in the future... see dsniff/webmitm and cain)

First make sure the **x11vnc** SSL certificate+key is the same as Apache's. (otherwise you may get one extra dialog and/or one extra connection that has to time out).

The following RewriteRule's are the same now advocated in the instructions above.

The `httpsPort` and `urlPrefix=` parameters give hints to the applet to improve connecting: This is what goes in `httpd.conf`:

<pre>   RewriteEngine On
   RewriteRule /vnc/([^/]+)$               /vnc/$1/index.vnc?CONNECT=$1+5915&PORT=563&urlPrefix=_2F_vnc_2F_$1 [R,NE]
   RewriteRule /vnc/trust/([^/]+)$         /vnc/$1/index.vnc?CONNECT=$1+5915&PORT=563&urlPrefix=_2F_vnc_2F_$1&trustAllVncCerts=yes [R,NE]
   RewriteRule /vnc/proxy/([^/]+)$         /vnc/$1/proxy.vnc?CONNECT=$1+5915&PORT=563&urlPrefix=_2F_vnc_2F_$1&forceProxy=yes [R,NE]
   RewriteRule /vnc/trust/proxy/([^/]+)$   /vnc/$1/proxy.vnc?CONNECT=$1+5915&PORT=563&urlPrefix=_2F_vnc_2F_$1&forceProxy=yes&trustAllVncCerts=yes [R,NE]
</pre>

The httpsPort and urlPrefix provide useful hints to the VNC Viewer applet when it connects to **x11vnc** to glean information about Proxies, certificates, etc.

This is what goes into `ssl.conf`:

<pre>   RewriteEngine On
   RewriteRule /vnc/([^/]+)$                /vnc/$1/index.vnc?CONNECT=$1+5915&PORT=563&httpsPort=443&GET=1&urlPrefix=_2F_vnc_2F_$1 [R,NE]
   RewriteRule /vnc/proxy/([^/]+)$          /vnc/$1/proxy.vnc?CONNECT=$1+5915&PORT=563&httpsPort=443&GET=1&urlPrefix=_2F_vnc_2F_$1&forceProxy=yes [R,NE]
   RewriteRule /vncs/([^/]+)$              /vncs/$1/index.vnc?CONNECT=$1+5915&PORT=563&httpsPort=443&GET=1&urlPrefix=_2F_vncs_2F_$1 [R,NE]
   RewriteRule /vncs/proxy/([^/]+)$        /vncs/$1/proxy.vnc?CONNECT=$1+5915&PORT=563&httpsPort=443&GET=1&urlPrefix=_2F_vncs_2F_$1&forceProxy=yes [R,NE]
   RewriteRule /vncs/trust/([^/]+)$        /vncs/$1/index.vnc?CONNECT=$1+5915&PORT=563&httpsPort=443&GET=1&urlPrefix=_2F_vncs_2F_$1&trustAllVncCerts=yes [R,NE]
   RewriteRule /vncs/trust/proxy/([^/]+)$  /vncs/$1/proxy.vnc?CONNECT=$1+5915&PORT=563&httpsPort=443&GET=1&urlPrefix=_2F_vncs_2F_$1&forceProxy=yes&trustAllVncCerts=yes [R,NE]
</pre>

The rest is the same.

The httpsPort and urlPrefix and GET provide useful hints to the VNC Viewer applet when it connects to **x11vnc** to glean information about Proxies, certificates, etc, and also for the ultimate VNC connection (GET speeds this up by sending a special HTTP GET to cause **x11vnc** to immediately switch to the VNC protocol).

To turn these into URLs, as was done above, take the string in the RewriteRule, e.g. `/vncs` and turn it into `https://gateway/vncs/machinename` Similarly for non-https: `http://gateway:563/vnc/machinename`

If you use the 'trust' ones, you are performing _NO_ checks, visual or otherwise, on the VNC SSL certificate. It is trusted without question. This speeds things up because it avoids a dialog about certificates, but of course has some risk WRT Man in the Middle attacks. I don't recommend them. It is better to use `/vnc` or `/vncs` and the first time you connect carefully check the Certificate and then tell your Browser and Java Virtual Machine to trust the certificate 'Always'. Then if you later get an unexpected dialog, you know something is wrong. Nearly always it is just a changed or expired certificate, but better safe than sorry...

</a>`

-----
http://www.karlrunge.com/x11vnc/enhanced_tightvnc_viewer.html:

* * *

## Enhanced TightVNC Viewer   (SSVNC:   SSL/SSH VNC viewer)

[(To Downloads)](#download)  [(To Quick Start)](#quickstart)

![](ssvnc.gif) ![](ssvnc_windows.gif) ![](ssvnc_macosx.gif) <font color="white">[.](admwtp.html) [.](http://cell.runges.net/b.w)</font> 

The Enhanced TightVNC Viewer, SSVNC, adds encryption security to VNC connections.

The package provides a GUI for Windows, Mac OS X, and Unix that automatically starts up an STUNNEL SSL tunnel for SSL or ssh/plink for SSH connections to any VNC server, such as [**x11vnc**](index.html), and then launches the VNC Viewer to use the encrypted tunnel.

The x11vnc server has built-in SSL support, however SSVNC can make SSL encrypted VNC connections to _any_ VNC Server if they are running an SSL tunnel, such as STUNNEL or socat, at their end. SSVNC's SSH tunnel will work to _any_ VNC Server host running sshd that you can log into.

The Enhanced TightVNC Viewer package started as a project to add some patches to the long neglected Unix TightVNC Viewer. However, now the front-end GUI, encryption, and wrapper scripts features possibly outweigh the Unix TightVNC Viewer improvements (see the lists below to compare).

The SSVNC Unix vncviewer can also be run without the SSVNC encryption GUI as an enhanced replacement for the `xvncviewer`, `xtightvncviewer`, etc., viewers.

In addition to normal SSL, SSVNC also supports the [VeNCrypt](http://sourceforge.net/projects/vencrypt/) SSL/TLS and Vino/ANONTLS encryption extensions to VNC on Unix, Mac OS X, and Windows. Via the provided SSVNC VeNCrypt bridge, VeNCrypt and ANONTLS encryption also works with _**any**_ third party VNC Viewer (e.g. RealVNC, TightVNC, UltraVNC, etc...) you select via 'Change VNC Viewer'.

The short name for this project is "**ssvnc**" for SSL/SSH VNC Viewer. This is the name of the command to start it.

There is a simplified [SSH-Only](#sshvnc) mode (`sshvnc`). And an even more simplified [Terminal-Services](#tsvnc) mode (`tsvnc`) for use with **x11vnc** on the remote side.

The tool has many additional features; see the descriptions below.

It is a self-contained bundle, you could carry it around on, say, a [USB memory stick / flash drive](#memory-stick) for secure VNC viewing from almost any machine, Unix, Mac OS X, and Windows (and if you create a directory named "Home" in the toplevel ssvnc directory on the drive your VNC profiles and certs will be kept there as well). For Unix, there is also a [conventional source tarball](#source) to build and install in the normal way and not use a pre-built bundle.

* * *

<a name="announcements">#### Announcements:

**<font color="bisque4">Important:</font>** If you created any SSL certificates with SSVNC (or anything else) on a Debian or Ubuntu system from Sept. 2006 through May 2008, then those keys are likely extremely weak and can be easily cracked. The certificate files should be deleted and recreated on a non-Debian system or an updated one. See</a> [http://www.debian.org/security/2008/dsa-1571](http://www.debian.org/security/2008/dsa-1571) for details. The same applies to SSH keys.

Please read this information on using SSVNC on workstations with [Untrusted Local Users](ssvnc_untrusted_local_users.html).

* * *

#### Feature List:

Wrapper scripts and a tcl/tk GUI were written to create these features for Unix, Mac OS X, and Windows:

*   SSL support for connections using the bundled stunnel program.
*   Automatic SSH connections from the GUI (system ssh is used on Unix and MacOS X; bundled plink is used on Windows)
*   Ability to Save and Load VNC profiles for different hosts.
*   You can also use your own VNC Viewer, e.g. UltraVNC or RealVNC, with the SSVNC encryption GUI front-end if you prefer.
*   Create or Import SSL Certificates and Private Keys.
*   Reverse (viewer listening) VNC connections via SSL and SSH.
*   VeNCrypt SSL/TLS VNC encryption support (used by [VeNCrypt](http://sourceforge.net/projects/vencrypt/), QEMU, ggi, libvirt/virt-manager/xen, vinagre/gvncviewer/gtk-vnc)
*   ANONTLS SSL/TLS VNC encryption support (used by Vino)
*   VeNCrypt and ANONTLS are also enabled for _any_ 3rd party VNC Viewer (e.g. RealVNC, TightVNC, UltraVNC ...) on Unix, MacOSX, and Windows via the provided SSVNC VeNCrypt Viewer Bridge tool (use 'Change VNC Viewer' to select the one you want.)
*   Support for Web [Proxies](ssvnc-proxies.html), SOCKS Proxies, and the [UltraVNC repeater proxy](http://www.uvnc.com/addons/repeater.html) (e.g. `repeater://host:port+ID:1234`). Multiple proxies may be chained together (3 max).
*   Support for SSH Gateway connections and non-standard SSH ports.
*   Automatic Service tunnelling via SSH for CUPS and SMB Printing, ESD/ARTSD Audio, and SMB (Windows/Samba) filesystem mounting.
*   Sets up any additional SSH port redirections that you want.
*   Zeroconf (aka Bonjour) is used on Unix and Mac OS X to find VNC servers on your local network if the `avahi-browse` or `dns-sd` program is available and in your PATH.
*   Port Knocking for "closed port" SSH/SSL connections. In addition to a simple fixed port sequence and one-time-pad implementation, a hook is also provided to run any port knocking client before connecting.
*   Support for native MacOS X usage with bundled Chicken of the VNC viewer (the Unix X11 viewer is also provided for MacOS X, and is better IMHO. It is now the default on MacOS X.)
*   [Dynamic VNC Server Port determination](#dynamic-port) and redirection (using ssh's builtin SOCKS proxy, `ssh -D`) for servers like x11vnc that print out PORT= at startup.
*   Unix Username and Password entry for use with "`x11vnc -unixpw`" type login dialogs.
*   Simplified mode launched by command "[sshvnc](#sshvnc)" that is SSH Only.
*   Simplified mode launched by command "[tsvnc](#tsvnc)" that provides a VNC "Terminal Services" mode (uses x11vnc on the remote side).
*   IPv6 support for all connection modes on Unix, MacOSX, and Windows.

Patches to TightVNC 1.3.9 vnc_unixsrc tree were created for [Unix TightVNC Viewer improvements](#unix-patches) (these only apply to the **Unix** VNC viewer, including MacOSX XQuartz):

*   rfbNewFBSize VNC support (dynamic screen resizing)
*   Client-side Scaling of the Desktop in the viewer.
*   ZRLE VNC encoding support (RealVNC's encoding)
*   Support for the ZYWRLE encoding, a wavelet based extension to ZRLE to improve compression of motion video and photo regions.
*   [TurboVNC](faq.html#faq-turbovnc) support ([VirtualGL](http://www.virtualgl.org/)'s modified TightVNC encoding; requires TurboJPEG library)
*   Pipelined Updates of the framebuffer as in TurboVNC (asks for the next update before the current one has finished downloading; this gives some speedup on high latency connections.)
*   Cursor [alphablending](faq.html#faq-xfixes-alpha-hacks) with x11vnc at 32bpp (`-alpha` option)
*   Option "`-unixpw ...`" for use with "`x11vnc -unixpw`" type login dialogs.
*   Support for UltraVNC extensions: 1/n Server side scaling, Text Chat, Single Window, Disable Server-side Input. Both UltraVNC and **x11vnc** servers support these extensions.
*   UltraVNC File Transfer via an auxiliary Java helper program (`java` must be in `$PATH`). Note that the **x11vnc** server also supports UltraVNC file transfer.
*   Connection support for the [UltraVNC repeater proxy](http://www.uvnc.com/addons/repeater.html) (`-repeater` option).
*   Support for UltraVNC [Single Click](http://www.uvnc.com/addons/singleclick.html) operation. (both unencrypted: SC I, and SSL encrypted: SC III)
*   Support for UltraVNC [DSM Encryption Plugin](http://www.uvnc.com/features/encryption.html) symmetric encryption mode. (ARC4, AESV2, MSRC4, and SecureVNC)
*   Support for UltraVNC [MS-Logon](http://www.uvnc.com/features/authentication.html) authentication (**NOTE:** the UltraVNC MS-Logon key exchange implementation is very weak; an eavesdropper on the network can recover your Windows password easily in a few seconds; you need to use an additional encrypted tunnel with MS-Logon.)
*   Support for symmetric encryption (including blowfish and 3des ciphers) to Non-UltraVNC Servers. Any server using the same encryption method will work, [e.g.:](x11vnc_opts.html#opt-enc)  `x11vnc -enc blowfish:./my.key`
*   Instead of `hostname:display` one can also supply "`exec=command args...`" to connect the viewer to the stdio of an external command (e.g. `stunnel` or `socat`) rather than using a TCP/IP socket. Unix domain sockets, e.g. `/path/to/unix/socket`, and a previously opened file descriptor `fd=0`, work too.
*   Local Port Protections for STUNNEL and SSH: avoid having for long periods of time a listening port on the the local (VNC viewer) side that redirects to the remote side.
*   Reverse (viewer listening) VNC connections can show a Popup dialog asking whether to accept the connection or not (`-acceptpopup`.) The extra info provided by UltraVNC Single Click reverse connections is also supported (`-acceptpopupsc`)
*   Extremely low color modes: 64 and 8 colors in 8bpp (`-use64`/`-bgr222`, `-use8`/`-bgr111`)
*   Medium color mode: 16bpp mode on a 32bpp Viewer display (`-16bpp`/`-bgr565`)
*   For use with x11vnc's [client-side caching](faq.html#faq-client-caching) `-ncache` method use the cropping option `-ycrop n`. This will "hide" the large pixel buffer cache below the actual display. Set to the actual height or use -1 for autodetection (also, tall screens, H > 2*W, are autodetected by default).
*   Escape Keys: specify a set of modifier keys so that when they are all pressed down you can invoke Popup menu actions via keystrokes. I.e., a set of 'Hot Keys'. One can also pan (move) the desktop inside the viewport via Arrow keys or a mouse drag.
*   Scrollbar width setting: `-sbwidth n`, the default is very thin, 2 pixels, for less distracting `-ycrop` usage.
*   Selection text sending and receiving can be fine-tuned with the -sendclipboard, -sendalways, and -recvtext options.
*   TightVNC compression and quality levels are automatically set based on observed network latency (n.b. not bandwidth.)
*   Improvements to the [Popup menu](#popup), all of these can now be changed dynamically via the menu: ViewOnly, Toggle Bell, CursorShape updates, X11 Cursor, Cursor Alphablending, Toggle Tight/ZRLE, Toggle JPEG, FullColor/16bpp/8bpp (256/64/8 colors), Greyscale for low color modes, Scaling the Viewer resolution, Escape Keys, Pipeline Updates, and others, including UltraVNC extensions.
*   Maintains its own BackingStore if the X server does not.
*   The default for `localhost:0` connections is not raw encoding since same-machine connections are pretty rare. Default assumes you are using a SSL or SSH tunnel. Use `-rawlocal` to revert.
*   XGrabServer support for fullscreen mode, for old window managers (`-grab`/`-graball` option).
*   Fix for Popup menu positioning for old window managers (`-popupfix` option).
*   The VNC Viewer `ssvncviewer` supports IPv6 natively (no helpers needed.)

The list of 3rd party software bundled in the archive files:

*   TightVNC Viewer  (windows, unix, macosx)
*   Chicken of the VNC Viewer  (macosx)
*   Stunnel  (windows, unix, macosx)
*   Putty/Plink/Pageant  (windows)
*   OpenSSL  (windows)
*   esound  (windows)

These are all self-contained in the bundle directory: they will not be installed on your system. Just un-zip or un-tar the file you downloaded and run the frontend `ssvnc` straight from its directory. Alternatively, on Unix you can use the [conventional source tarball](#source).

<a name="quickstart"> 
</a>

* * *

<a name="quickstart">Here is the **_Quick Start_** info from the README for how to setup and use SSVNC:

<pre>Quick Start:
-----------

Unix and Mac OS X:

    Inside a Terminal do something like the following.

    Unpack the archive:

        % gzip -dc ssvnc-1.0.30.tar.gz | tar xvf -

    Run the GUI:

        % ./ssvnc/Unix/ssvnc               (for Unix)

        % ./ssvnc/MacOSX/ssvnc             (for Mac OS X)

    The smaller file "ssvnc_no_windows-1.0.30.tar.gz"
    could have been used as well.

    On MacOSX you could also click on the SSVNC app icon in the Finder.

    On MacOSX if you don't like the Chicken of the VNC (e.g. no local
    cursors, no screen size rescaling, and no password prompting), and you
    have the XDarwin X server installed, you can set DISPLAY before starting
    ssvnc (or type DISPLAY=... in Host:Disp and hit Return).  Then our
    enhanced TightVNC viewer will be used instead of COTVNC.
    Update: there is now a 'Use X11 vncviewer on MacOSX' under Options ...

    If you want a SSH-only tool (without the distractions of SSL) run
    the command: 

                sshvnc

    instead of "ssvnc".  Or click "SSH-Only Mode" under Options.
    Control-h will toggle between the two modes.

    If you want a simple VNC Terminal Services only mode (requires x11vnc
    on the remote server) run the command:

                tsvnc

    instead of "ssvnc".  Or click "Terminal Services" under Options.
    Control-t will toggle between the two modes.

    "tsvnc profile-name" and "tsvnc user@hostname" work too.

Unix/MacOSX Install:

    There is no standard install for the bundles, but you can make
    symlinks like so:

        cd /a/directory/in/PATH
        ln -s /path/to/ssvnc/bin/{s,t}* .

    Or put /path/to/ssvnc/bin, /path/to/ssvnc/Unix, or /path/to/ssvnc/MacOSX
    in your PATH.

    For the conventional source tarball it will compile and install, e.g.:

       gzip -dc ssvnc-1.0.30.src.tar.gz | tar xvf -
       cd ssvnc-1.0.30
       make config
       make all
       make PREFIX=/my/install/dir install

    then have /my/install/dir/bin in your PATH.

Windows:

    Unzip, using WinZip or a similar utility, the zip file:

        ssvnc-1.0.30.zip

    Run the GUI, e.g.:

        Start -> Run -> Browse

    and then navigate to

        .../ssvnc/Windows/ssvnc.exe

    select Open, and then OK to launch it.

    The smaller file "ssvnc_windows_only-1.0.30.zip"
    could have been used as well.

    You can make a Windows shortcut to this program if you want to.

    See the Windows/README.txt for more info.

    If you want a SSH-only tool (without the distractions of SSL) run
    the command:

                sshvnc.bat

    Or click "SSH-Only Mode" under Options.

    If you want a simple VNC Terminal Services only mode (requires x11vnc
    on the remote server) run the command:

                tsvnc.bat

    Or click "Terminal Services" under Options.  Control-t will toggle
    between the two modes.  "tsvnc profile-name" and "tsvnc user@hostname"
    work too.
</pre>

* * *

</a>

<a name="quickstart">You can read all of the SSVNC GUI's</a> [Online Help Text here](ssvnc_help.html).  

* * *

The bundle unpacks a directory/folder named: `ssvnc`. It contains these programs to launch the GUI:

<pre>	Windows/ssvnc.exe        for Windows
	MacOSX/ssvnc             for Mac OS X
	Unix/ssvnc               for Unix
</pre>

(the Mac OS X and Unix launchers are simply links to the `bin` directory). See the README for more information.

The [SSH-Only mode](#sshvnc) launcher program has name `sshvnc`. The [Terminal Services mode](#tsvnc) launcher program (assumes **x11vnc** 0.8.4 or later and **Xvfb** installed on the server machine) has name `tsvnc`.

The Viewer SSL support is done via a wrapper script (`bin/ssvnc_cmd` that calls `bin/util/ss_vncviewer`) that starts up the STUNNEL tunnel first and then starts the TightVNC viewer pointed at that tunnel. The `bin/ssvnc` program is a GUI front-end to that script. See [this FAQ](faq.html#faq-ssl-tunnel-ext) for more details on SSL tunnelling. In SSH connection mode, the wrappers start up SSH appropriately.

<a name="memory-stick"> 
_**Memory Stick Usage:**_ If you create a directory named "`Home`" in that toplevel `ssvnc` directory then that will be used as the base for storing VNC profiles and certificates. Also, for convenience, if you first run the command with "." as an argument (e.g. "`ssvnc .`") it will automatically create the "Home" directory for you. This is handy if you want to place SSVNC on a USB flash drive that you carry around for mobile use and you want the profiles you create to stay with the drive (otherwise you'd have to browse to the drive directory each time you load or save).</a>

<a name="memory-stick">One user on Windows created a BAT file to launch SSVNC and needed to do this to get the Home directory correct:</a>

<pre><a name="memory-stick">cd \ssvnc\Windows
start \ssvnc\Windows\ssvnc.exe</a> </pre>

<a name="memory-stick">(an optional profile name can be supplied to the ssvnc.exe line)

WARNING: if you use ssvnc from an "Internet Cafe", i.e. some untrusted computer, please be aware that someone may have set up that machine to be capturing your keystrokes, etc.

</a>

<a name="memory-stick"></a><a name="sshvnc"> 
_**SSH-Only version:**_ The command "`sshvnc`" can be run instead of "`ssvnc`" to get an SSH-only version of the tool:</a>

<a name="sshvnc">![](sshvnc.gif)</a>

<a name="sshvnc">These also work: "`sshvnc myprofile`" and "`sshvnc user@hostname`". To switch from the regular SSVNC mode, click "SSH-Only Mode" under Options. This mode is less distracting if you never plan to use SSL, manage certificates, etc.</a>

<a name="sshvnc"></a><a name="tsvnc"> 
_**Terminal Services Only:**_ The command "`tsvnc`" can be run instead of "`ssvnc`" to get a "Terminal Services" only version of the tool:</a>

<a name="tsvnc">![](tsvnc.gif)</a>

<a name="tsvnc">These also work: "`tsvnc myprofile`" and "`tsvnc user@hostname`". To switch from the regular SSVNC mode, click "Terminal Services" under Options.</a>

<a name="tsvnc">This mode requires</a> [x11vnc](index.html) (0.9.3 or later) installed on the remote machine to find, create, and manage the user sessions. SSH is used to create the encrypted and authenticated tunnel. The **Xvfb** (virtual framebuffer X server) program must also be installed on the remote system. However `tsvnc` will **_also_** connect to a real X session (i.e. on the physical hardware) if you are already logged into the X session; this is a useful access mode and _does not_ require **Xvfb** on the remote system.

This mode should be very easy for beginner users to understand and use. On the remote end you only need to have `x11vnc` and `Xvfb` available in $PATH, and on the local end you just run something like:

<pre>   tsvnc myname@myhost.com
</pre>

(or start up the `tsvnc` GUI first and then enter `myname@myhost.com` and press "Connect").

Normally the Terminal Services sessions created are virtual (RAM-only) ones (e.g. Xvfb, [Xdummy](faq.html#faq-xvfb), or Xvnc), however a nice feature is if you have a _regular_ X session (i.e displaying on the physical hardware) on the remote machine that you are _ALREADY_ logged into, then the **x11vnc** run from `tsvnc` will find it for you as well.

Also, there is setting "X Login" under Advanced Options that allows you to attach to a real X server with no one logged in yet (i.e. XDM/GDM/KDM Login Greeter screen) as long as you have sudo(1) permission on the remote machine.

Nice features to soon to be added to the tsvnc mode are easy CUPS printing (working fairly well) and Sound redirection (needs much work) of the Terminal Services Desktop session. It is easier in tsvnc mode because the entire desktop session can be started with the correct environment. ssvnc tries to handle the general case of an already started desktop and that is more difficult.

<a name="proxies"> 
_**Proxies:**_ Web proxies, SOCKS proxies, and the UltraVNC repeater proxy are supported to allow the SSVNC connection to go through the proxy to the otherwise unreachable VNC Server. SSH gateway machines can be used in the same way. Read</a> [more about SSVNC proxy support here](ssvnc-proxies.html).

<a name="dynamic-port"> 
_**Dynamic VNC Server Port determination:**_ If you are running SSVNC on Unix and are using SSH to start the remote VNC server and the VNC server prints out the line "PORT=NNNN" to indicate which dynamic port it is using (x11vnc does this), then if you prefix the SSH command with "PORT=" SSVNC will watch for the PORT=NNNN line and uses ssh's built in SOCKS proxy (ssh -D ...) to connect to the dynamic VNC server port through the SSH tunnel. For example:</a>

<pre> <a name="dynamic-port">VNC Host:Display     user@somehost.com
        Remote SSH Command:  PORT= x11vnc -find</a> </pre>

<a name="dynamic-port">or "`PORT= x11vnc -display :0 -localhost`", etc. Or use "`P= x11vnc ...`"

There is also code to detect the display of the regular Unix vncserver(1). It extracts the display (and hence port) from the lines "New 'X' desktop is hostname:4" and also "VNC server is already running as :4". So you can use something like:

<pre>        PORT= vncserver; sleep 15
or:     PORT= vncserver :4; sleep 15
</pre>

the latter is preferred because when you reconnect with it will find the already running one. The former one will keep creating new X sessions if called repeatedly.</a>

<a name="dynamic-port">If you use `PORT=` on Windows, a large random port is selected instead and the</a> [`-rfbport`](x11vnc_opts.html#opt-rfbport) option is passed to **x11vnc** (it does not work with vncserver).

<a name="unix-patches"> 
_**Patches for Unix Tightvnc viewer:**_</a>

<a name="unix-patches">The `rfbNewFBSize` support allows the enhanced TightVNC Unix viewer to resize when the server does (e.g. "`x11vnc -R scale=3/4`" remote control command).</a>

<a name="unix-patches">The cursor alphablending is</a> [described here](faq.html#faq-xfixes-alpha-hacks).

The RealVNC ZRLE encoding is supported, in addition to some low colors modes (16bpp and 8bpp at 256, 64, and even 8 colors, for use on very slow connections). Greyscales are also enabled for the low color modes.

The Popup menu (F8) is enhanced with the ability to change many things on the fly. F9 is added as a shortcut to toggle FullScreen mode.<a name="ycrop"></a>

<a name="ycrop">**Client Side Caching**: The **x11vnc**</a> [client-side caching](faq.html#faq-client-caching) is handled nicely by this viewer. The **very** large pixel cache below the actual display in this caching method is distracting. Our Unix VNC viewer will automatically try to autodetect the actual display height if the framebuffer is very tall (more than twice as high as it is wide). One can also set the height to the known value via `-ycrop n`, or use `-ycrop -1` to force autodection. In fullscreen mode one is not possible to scroll down to the pixel cache region. In non-fullscreen mode the window manager frame is "shrink-wrapped" around the actual screen display. You can still scroll down to the pixel cache region. The scrollbars are set to be very thin (2 pixels) to be less distracting. Use the `-sbwidth n` to make them wider.

Probably nobody is interested in the [grabserver patch for old window managers](faq.html#faq-scrollbars) when the viewer is in fullscreen mode... This and some other unfixed bugs have been fixed in our patches (fullscreen toggle works with KDE, `-x11cursor` has been fixed, and the dot cursor has been made smaller).

From the `-help` output:

<pre>SSVNC Viewer (based on TightVNC viewer version 1.3.9)

Usage: vncviewer [<OPTIONS>] [<HOST>][:<DISPLAY#>]
       vncviewer [<OPTIONS>] [<HOST>][::<PORT#>]
       vncviewer [<OPTIONS>] exec=[CMD ARGS...]
       vncviewer [<OPTIONS>] fd=n
       vncviewer [<OPTIONS>] /path/to/unix/socket
       vncviewer [<OPTIONS>] -listen [<DISPLAY#>]
       vncviewer -help

<OPTIONS> are standard Xt options, or:
        -via <GATEWAY>
        -shared (set by default)
        -noshared
        -viewonly
        -fullscreen
        -noraiseonbeep
        -passwd <PASSWD-FILENAME> (standard VNC authentication)
        -user <USERNAME> (Unix login authentication)
        -encodings <ENCODING-LIST> (e.g. "tight,copyrect")
        -bgr233
        -owncmap
        -truecolour
        -depth <DEPTH>
        -compresslevel <COMPRESS-VALUE> (0..9: 0-fast, 9-best)
        -quality <JPEG-QUALITY-VALUE> (0..9: 0-low, 9-high)
        -nojpeg
        -nocursorshape
        -x11cursor
        -autopass

Option names may be abbreviated, e.g. -bgr instead of -bgr233.
See the manual page for more information.

Enhanced TightVNC viewer (SSVNC) options:

   URL http://www.karlrunge.com/x11vnc/ssvnc.html

   Note: ZRLE and ZYWRLE encodings are now supported.

   Note: F9 is shortcut to Toggle FullScreen mode.

   Note: In -listen mode set the env var. SSVNC_MULTIPLE_LISTEN=1
         to allow more than one incoming VNC server at a time.
         This is the same as -multilisten described below.  Set
         SSVNC_MULTIPLE_LISTEN=MAX:n to allow no more than "n"
         simultaneous reverse connections.

   Note: If the host:port is specified as "exec=command args..."
         then instead of making a TCP/IP socket connection to the
         remote VNC server, "command args..." is executed and the
         viewer is attached to its stdio.  This enables tunnelling
         established via an external command, e.g. an stunnel(8)
         that does not involve a listening socket.  This mode does
         not work for -listen reverse connections.

         If the host:port is specified as "fd=n" then it is assumed
         n is an already opened file descriptor to the socket. (i.e
         the parent did fork+exec)

         If the host:port contains a '/' it is interpreted as a
         unix-domain socket (AF_LOCAL insead of AF_INET)

        -multilisten  As in -listen (reverse connection listening) except
                    allow more than one incoming VNC server to be connected
                    at a time.  The default for -listen of only one at a
                    time tries to play it safe by not allowing anyone on
                    the network to put (many) desktops on your screen over
                    a long window of time. Use -multilisten for no limit.

        -acceptpopup  In -listen (reverse connection listening) mode when
                    a reverse VNC connection comes in show a popup asking
                    whether to Accept or Reject the connection.  The IP
                    address of the connecting host is shown.  Same as
                    setting the env. var. SSVNC_ACCEPT_POPUP=1.

        -acceptpopupsc  As in -acceptpopup except assume UltraVNC Single
                    Click (SC) server.  Retrieve User and ComputerName
                    info from UltraVNC Server and display in the Popup.

        -use64      In -bgr233 mode, use 64 colors instead of 256.
        -bgr222     Same as -use64.

        -use8       In -bgr233 mode, use 8 colors instead of 256.
        -bgr111     Same as -use8.

        -16bpp      If the vnc viewer X display is depth 24 at 32bpp
                    request a 16bpp format from the VNC server to cut
                    network traffic by up to 2X, then tranlate the
                    pixels to 32bpp locally.
        -bgr565     Same as -16bpp.

        -grey       Use a grey scale for the 16- and 8-bpp modes.

        -alpha      Use alphablending transparency for local cursors
                    requires: x11vnc server, both client and server
                    must be 32bpp and same endianness.

        -scale str  Scale the desktop locally.  The string "str" can
                    a floating point ratio, e.g. "0.9", or a fraction,
                    e.g. "3/4", or WxH, e.g. 1280x1024\.  Use "fit"
                    to fit in the current screen size.  Use "auto" to
                    fit in the window size.  "str" can also be set by
                    the env. var. SSVNC_SCALE.

                    If you observe mouse trail painting errors, enable
                    X11 Cursor mode (either via Popup or -x11cursor.)

                    Note that scaling is done in software and so can be
                    slow and requires more memory.  Some speedup Tips:

                        ZRLE is faster than Tight in this mode.  When
                        scaling is first detected, the encoding will
                        be automatically switched to ZRLE.  Use the
                        Popup menu if you want to go back to Tight.
                        Set SSVNC_PRESERVE_ENCODING=1 to disable this.

                        Use a solid background on the remote side.
                        (e.g. manually or via x11vnc -solid ...)

                        If the remote server is x11vnc, try client
                        side caching: x11vnc -ncache 10 ...

        -ycrop n    Only show the top n rows of the framebuffer.  For
                    use with x11vnc -ncache client caching option
                    to help "hide" the pixel cache region.
                    Use a negative value (e.g. -1) for autodetection.
                    Autodetection will always take place if the remote
                    fb height is more than 2 times the width.

        -sbwidth n  Scrollbar width for x11vnc -ncache mode (-ycrop),
                    default is very narrow: 2 pixels, it is narrow to
                    avoid distraction in -ycrop mode.

        -nobell     Disable bell.

        -rawlocal   Prefer raw encoding for localhost, default is
                    no, i.e. assumes you have a SSH tunnel instead.

        -notty      Try to avoid using the terminal for interactive
                    responses: use windows for messages and prompting
                    instead.  Messages will also be printed to terminal.

        -sendclipboard  Send the X CLIPBOARD selection (i.e. Ctrl+C,
                        Ctrl+V) instead of the X PRIMARY selection (mouse
                        select and middle button paste.)

        -sendalways     Whenever the mouse enters the VNC viewer main
                        window, send the selection to the VNC server even if
                        it has not changed.  This is like the Xt resource
                        translation SelectionToVNC(always)

        -recvtext str   When cut text is received from the VNC server,
                        ssvncviewer will set both the X PRIMARY and the
                        X CLIPBOARD local selections.  To control which
                        is set, specify 'str' as 'primary', 'clipboard',
                        or 'both' (the default.)

        -graball    Grab the entire X server when in fullscreen mode,
                    needed by some old window managers like fvwm2.

        -popupfix   Warp the popup back to the pointer position,
                    needed by some old window managers like fvwm2.
        -sendclipboard  Send the X CLIPBOARD selection (i.e. Ctrl+C,
                        Ctrl+V) instead of the X PRIMARY selection (mouse
                        select and middle button paste.)

        -sendalways     Whenever the mouse enters the VNC viewer main
                        window, send the selection to the VNC server even if
                        it has not changed.  This is like the Xt resource
                        translation SelectionToVNC(always)

        -recvtext str   When cut text is received from the VNC server,
                        ssvncviewer will set both the X PRIMARY and the
                        X CLIPBOARD local selections.  To control which
                        is set, specify 'str' as 'primary', 'clipboard',
                        or 'both' (the default.)

        -graball    Grab the entire X server when in fullscreen mode,
                    needed by some old window managers like fvwm2.

        -popupfix   Warp the popup back to the pointer position,
                    needed by some old window managers like fvwm2.

        -grabkbd    Grab the X keyboard when in fullscreen mode,
                    needed by some window managers. Same as -grabkeyboard.
                    -grabkbd is the default, use -nograbkbd to disable.

        -bs, -nobs  Whether or not to use X server Backingstore for the
                    main viewer window.  The default is to not, mainly
                    because most Linux, etc, systems X servers disable
                    *all* Backingstore by default.  To re-enable it put

                        Option "Backingstore"

                    in the Device section of /etc/X11/xorg.conf.
                    In -bs mode with no X server backingstore, whenever an
                    area of the screen is re-exposed it must go out to the
                    VNC server to retrieve the pixels. This is too slow.

                    In -nobs mode, memory is allocated by the viewer to
                    provide its own backing of the main viewer window. This
                    actually makes some activities faster (changes in large
                    regions) but can appear to "flash" too much.

        -noshm      Disable use of MIT shared memory extension (not recommended)

        -termchat   Do the UltraVNC chat in the terminal vncviewer is in
                    instead of in an independent window.

        -unixpw str Useful for logging into x11vnc in -unixpw mode. "str" is a
                    string that allows many ways to enter the Unix Username
                    and Unix Password.  These characters: username, newline,
                    password, newline are sent to the VNC server after any VNC
                    authentication has taken place.  Under x11vnc they are
                    used for the -unixpw login.  Other VNC servers could do
                    something similar.

                    You can also indicate "str" via the environment
                    variable SSVNC_UNIXPW.

                    Note that the Escape key is actually sent first to tell
                    x11vnc to not echo the Unix Username back to the VNC
                    viewer. Set SSVNC_UNIXPW_NOESC=1 to override this.

                    If str is ".", then you are prompted at the command line
                    for the username and password in the normal way.  If str is
                    "-" the stdin is read via getpass(3) for username@password.
                    Otherwise if str is a file, it is opened and the first line
                    read is taken as the Unix username and the 2nd as the
                    password. If str prefixed by "rm:" the file is removed
                    after reading. Otherwise, if str has a "@" character,
                    it is taken as username@password. Otherwise, the program
                    exits with an error. Got all that?

     -repeater str  This is for use with UltraVNC repeater proxy described
                    here: http://www.uvnc.com/addons/repeater.html.  The "str"
                    is the ID string to be sent to the repeater.  E.g. ID:1234
                    It can also be the hostname and port or display of the VNC
                    server, e.g. 12.34.56.78:0 or snoopy.com:1\.  Note that when
                    using -repeater, the host:dpy on the cmdline is the repeater
                    server, NOT the VNC server.  The repeater will connect you.

                    Example: vncviewer ... -repeater ID:3333 repeat.host:5900
                    Example: vncviewer ... -repeater vhost:0 repeat.host:5900

                    Use, e.g., '-repeater SCIII=ID:3210' if the repeater is a
                    Single Click III (SSL) repeater (repeater_SSL.exe) and you
                    are passing the SSL part of the connection through stunnel,
                    socat, etc. This way the magic UltraVNC string 'testB'
                    needed to work with the repeater is sent to it.

     -rfbversion str Set the advertised RFB version.  E.g.: -rfbversion 3.6
                    For some servers, e.g. UltraVNC this needs to be done.

     -ultradsm      UltraVNC has symmetric private key encryption DSM plugins:
                    http://www.uvnc.com/features/encryption.html. It is assumed
                    you are using a unix program (e.g. our ultravnc_dsm_helper)
                    to encrypt and decrypt the UltraVNC DSM stream. IN ADDITION
                    TO THAT supply -ultradsm to tell THIS viewer to modify the
                    RFB data sent so as to work with the UltraVNC Server. For
                    some reason, each RFB msg type must be sent twice under DSM.

     -mslogon user  Use Windows MS Logon to an UltraVNC server.  Supply the
                    username or "1" to be prompted.  The default is to
                    autodetect the UltraVNC MS Logon server and prompt for
                    the username and password.

                    IMPORTANT NOTE: The UltraVNC MS-Logon Diffie-Hellman
                    exchange is very weak and can be brute forced to recover
                    your username and password in a few seconds of CPU time.
                    To be safe, be sure to use an additional encrypted tunnel
                    (e.g. SSL or SSH) for the entire VNC session.

     -chatonly      Try to be a client that only does UltraVNC text chat. This
                    mode is used by x11vnc to present a chat window on the
                    physical X11 console (i.e. chat with the person at the
                    display).

     -env VAR=VALUE To save writing a shell script to set environment variables,
                    specify as many as you need on the command line.  For
                    example, -env SSVNC_MULTIPLE_LISTEN=MAX:5 -env EDITOR=vi

     -noipv6        Disable all IPv6 sockets.  Same as VNCVIEWER_NO_IPV6=1.

     -noipv4        Disable all IPv4 sockets.  Same as VNCVIEWER_NO_IPV4=1.

     -printres      Print out the Ssvnc X resources (appdefaults) and then exit
                    You can save them to a file and customize them (e.g. the
                    keybindings and Popup menu)  Then point to the file via
                    XENVIRONMENT or XAPPLRESDIR.

     -pipeline      Like TurboVNC, request the next framebuffer update as soon
                    as possible instead of waiting until the end of the current
                    framebuffer update coming in.  Helps 'pipeline' the updates.
                    This is currently the default, use -nopipeline to disable.

     -appshare      Enable features for use with x11vnc's -appshare mode where
                    instead of sharing the full desktop only the application's
                    windows are shared.  Viewer multilisten mode is used to
                    create the multiple windows: -multilisten is implied.
                    See 'x11vnc -appshare -help' more information on the mode.

                    Features enabled in the viewer under -appshare are:
                    Minimum extra text in the title, auto -ycrop is disabled,
                    x11vnc -remote_prefix X11VNC_APPSHARE_CMD: message channel,
                    x11vnc initial window position hints.  See also Escape Keys
                    below for additional key and mouse bindings.

     -escape str    This sets the 'Escape Keys' modifier sequence and enables
                    escape keys mode.  When the modifier keys escape sequence
                    is held down, the next keystroke is interpreted locally
                    to perform a special action instead of being sent to the
                    remote VNC server.

                    Use '-escape default' for the default modifier sequence.
                    (Unix: Alt_L,Super_L and MacOSX: Control_L,Meta_L)

    Here are the 'Escape Keys: Help+Set' instructions from the Popup Menu:

    Escape Keys:  Enter a comma separated list of modifier keys to be the
    'escape sequence'.  When these keys are held down, the next keystroke is
    interpreted locally to invoke a special action instead of being sent to
    the remote VNC server.  In other words, a set of 'Hot Keys'.

    To enable or disable this, click on 'Escape Keys: Toggle' in the Popup.

    Here is the list of hot-key mappings to special actions:

       r: refresh desktop  b: toggle bell   c: toggle full-color
       f: file transfer    x: x11cursor     z: toggle Tight/ZRLE
       l: full screen      g: graball       e: escape keys dialog
       s: scale dialog     +: scale up (=)  -: scale down (_)
       t: text chat                         a: alphablend cursor
       V: toggle viewonly  Q: quit viewer   1 2 3 4 5 6: UltraVNC scale 1/n

       Arrow keys:         pan the viewport about 10% for each keypress.
       PageUp / PageDown:  pan the viewport by a screenful vertically.
       Home   / End:       pan the viewport by a screenful horizontally.
       KeyPad Arrow keys:  pan the viewport by 1 pixel for each keypress.
       Dragging the Mouse with Button1 pressed also pans the viewport.
       Clicking Mouse Button3 brings up the Popup Menu.

    The above mappings are *always* active in ViewOnly mode, unless you set the
    Escape Keys value to 'never'.

    If the Escape Keys value below is set to 'default' then a default list of
    of modifier keys is used.  For Unix it is: Alt_L,Super_L and for MacOSX it
    is Control_L,Meta_L.  Note: the Super_L key usually has a Windows(TM) Flag
    on it.  Also note the _L and _R mean the key is on the LEFT or RIGHT side
    of the keyboard.

    On Unix   the default is Alt and Windows keys on Left side of keyboard.
    On MacOSX the default is Control and Command keys on Left side of keyboard.

    Example: Press and hold the Alt and Windows keys on the LEFT side of the
    keyboard and then press 'c' to toggle the full-color state.  Or press 't'
    to toggle the ultravnc Text Chat window, etc.

    To use something besides the default, supply a comma separated list (or a
    single one) from: Shift_L Shift_R Control_L Control_R Alt_L Alt_R Meta_L
    Meta_R Super_L Super_R Hyper_L Hyper_R or Mode_switch.

   New Popup actions:

        ViewOnly:                ~ -viewonly
        Disable Bell:            ~ -nobell
        Cursor Shape:            ~ -nocursorshape
        X11 Cursor:              ~ -x11cursor
        Cursor Alphablend:       ~ -alpha
        Toggle Tight/Hextile:    ~ -encodings hextile...
        Toggle Tight/ZRLE:       ~ -encodings zrle...
        Toggle ZRLE/ZYWRLE:      ~ -encodings zywrle...
        Quality Level            ~ -quality (both Tight and ZYWRLE)
        Compress Level           ~ -compresslevel
        Disable JPEG:            ~ -nojpeg  (Tight)
        Pipeline Updates         ~ -pipeline

        Full Color                 as many colors as local screen allows.
        Grey scale (16 & 8-bpp)  ~ -grey, for low colors 16/8bpp modes only.
        16 bit color (BGR565)    ~ -16bpp / -bgr565
        8  bit color (BGR233)    ~ -bgr233
        256 colors               ~ -bgr233 default # of colors.
         64 colors               ~ -bgr222 / -use64
          8 colors               ~ -bgr111 / -use8
        Scale Viewer             ~ -scale
        Escape Keys: Toggle      ~ -escape
        Escape Keys: Help+Set    ~ -escape
        Set Y Crop (y-max)       ~ -ycrop
        Set Scrollbar Width      ~ -sbwidth
        XGrabServer              ~ -graball

        UltraVNC Extensions:

          Set 1/n Server Scale     Ultravnc ext. Scale desktop by 1/n.
          Text Chat                Ultravnc ext. Do Text Chat.
          File Transfer            Ultravnc ext. File xfer via Java helper.
          Single Window            Ultravnc ext. Grab and view a single window.
                                   (select then click on the window you want).
          Disable Remote Input     Ultravnc ext. Try to prevent input and
                                   viewing of monitor at physical display.

        Note: the Ultravnc extensions only apply to servers that support
              them.  x11vnc/libvncserver supports some of them.

        Send Clipboard not Primary  ~ -sendclipboard
        Send Selection Every time   ~ -sendalways
</pre>

<a name="popup">Nearly all of these can be changed dynamically in the Popup menu (press F8 for it):

![](viewer_menu.gif) ![](unixviewer.jpg)

* * *

_**Windows:**_

For Windows, SSL Viewer support is provided by a GUI `Windows/ssvnc.exe` that prompts for the VNC display and then starts up STUNNEL followed by the Stock TightVNC Windows Viewer. Both are bundled in the package for your convenience. The GUI has other useful features. When the connection is finished, you will be asked if you want to terminate the STUNNEL program. For SSH connections from Windows the GUI will use PLINK instead of STUNNEL. A user reports that SSVNC works properly in remote helpdesk mode using UltraVNC Single-click in Windows Vista.

_**Unix and Mac OS X:**_

Run the GUI (`ssvnc`, see above) and let me know how it goes.

* * *

</a>

<a name="popup">Hopefully this tool will make it convenient for people to help test and use the</a> [built-in SSL support](faq.html#faq-ssl-tunnel-int) in **x11vnc**. Extra testing of this feature is **much** appreciated!! Thanks.

_**Please Help Test**_ the newly added features:

*   Automatic Service tunnelling via SSH for CUPS and SMB Printing
*   ESD/ARTSD Audio
*   SMB (Windows/Samba) filesystem mounting

These allow you to print from the remote (VNC Server) machine to local printers, listen to sounds (with some limitations) from the remote VNC Server machine, and to mount your local Windows or Samba shares on the remote VNC Server machine. Basically these new features try to automate the tricks described here:

<pre>    [http://www.karlrunge.com/x11vnc/faq.html#faq-smb-shares](faq.html#faq-smb-shares)
    [http://www.karlrunge.com/x11vnc/faq.html#faq-cups](faq.html#faq-cups)
    [http://www.karlrunge.com/x11vnc/faq.html#faq-sound](faq.html#faq-sound)
</pre>

<a name="download"></a>

* * *

<a name="download"></a>

<a name="download">_**Downloading:**_ Downloads for this project are hosted at</a> [Sourceforge.net](http://sourceforge.net/projects/ssvnc).

Choose the archive file bundle that best suits you (e.g. no source code, windows only, unix only, zip, tar etc).

A quick guide:

   On some flavor of Unix, e.g. Linux or Solaris? Use "`ssvnc_unix_only`" (or "`ssvnc_no_windows`" to recompile).
   On Mac OS X? Use "`ssvnc_no_windows`".
   On Windows? Use "`ssvnc_windows_only`".

<pre>  [ssvnc_windows_only-1.0.29.zip](http://downloads.sourceforge.net/ssvnc/ssvnc_windows_only-1.0.29.zip?use_mirror=)      Windows Binaries Only.  No source included (6.2MB)
  [ssvnc_no_windows-1.0.29.tar.gz](http://downloads.sourceforge.net/ssvnc/ssvnc_no_windows-1.0.29.tar.gz?use_mirror=)     Unix and Mac OS X Only. No Windows binaries.  Source included. (10.1MB)
  [ssvnc_unix_only-1.0.29.tar.gz](http://downloads.sourceforge.net/ssvnc/ssvnc_unix_only-1.0.29.tar.gz?use_mirror=)      Unix Binaries Only.     No source included. (7.2MB)
  [ssvnc_unix_minimal-1.0.29.tar.gz](http://downloads.sourceforge.net/ssvnc/ssvnc_unix_minimal-1.0.29.tar.gz?use_mirror=)   Unix Minimal.  You must supply your own `vncviewer` and `stunnel`. (0.2MB)

  [ssvnc-1.0.29.tar.gz](http://ssvnc.sourceforge.net/dev/ssvnc-1.0.29.tar.gz)                All Unix, Mac OS X, and Windows binaries and source TGZ. (16.1MB)
  [ssvnc-1.0.29.zip](http://ssvnc.sourceforge.net/dev/ssvnc-1.0.29.zip)                   All Unix, Mac OS X, and Windows binaries and source ZIP. (16.4MB)
  [ssvnc_all-1.0.29.zip](http://downloads.sourceforge.net/ssvnc/ssvnc_all-1.0.29.zip?use_mirror=)               All Unix, Mac OS X, and Windows binaries and source AND full archives in the zip dir. (19.2MB)
</pre>

<a name="source">Here is a conventional source tarball:</a>

<pre> <a name="source"></a> [ssvnc-1.0.29.src.tar.gz](http://downloads.sourceforge.net/ssvnc/ssvnc-1.0.29.src.tar.gz?use_mirror=)            Conventional Source for SSVNC GUI and Unix VNCviewer  (0.5MB)
</pre>

it will be of use to those who do not want the SSVNC "one-size-fits-all" bundles. For example, package/distro maintainers will find this more familiar and useful to them (i.e. they run: "`make config; make all; make install`"). Note that it does not include the `stunnel` source, and so has a dependency that the system stunnel is installed.

Read the [README.src](etv/README.src.txt) file for more information on using the conventional source tarball.

Note: even with the Unix bundles, e.g. "`ssvnc_no_windows`" or "`ssvnc_all`", you may need to run the "`./build.unix`" script in the top directory to recompile for your operating system.

Here are the corresponding 1.0.30 development bundles (**Please** help test them):

<pre>  [ssvnc_windows_only-1.0.30.zip](http://ssvnc.sourceforge.net/dev/ssvnc_windows_only-1.0.30.zip)
  [ssvnc_no_windows-1.0.30.tar.gz](http://ssvnc.sourceforge.net/dev/ssvnc_no_windows-1.0.30.tar.gz)
  [ssvnc_unix_only-1.0.30.tar.gz](http://ssvnc.sourceforge.net/dev/ssvnc_unix_only-1.0.30.tar.gz)
  [ssvnc_unix_minimal-1.0.30.tar.gz](http://ssvnc.sourceforge.net/dev/ssvnc_unix_minimal-1.0.30.tar.gz)

  [ssvnc-1.0.30.tar.gz](http://ssvnc.sourceforge.net/dev/ssvnc-1.0.30.tar.gz)
  [ssvnc-1.0.30.zip](http://ssvnc.sourceforge.net/dev/ssvnc-1.0.30.zip)
  [ssvnc_all-1.0.30.zip](http://ssvnc.sourceforge.net/dev/ssvnc_all-1.0.30.zip)

  [ssvnc-1.0.30.src.tar.gz](http://ssvnc.sourceforge.net/dev/ssvnc-1.0.30.src.tar.gz)            Conventional Source for SSVNC GUI and Unix VNCviewer  (0.5MB)
</pre>

For any Unix system, a self-extracting and running file for the "ssvnc_unix_minimal" package is here: [ssvnc](etv/ssvnc). Save it as filename "`ssvnc`", type "`chmod 755 ./ssvnc`", and then launch the GUI via typing "`./ssvnc`". Note that this "ssvnc_unix_minimal" mode requires you install the "`stunnel`" and "`vncviewer`" programs externally (for example, install your distros' versions, e.g. on debian: "`apt-get install stunnel4 xtightvncviewer`".) It will work, but many of the SSVNC features will be missing.

_**Previous releases:**_
   [Release 1.0.18 at Sourceforge.net](http://sourceforge.net/project/showfiles.php?group_id=243486&package_id=296727&release_id=636282)
   [Release 1.0.19 at Sourceforge.net](http://sourceforge.net/project/showfiles.php?group_id=243486&package_id=296727&release_id=636337)
   [Release 1.0.20 at Sourceforge.net](http://sourceforge.net/project/showfiles.php?group_id=243486&package_id=296727&release_id=636338)
   [Release 1.0.21 at Sourceforge.net](http://sourceforge.net/project/showfiles.php?group_id=243486&package_id=296727&release_id=640923)
   [Release 1.0.22 at Sourceforge.net](http://sourceforge.net/project/showfiles.php?group_id=243486&package_id=296727&release_id=652804)
   [Release 1.0.23 at Sourceforge.net](http://sourceforge.net/projects/ssvnc/files/ssvnc/1.0.23/)
   [Release 1.0.24 at Sourceforge.net](http://sourceforge.net/projects/ssvnc/files/ssvnc/1.0.24/)
   [Release 1.0.25 at Sourceforge.net](http://sourceforge.net/projects/ssvnc/files/ssvnc/1.0.25/)
   [Release 1.0.26 at Sourceforge.net](http://sourceforge.net/projects/ssvnc/files/ssvnc/1.0.26/)
   [Release 1.0.27 at Sourceforge.net](http://sourceforge.net/projects/ssvnc/files/ssvnc/1.0.27/)
   [Release 1.0.28 at Sourceforge.net](http://sourceforge.net/projects/ssvnc/files/ssvnc/1.0.28/)
   [Release 1.0.29 at Sourceforge.net](http://sourceforge.net/projects/ssvnc/files/ssvnc/1.0.29/)

Please help test the UltraVNC File Transfer support in the native Unix VNC viewer! Let us know how it went.

Current Unix binaries in the archives:

<pre>    Linux.i686
    Linux.x86_64
    Linux.ppc64    X (removed)
    Linux.alpha    X (removed)
    SunOS.sun4u
    SunOS.sun4m
    SunOS.i86pc
    Darwin.Power.Macintosh
    Darwin.i386
    HP-UX.9000     X (removed)
    FreeBSD.i386   X (removed)
    NetBSD.i386    X (removed)
    OpenBSD.i386   X (removed)
</pre>

(some of these are out of date, marked with 'X' above, because I no longer have access to machines running those OS's. Use the "`build.unix`" script to recompile on your system).

Note: some of the above binaries depend on `libssl.so.0.9.7`, whereas some recent distros only provide `libssl.so.0.9.8` by default (for compatibility reasons they should install both by default but not all do). So you may need to instruct your distro to install the 0.9.7 library (it is fine to have both runtimes installed simultaneously since the libraries have different names). _Update:_ I now try to statically link `libssl.a` for all of the binaries in the archive.

You can also run the included `build.unix` script to try to automatically build the binaries if your OS is not in the above list or the included binary does not run properly on your system. Let me know how that goes.

* * *

**IMPORTANT**: there may be restrictions for you to download, use, or redistribute the above because of cryptographic software they contain or for other reasons. Please check out your situation and information at the following and related sites:

<pre>	[http://stunnel.mirt.net](http://stunnel.mirt.net)
	[http://www.stunnel.org](http://www.stunnel.org)
	[http://www.openssl.org](http://www.openssl.org)
	[http://www.chiark.greenend.org.uk/~sgtatham/putty/](http://www.chiark.greenend.org.uk/~sgtatham/putty/)
        [http://www.tightvnc.com](http://www.tightvnc.com)
	[http://www.realvnc.com](http://www.realvnc.com)
	[http://sourceforge.net/projects/cotvnc/](http://sourceforge.net/projects/cotvnc/)
</pre>

* * *

**README:** Here is the toplevel [README from the bundle](README.ssvnc.html).


-----
http://www.karlrunge.com/x11vnc/x11vnc_opts.html:

* * *

## x11vnc: a VNC server for real X displays

Here are all of **x11vnc** command line options:

<pre>% x11vnc -opts      (see below for -help long descriptions)

x11vnc: allow VNC connections to real X11 displays. 0.9.14 lastmod: 2013-11-21

x11vnc options:
  -display disp            -auth file               -N                     
  -autoport n              -rfbport str             -6                     
  -no6                     -noipv6                  -noipv4                
  -reopen                  -reflect host:N          -id windowid           
  -sid windowid            -tag str                 -appshare              
  -clip WxH+X+Y            -flashcmap               -shiftcmap n           
  -notruecolor             -advertise_truecolor     -visual n              
  -overlay                 -overlay_nocursor        -8to24 [opts]          
  -24to32                  -scale fraction          -geometry WxH          
  -scale_cursor frac       -viewonly                -shared                
  -once                    -forever                 -loop                  
  -timeout n               -sleepin n               -inetd                 
  -tightfilexfer           -ultrafilexfer           -http                  
  -http_ssl                -avahi                   -mdns                  
  -zeroconf                -connect string          -connect_or_exit str   
  -proxy string            -vncconnect              -novncconnect          
  -allow host1[,host2..]   -localhost               -unixsock str          
  -unixsockonly str        -listen6 str             -nolookup              
  -input string            -grabkbd                 -grabptr               
  -ungrabboth              -grabalways              -viewpasswd string     
  -passwdfile filename     -showrfbauth filename    -usepw                 
  -storepasswd pass file   -nopw                    -accept string         
  -afteraccept string      -gone string             -unixpw [list]         
  -unixpw_nis [list]       -unixpw_cmd cmd          -find                  
  -finddpy                 -listdpy                 -findauth [disp]       
  -create                  -xdummy                  -xvnc                  
  -xvnc_redirect           -xdummy_xvfb             -create_xsrv str       
  -svc                     -svc_xdummy              -svc_xvnc              
  -svc_xdummy_xvfb         -xdmsvc                  -sshxdmsvc             
  -unixpw_system_greeter   -redirect port           -display WAIT:...      
  -vencrypt mode           -anontls mode            -sslonly               
  -dhparams file           -nossl                   -ssl [pem]             
  -ssltimeout n            -sslnofail               -ssldir dir            
  -sslverify path          -sslCRL path             -sslGenCA [dir]        
  -sslGenCert type name    -sslEncKey pem           -sslCertInfo pem       
  -sslDelCert pem          -sslScripts              -stunnel [pem]         
  -stunnel3  [pem]         -enc cipher:keyfile      -https [port]          
  -httpsredir [port]       -http_oneport            -ssh user@host:disp    
  -users list              -noshm                   -flipbyteorder         
  -onetile                 -solid [color]           -blackout string       
  -xinerama                -noxinerama              -xtrap                 
  -xrandr [mode]           -rotate string           -padgeom WxH           
  -o logfile               -flag file               -rmflag file           
  -rc filename             -norc                    -env VAR=VALUE         
  -prog /path/to/x11vnc    -h, -help                -?, -opts              
  -V, -version             -license                 -dbg                   
  -q, -quiet               -v, -verbose             -bg                    
  -modtweak                -nomodtweak              -xkb                   
  -noxkb                   -capslock                -skip_lockkeys         
  -noskip_lockkeys         -skip_keycodes string    -sloppy_keys           
  -skip_dups               -noskip_dups             -add_keysyms           
  -noadd_keysyms           -clear_mods              -clear_keys            
  -clear_all               -remap string            -norepeat              
  -repeat                  -nofb                    -nobell                
  -nosel                   -noprimary               -nosetprimary          
  -noclipboard             -nosetclipboard          -seldir string         
  -cursor [mode]           -nocursor                -cursor_drag           
  -arrow n                 -noxfixes                -alphacut n            
  -alphafrac fraction      -alpharemove             -noalphablend          
  -nocursorshape           -cursorpos               -nocursorpos           
  -xwarppointer            -noxwarppointer          -always_inject         
  -buttonmap string        -nodragging              -ncache n              
  -ncache_cr               -ncache_no_moveraise     -ncache_no_dtchange    
  -ncache_no_rootpixmap    -ncache_keep_anims       -ncache_old_wm         
  -ncache_pad n            -debug_ncache            -wireframe [str]       
  -nowireframe             -nowireframelocal        -wirecopyrect mode     
  -nowirecopyrect          -debug_wireframe         -scrollcopyrect mode   
  -noscrollcopyrect        -scr_area n              -scr_skip list         
  -scr_inc list            -scr_keys list           -scr_term list         
  -scr_keyrepeat lo-hi     -scr_parms string        -fixscreen string      
  -debug_scroll            -noxrecord               -grab_buster           
  -nograb_buster           -debug_grabs             -debug_sel             
  -pointer_mode n          -input_skip n            -allinput              
  -input_eagerly           -speeds rd,bw,lat        -wmdt string           
  -debug_pointer           -debug_keyboard          -defer time            
  -wait time               -extra_fbur n            -wait_ui factor        
  -setdefer n              -nowait_bog              -slow_fb time          
  -xrefresh time           -nap                     -nonap                 
  -sb time                 -readtimeout n           -ping n                
  -nofbpm                  -fbpm                    -nodpms                
  -dpms                    -forcedpms               -clientdpms            
  -noserverdpms            -noultraext              -chatwindow            
  -noxdamage               -xd_area A               -xd_mem f              
  -sigpipe string          -threads                 -nothreads             
  -fs f                    -gaps n                  -grow n                
  -fuzz n                  -debug_tiles             -snapfb                
  -rawfb string            -freqtab file            -pipeinput cmd         
  -macnodim                -macnosleep              -macnosaver            
  -macnowait               -macwheel n              -macnoswap             
  -macnoresize             -maciconanim n           -macmenu               
  -macuskbd                -macnocglion             -macnoopengl           
  -macnorawfb              -macdisplay n            -gui [gui-opts]        
  -remote command          -query variable          -QD variable           
  -sync                    -query_retries str       -remote_prefix str     
  -noremote                -yesremote               -unsafe                
  -safer                   -privremote              -nocmds                
  -allowedcmds list        -deny_all              

LibVNCServer options:
-rfbport port          TCP port for RFB protocol
-rfbwait time          max time in ms to wait for RFB client
-rfbauth passwd-file   use authentication on RFB protocol
                       (use 'storepasswd' to create a password file)
-rfbversion 3.x        Set the version of the RFB we choose to advertise
-permitfiletransfer    permit file transfer support
-passwd plain-password use authentication 
                       (use plain-password as password, USE AT YOUR RISK)
-deferupdate time      time in ms to defer updates (default 40)
-deferptrupdate time   time in ms to defer pointer updates (default none)
-desktop name          VNC desktop name (default "LibVNCServer")
-alwaysshared          always treat new clients as shared
-nevershared           never treat new clients as shared
-dontdisconnect        don't disconnect existing clients when a new non-shared
                       connection comes in (refuse new connection instead)
-httpdir dir-path      enable http server using dir-path home
-httpport portnum      use portnum for http connection
-enablehttpproxy       enable http proxy support
-progressive height    enable progressive updating for slow links
-listen ipaddr         listen for connections only on network interface with
                       addr ipaddr. '-listen localhost' and hostname work too.

libvncserver-tight-extension options:
-disablefiletransfer   disable file transfer
-ftproot string        set ftp root

% x11vnc -help

x11vnc: allow VNC connections to real X11 displays. 0.9.14 lastmod: 2013-11-21

(type "x11vnc -opts" to just list the options.)

Typical usage is:

   Run this command in a shell on the remote machine "far-host"
   with X session you wish to view:

       x11vnc -display :0

   Then run this in another window on the machine you are sitting at:

       vncviewer far-host:0

Once x11vnc establishes connections with the X11 server and starts listening
as a VNC server it will print out a string: PORT=XXXX where XXXX is typically
5900 (the default VNC server port).  One would next run something like
this on the local machine: "vncviewer hostname:N" where "hostname" is
the name of the machine running x11vnc and N is XXXX - 5900, i.e. usually
"vncviewer hostname:0".

By default x11vnc will not allow the screen to be shared and it will exit
as soon as the client disconnects.  See -shared and -forever below to override
these protections.  See the FAQ for details how to tunnel the VNC connection
through an encrypted channel such as ssh(1).  In brief:

       ssh -t -L 5900:localhost:5900 far-host 'x11vnc -localhost -display :0'

       vncviewer -encodings 'copyrect tight zrle hextile' localhost:0

Also, use of a VNC password (-rfbauth or -passwdfile) is strongly recommended.

For additional info see: http://www.karlrunge.com/x11vnc/
                    and  http://www.karlrunge.com/x11vnc/faq.html

Config file support: if the file $HOME/.x11vncrc exists then each line in
it is treated as a single command line option.  Disable with -norc.  For
each option name, the leading character "-" is not required.  E.g. a line
that is either "forever" or "-forever" may be used and are equivalent.
Likewise "wait 100" or "-wait 100" are acceptable and equivalent lines.
The "#" character comments out to the end of the line in the usual way
(backslash it for a literal).  Leading and trailing whitespace is trimmed off.
Lines may be continued with a "\" as the last character of a line (it
becomes a space character).

Options:

<a name="opt-display"></a>-display disp          X11 server display to connect to, usually :0\.  The X
                       server process must be running on same machine and
                       support MIT-SHM.  Equivalent to setting the DISPLAY
                       environment variable to "disp".

                       See the description below of the "-display WAIT:..."
                       extensions, where alias "-find" will find the user's
                       display automatically, and "-create" will create a
                       Xvfb session if no session is found.

<a name="opt-auth"></a>-auth file             Set the X authority file to be "file", equivalent to
                       setting the XAUTHORITY environment variable to "file"
                       before startup.  Same as -xauth file.  See Xsecurity(7),
                       xauth(1) man pages for more info.

                       Use '-auth guess' to have x11vnc use its -findauth
                       mechanism (described below) to try to guess the
                       XAUTHORITY filename and use it.

                       XDM/GDM/KDM: if you are running x11vnc as root and want
                       to find the XAUTHORITY before anyone has logged into an
                       X session yet, use: x11vnc -env FD_XDM=1 -auth guess ...
                       (This will also find the XAUTHORITY if a user is already
                       logged into the X session.)  When running as root,
                       FD_XDM=1 will be tried if the initial -auth guess fails.

<a name="opt-N"></a>-N                     If the X display is :N, try to set the VNC display to
                       also be :N This just sets the -rfbport option to 5900+N
                       The program will exit immediately if that port is not
                       available. The -N option only works with normal -display
                       usage, e.g. :0 or :8, -N is ignored in the -display
                       WAIT:..., -create, -find, -svc, -redirect, etc modes.

<a name="opt-autoport"></a>-autoport n            Automatically probe for a free VNC port starting at n.
                       The default is to start probing at 5900\.  Use this to
                       stay away from other VNC servers near 5900.

<a name="opt-rfbport"></a>-rfbport str           The VNC port to listen on (a LibVNCServer option), e.g.
                       5900, 5901, etc.  If specified as "-rfbport PROMPT"
                       then the x11vnc -gui is used to prompt the user to
                       enter the port number.

<a name="opt-6"></a>-6                     IPv6 listening support.  In addition to IPv4, the
                       IPv6 address is listened on for incoming connections.
                       The same port number as IPv4 is used.

                       NOTE:  This x11vnc binary was compiled to have the
                       "-6" IPv6 listening mode ENABLED by default (CPPFLAGS
                       -DX11VNC_LISTEN6=1).  So to disable IPv6 listening mode
                       you MUST supply the "-no6" option (see below.)

                       The "-6" mode works for both normal connections and
                       -ssl encrypted ones.  Nearly everything is supported
                       for the IPv6 case, but there are a few exceptions.
                       See -stunnel for its IPv6 support.

                       Currently, for absolutely everything to work correctly
                       the machine may need to have some IPv4 support, at the
                       least for the loopback interface.  However, for nearly
                       all usage modes no IPv4 support is required. See -nopiv4.

                       If you have trouble compiling or running in IPv6 mode,
                       set -DX11VNC_IPV6=0 in CPPFLAGS when configuring to
                       disable IPv6 support.

<a name="opt-no6"></a>-no6                   Disable IPv6 listening support (only useful if the
                       "-6" mode is compiled in to be the default; see the
                       X11VNC_LISTEN6 description above under "-6".)

<a name="opt-noipv6"></a>-noipv6                Do not try to use IPv6 for any listening or connecting
                       sockets.  This includes both the listening service
                       port(s) and outgoing connections from -connect,
                       -connect_or_exit, or -proxy.  Use this if you are having
                       problems due to IPv6.

<a name="opt-noipv4"></a>-noipv4                Do not try to use IPv4 for any listening or connecting
                       sockets.  This is mainly for exploring the behavior of
                       x11vnc on an IPv6-only system, but may have other uses.

<a name="opt-reopen"></a>-reopen                If the X server connection is disconnected, try to
                       reopen the X display (up to one time.)  This is of use
                       for display managers like GDM (KillInitClients option)
                       that kill x11vnc just after the user logs into the
                       X session.  Note: the reopened state may be unstable.
                       Set X11VNC_REOPEN_DISPLAY=n to reopen n times and
                       set X11VNC_REOPEN_SLEEP_MAX to the number of seconds,
                       default 10, to keep trying to reopen the display (once
                       per second.)

                       Update: as of 0.9.9, x11vnc tries to automatically avoid
                       being killed by the display manager by delaying creating
                       windows or using XFIXES.  So you shouldn't need to use
                       KillInitClients=false as long as you log in quickly
                       enough (within 45 seconds of connecting.)  You can
                       disable this by setting X11VNC_AVOID_WINDOWS=never.
                       You can also set it to the number of seconds to delay.

<a name="opt-reflect"></a>-reflect host:N        Instead of connecting to and polling an X display,
                       connect to the remote VNC server host:N and be a
                       reflector/repeater for it.  This is useful for trying
                       to manage the case of many simultaneous VNC viewers
                       (e.g. classroom broadcasting) where, e.g. you put
                       a repeater on each network switch, etc, to improve
                       performance by distributing the load and network
                       traffic.  Implies -shared (use -noshared as a later
                       option to disable). See the discussion below under
                       -rawfb vnc:host:N for more details.

<a name="opt-id"></a>-id windowid           Show the X window corresponding to "windowid" not
                       the entire display.  New windows like popup menus,
                       transient toplevels, etc, may not be seen or may be
                       clipped.  Disabling SaveUnders or BackingStore in the
                       X server may help show them.  x11vnc may crash if the
                       window is initially partially obscured, changes size,
                       is iconified, etc.  Some steps are taken to avoid this
                       and the -xrandr mechanism is used to track resizes.  Use
                       xwininfo(1) to get the window id, or use "-id pick"
                       to have x11vnc run xwininfo(1) for you and extract
                       the id.  The -id option is useful for exporting very
                       simple applications (e.g. the current view on a webcam).
<a name="opt-sid"></a>-sid windowid          As -id, but instead of using the window directly it
                       shifts a root view to it: this shows SaveUnders menus,
                       etc, although they will be clipped if they extend beyond
                       the window.

<a name="opt-tag"></a>-tag str               This option is ignored, but allows you to specify a
                       unique string on the x11vnc command line, for example
                       "-tag test34934z", this could enable a reliable
                       way to identify different x11vnc processes via their
                       command lines (see ps(1), pgrep(1), and pkill(1)
                       and /proc/PID/cmdline.)

<a name="opt-appshare"></a>-appshare              Simple application sharing based on the -id/-sid
                       mechanism.  Every new toplevel window that the
                       application creates induces a new viewer window via
                       a reverse connection.  The -id/-sid and -connect
                       options are required.  Run 'x11vnc -appshare -help'
                       for more info.

<a name="opt-clip"></a>-clip WxH+X+Y          Only show the sub-region of the full display that
                       corresponds to the rectangle geometry with size WxH and
                       offset +X+Y.  The VNC display has size WxH (i.e. smaller
                       than the full display).  This also works for -id/-sid
                       mode where the offset is relative to the upper left
                       corner of the selected window.  An example use of this
                       option would be to split a large (e.g. Xinerama) display
                       into two parts to be accessed via separate viewers by
                       running a separate x11vnc on each part.

                       Use '-clip xinerama0' to clip to the first xinerama
                       sub-screen (if xinerama is active).  xinerama1 for the
                       2nd sub-screen, etc.  This way you don't need to figure
                       out the WxH+X+Y of the desired xinerama sub-screen.
                       screens are sorted in increasing distance from the
                       (0,0) origin (I.e. not the Xserver's order).

<a name="opt-flashcmap"></a>-flashcmap             In 8bpp indexed color, let the installed colormap flash
                       as the pointer moves from window to window (slow).
                       Also try the -8to24 option to avoid flash altogether.
<a name="opt-shiftcmap"></a>-shiftcmap n           Rare problem, but some 8bpp displays use less than 256
                       colorcells (e.g. 16-color grayscale, perhaps the other
                       bits are used for double buffering) *and* also need to
                       shift the pixels values away from 0, .., ncells.  "n"
                       indicates the shift to be applied to the pixel values.
                       To see the pixel values set DEBUG_CMAP=1 to print out
                       a colormap histogram.  Example: -shiftcmap 240
<a name="opt-notruecolor"></a>-notruecolor           For 8bpp displays, force indexed color (i.e. a colormap)
                       even if it looks like 8bpp TrueColor (rare problem).
<a name="opt-advertise_truecolor"></a>-advertise_truecolor   If the X11 display is indexed color, lie to clients
                       when they first connect by telling them it is truecolor.
                       To workaround RealVNC: inPF has colourMap but not 8bpp
                       Use '-advertise_truecolor reset' to reset client fb too.

<a name="opt-visual"></a>-visual n              This option probably does not do what you think.
                       It simply *forces* the visual used for the framebuffer;
                       this may be a bad thing... (e.g. messes up colors or
                       cause a crash). It is useful for testing and for some
                       workarounds.  n may be a decimal number, or 0x hex.
                       Run xdpyinfo(1) for the values.  One may also use
                       "TrueColor", etc. see <X11/X.h> for a list.  If the
                       string ends in ":m" then for better or for worse
                       the visual depth is forced to be m.  You may want to
                       use -noshm when using this option (so XGetImage may
                       automatically translate the pixel data).

<a name="opt-overlay"></a>-overlay               Handle multiple depth visuals on one screen, e.g. 8+24
                       and 24+8 overlay visuals (the 32 bits per pixel are
                       packed with 8 for PseudoColor and 24 for TrueColor).

                       Currently -overlay only works on Solaris via
                       XReadScreen(3X11) and IRIX using XReadDisplay(3).
                       On Solaris there is a problem with image "bleeding"
                       around transient popup menus (but not for the menu
                       itself): a workaround is to disable SaveUnders
                       by passing the "-su" argument to Xsun (in
                       /etc/dt/config/Xservers).

                       Use -overlay as a workaround for situations like these:
                       Some legacy applications require the default visual to
                       be 8bpp (8+24), or they will use 8bpp PseudoColor even
                       when the default visual is depth 24 TrueColor (24+8).
                       In these cases colors in some windows will be incorrect
                       in x11vnc unless -overlay is used.  Another use of
                       -overlay is to enable showing the exact mouse cursor
                       shape (details below).

                       Under -overlay, performance will be somewhat slower
                       due to the extra image transformations required.
                       For optimal performance do not use -overlay, but rather
                       configure the X server so that the default visual is
                       depth 24 TrueColor and try to have all apps use that
                       visual (e.g. some apps have -use24 or -visual options).
<a name="opt-overlay_nocursor"></a>-overlay_nocursor      Sets -overlay, but does not try to draw the exact mouse
                       cursor shape using the overlay mechanism.

<a name="opt-8to24"></a>-8to24 [opts]          Try this option if -overlay is not supported on your
                       OS, and you have a legacy 8bpp app that you want to
                       view on a multi-depth display with default depth 24
                       (and is 32 bpp) OR have a default depth 8 display with
                       depth 24 overlay windows for some apps.  This option
                       may not work on all X servers and hardware (tested
                       on XFree86/Xorg mga driver and Xsun).  The "opts"
                       string is not required and is described below.

                       This mode enables a hack where x11vnc monitors windows
                       within 3 levels from the root window.  If it finds
                       any that are 8bpp it extracts the indexed color
                       pixel values using XGetImage() and then applies a
                       transformation using the colormap(s) to create TrueColor
                       RGB values that it in turn inserts into bits 1-24 of
                       the framebuffer.  This creates a depth 24 "view"
                       of the display that is then exported via VNC.

                       Conversely, for default depth 8 displays, the depth
                       24 regions are read by XGetImage() and everything is
                       transformed and inserted into a depth 24 TrueColor
                       framebuffer.

                       Note that even if there are *no* depth 24 visuals or
                       windows (i.e. pure 8bpp), this mode is potentially
                       an improvement over -flashcmap because it avoids the
                       flashing and shows each window in the correct color.

                       This method works OK, but may still have bugs and it
                       does hog resources.  If there are multiple 8bpp windows
                       using different colormaps, one may have to iconify all
                       but one for the colors to be correct.

                       There may be painting errors for clipping and switching
                       between windows of depths 8 and 24\.  Heuristics are
                       applied to try to minimize the painting errors.  One can
                       also press 3 Alt_L's in a row to refresh the screen
                       if the error does not repair itself.  Also the option
                       -fixscreen 8=3.0 or -fixscreen V=3.0 may be used to
                       periodically refresh the screen at the cost of bandwidth
                       (every 3 sec for this example).

                       The [opts] string can contain the following settings.
                       Multiple settings are separated by commas.

                       For for some X servers with default depth 24 a
                       speedup may be achieved via the option "nogetimage".
                       This enables a scheme were XGetImage() is not used
                       to retrieve the 8bpp data.  Instead, it assumes that
                       the 8bpp data is in bits 25-32 of the 32bit X pixels.
                       There is no requirement that the X server should put
                       the data there for our poll requests, but some do and
                       so the extra steps to retrieve it can be skipped.
                       Tested with mga driver with XFree86/Xorg.  For the
                       default depth 8 case this option is ignored.

                       To adjust how often XGetImage() is used to poll the
                       non-default visual regions for changes, use the option
                       "poll=t" where "t" is a floating point time.
                       (default: 0.05)

                       Setting the option "level2" will limit the search
                       for non-default visual windows to two levels from the
                       root window.  Do this on slow machines where you know
                       the window manager only imposes one extra window between
                       the app window and the root window.

                       Also for very slow machines use "cachewin=t"
                       where t is a floating point amount of time to cache
                       XGetWindowAttributes results.  E.g. cachewin=5.0.
                       This may lead to the windows being unnoticed for this
                       amount of time when deiconifying, painting errors, etc.

                       While testing on a very old SS20 these options gave
                       tolerable response: -8to24 poll=0.2,cachewin=5.0\. For
                       this machine -overlay is supported and gives better
                       response.

                       Debugging for this mode can be enabled by setting
                       "dbg=1", "dbg=2", or "dbg=3".

<a name="opt-24to32"></a>-24to32                Very rare problem: if the framebuffer (X display
                       or -rawfb) is 24bpp instead of the usual 32bpp, then
                       dynamically transform the pixels to 32bpp.  This will be
                       slower, but can be used to work around problems where
                       VNC viewers cannot handle 24bpp (e.g. "main: setPF:
                       not 8, 16 or 32 bpp?").  See the FAQ for more info.

                       In the case of -rawfb mode, the pixels are directly
                       modified by inserting a 0 byte to pad them out to 32bpp.
                       For X displays, a kludge is done that is equivalent to
                       "-noshm -visual TrueColor:32".  (If better performance
                       is needed for the latter, feel free to ask).

<a name="opt-scale"></a>-scale fraction        Scale the framebuffer by factor "fraction".  Values
                       less than 1 shrink the fb, larger ones expand it. Note:
                       the image may not be sharp and response may be slower.
                       If "fraction" contains a decimal point "." it
                       is taken as a floating point number, alternatively
                       the notation "m/n" may be used to denote fractions
                       exactly, e.g. -scale 2/3

                       To scale asymmetrically in the horizontal and vertical
                       directions, specify a WxH geometry to stretch to:
                       e.g. '-scale 1024x768', or also '-scale 0.9x0.75'

                       Scaling Options: can be added after "fraction" via
                       ":", to supply multiple ":" options use commas.
                       If you just want a quick, rough scaling without
                       blending, append ":nb" to "fraction" (e.g. -scale
                       1/3:nb).  No blending is the default for 8bpp indexed
                       color, to force blending for this case use ":fb".

                       To disable -scrollcopyrect and -wirecopyrect under
                       -scale use ":nocr".  If you need to to enable them use
                       ":cr" or specify them explicitly on the command line.
                       If a slow link is detected, ":nocr" may be applied
                       automatically.  Default: :cr

                       More esoteric options: for compatibility with vncviewers
                       the scaled width is adjusted to be a multiple of 4:
                       to disable this use ":n4".  ":in" use interpolation
                       scheme even when shrinking, ":pad" pad scaled width
                       and height to be multiples of scaling denominator
                       (e.g. 3 for 2/3).

<a name="opt-geometry"></a>-geometry WxH          Same as -scale WxH

<a name="opt-scale_cursor"></a>-scale_cursor frac     By default if -scale is supplied the cursor shape is
                       scaled by the same factor.  Depending on your usage,
                       you may want to scale the cursor independently of the
                       screen or not at all.  If you specify -scale_cursor
                       the cursor will be scaled by that factor.  When using
                       -scale mode to keep the cursor at its "natural" size
                       use "-scale_cursor 1".  Most of the ":" scaling
                       options apply here as well.

<a name="opt-viewonly"></a>-viewonly              All VNC clients can only watch (default off).
<a name="opt-shared"></a>-shared                VNC display is shared, i.e. more than one viewer can
                       connect at the same time (default off).
<a name="opt-once"></a>-once                  Exit after the first successfully connected viewer
                       disconnects, opposite of -forever. This is the Default.
<a name="opt-forever"></a>-forever               Keep listening for more connections rather than exiting
                       as soon as the first client(s) disconnect. Same as -many

                       To get the standard non-shared VNC behavior where when
                       a new VNC client connects the existing VNC client is
                       dropped use:  -nevershared -forever   This method can
                       also be used to guard against hung TCP connections that
                       do not go away.

<a name="opt-loop"></a>-loop                  Create an outer loop restarting the x11vnc process
                       whenever it terminates.  -bg and -inetd are ignored
                       in this mode (however see -loopbg below).

                       Useful for continuing even if the X server terminates
                       and restarts (at that moment the process will need
                       permission to reconnect to the new X server of course).

                       Use, e.g., -loop100 to sleep 100 millisecs between
                       restarts, etc.  Default is 2000ms (i.e. 2 secs) Use,
                       e.g. -loop300,5 to sleep 300 ms and only loop 5 times.

                       If -loopbg (plus any numbers) is specified instead,
                       the "-bg" option is implied and the mode approximates
                       inetd(8) usage to some degree.  In this case when
                       it goes into the background any listening sockets
                       (i.e. ports 5900, 5800) are closed, so the next one
                       in the loop can use them.  This mode will only be of
                       use if a VNC client (the only client for that process)
                       is already connected before the process goes into the
                       background, for example, usage of -display WAIT:..,
                       -svc, and -connect can make use of this "poor man's"
                       inetd mode.  The default wait time is 500ms in this
                       mode.  This usage could use useful:  -svc -bg -loopbg

<a name="opt-timeout"></a>-timeout n             Exit unless a client connects within the first n seconds
                       after startup.

                       If there have been no connection attempts after n
                       seconds x11vnc exits immediately.  If a client is
                       trying to connect but has not progressed to the normal
                       operating state, x11vnc gives it a few more seconds
                       to finish and exits if it does not make it to the
                       normal state.

                       For reverse connections via -connect or -connect_or_exit
                       a timeout of n seconds will be set for all reverse
                       connects.  If the connect timeout alarm goes off,
                       x11vnc will exit immediately.

<a name="opt-sleepin"></a>-sleepin n             At startup sleep n seconds before proceeding (e.g. to
                       allow redirs and listening clients to start up)

                       If a range is given: '-sleepin min-max', a random value
                       between min and max is slept. E.g. '-sleepin 0-20' and
                       '-sleepin 10-30'.  Floats are allowed too.

<a name="opt-inetd"></a>-inetd                 Launched by inetd(8): stdio instead of listening socket.
                       Note: if you are not redirecting stderr to a log file
                       (via shell 2> or -o option) you MUST also specify the -q
                       option, otherwise the stderr goes to the viewer which
                       will cause it to abort.  Specifying both -inetd and -q
                       and no -o will automatically close the stderr.

                       If the libvncserver used supports non AF_INET sockets
                       (the one bundled in x11vnc 0.9.13 and later does),
                       then -inetd mode can be used for a raw stdio pipe. For
                       example, using the SSVNC viewer exec=... mechanism:

                        ssvnc -viewer exec="ssh -tt -e none user@host \
                               'x11vnc -inetd -o log.txt -display :0'"

                       where the long cmdline has been split.  In the above
                       the only TCP connection is that of the ssh connection.
                       There is no port redirection (-L), etc.; raw stdio is
                       used on both sides of the ssh.  In some cases the -tt
                       option is not needed.

<a name="opt-tightfilexfer"></a>-tightfilexfer         Enable the TightVNC file transfer extension. Note that
                       that when the -viewonly option is supplied all file
                       transfers are disabled.  Also clients that log in
                       viewonly cannot transfer files.  However, if the remote
                       control mechanism is used to change the global or
                       per-client viewonly state the filetransfer permissions
                       will NOT change.

                       IMPORTANT: please understand if -tightfilexfer is
                       specified and you run x11vnc as root for, say, inetd
                       or display manager (gdm, kdm, ...) access and you do
                       not have it switch users via the -users option, then
                       VNC Viewers that connect are able to do filetransfer
                       reads and writes as *root*.

                       Also, tightfilexfer is disabled in -unixpw mode.

<a name="opt-ultrafilexfer"></a>-ultrafilexfer         Note: to enable UltraVNC filetransfer and to get it to
                       work you probably need to supply these LibVNCServer
                       options: "-rfbversion 3.6 -permitfiletransfer"
                       "-ultrafilexfer" is an alias for this combination.

                       IMPORTANT: please understand if -ultrafilexfer is
                       specified and you run x11vnc as root for, say, inetd
                       or display manager (gdm, kdm, ...) access and you do
                       not have it switch users via the -users option, then
                       VNC Viewers that connect are able to do filetransfer
                       reads and writes as *root*.

                       Note that sadly you cannot do both -tightfilexfer and
                       -ultrafilexfer at the same time because the latter
                       requires setting the version to 3.6 and tightvnc will
                       not do filetransfer when it sees that version number.

<a name="opt-http"></a>-http                  Instead of using -httpdir (see below) to specify
                       where the Java vncviewer applet is, have x11vnc try
                       to *guess* where the directory is by looking relative
                       to the program location and in standard locations
                       (/usr/local/share/x11vnc/classes, etc).  Under -ssl or
                       -stunnel the ssl classes subdirectory is sought.
<a name="opt-http_ssl"></a>-http_ssl              As -http, but force lookup for ssl classes subdir.

                       Note that for HTTPS, single-port Java applet delivery
                       you can set X11VNC_HTTPS_DOWNLOAD_WAIT_TIME to the
                       max number of seconds to wait for the applet download
                       to finish.  The default is 15.

<a name="opt-avahi"></a>-avahi                 Use the Avahi/mDNS ZeroConf protocol to advertise
                       this VNC server to the local network. (Related terms:
                       Rendezvous, Bonjour).  Depending on your setup, you
                       may need to start avahi-daemon and open udp port 5353
                       in your firewall.

                       You can set X11VNC_AVAHI_NAME, X11VNC_AVAHI_HOST,
                       and/or X11VNC_AVAHI_PORT environment variables
                       to override the default values.  For example:
                       -env X11VNC_AVAHI_NAME=wally

                       If the avahi API cannot be found at build time, a helper
                       program like avahi-publish(1) or dns-sd(1) will be tried

<a name="opt-mdns"></a>-mdns                  Same as -avahi.
<a name="opt-zeroconf"></a>-zeroconf              Same as -avahi.

<a name="opt-connect"></a>-connect string        For use with "vncviewer -listen" reverse connections.
                       If "string" has the form "host" or "host:port"
                       the connection is made once at startup.

                       Use commas for a list of host's and host:port's.
                       E.g. -connect host1,host2 or host1:0,host2:5678.
                       Note that to reverse connect to multiple hosts at the
                       same time you will likely need to also supply: -shared

                       Note that unlike most vnc servers, x11vnc will require a
                       password for reverse as well as for forward connections.
                       (provided password auth has been enabled, -rfbauth, etc)
                       If you do not want to require a password for reverse
                       connections set X11VNC_REVERSE_CONNECTION_NO_AUTH=1 in
                       your environment before starting x11vnc.

                       If "string" contains "/" it is instead interpreted
                       as a file to periodically check for new hosts.
                       The first line is read and then the file is truncated.
                       Be careful about the location of this file if x11vnc
                       is running as root (e.g. via gdm(1), etc).

                       Repeater mode: Some services provide an intermediate
                       "vnc repeater": http://www.uvnc.com/addons/repeater.html
                       (and also http://koti.mbnet.fi/jtko/ for linux port)
                       that acts as a proxy/gateway.  Modes like these require
                       an initial string to be sent for the reverse connection
                       before the VNC protocol is started.  Here are the ways
                       to do this:

                         -connect pre=some_string+host:port
                         -connect pre128=some_string+host:port
                         -connect repeater=ID:1234+host:port
                         -connect repeater=23.45.67.89::5501+host:port

                       SSVNC notation is also supported:

                         -connect repeater://host:port+ID:1234

                       As with normal -connect usage, if the repeater port is
                       not supplied 5500 is assumed.

                       The basic idea is between the special tag, e.g. "pre="
                       and "+" is the pre-string to be sent.  Note that in
                       this case host:port is the repeater server, NOT the
                       vnc viewer.  Somehow the pre-string tells the repeater
                       server how to find the vnc viewer and connect you to it.

                       In the case pre=some_string+host:port, "some_string"
                       is simply sent. In the case preNNN=some_string+host:port
                       "some_string" is sent in a null padded buffer of
                       length NNN.  repeater= is the same as pre250=, this is
                       the ultravnc repeater buffer size.

                       Strings like "\n" and "\r", etc. are expanded to
                       newline and carriage return.  "\c" is expanded to
                       "," since the connect string is comma separated.

                       See also the -proxy option below for additional ways
                       to plumb reverse connections.

                       Reverse SSL: using -connect in -ssl mode makes x11vnc
                       act as an SSL client (initiates SSL connection) rather
                       than an SSL server.  The idea is x11vnc might be
                       connecting to stunnel on the viewer side with the
                       viewer in listening mode.  If you do not want this
                       behavior, use -env X11VNC_DISABLE_SSL_CLIENT_MODE=1.
                       With this the viewer side can act as the SSL client
                       as it normally does for forward connections.

                       Reverse SSL Repeater mode:  This will work, but note
                       that if the VNC Client does any sort of a 'Fetch Cert'
                       action before connecting, then the Repeater will
                       likely drop the connection and both sides will need
                       to restart.  Consider the use of -connect_or_exit
                       and -loop300,2 to have x11vnc reconnect once to the
                       repeater after the fetch.  You will probably also want
                       to supply -sslonly to avoid x11vnc thinking the delay
                       in response means the connection is VeNCrypt.  The env
                       var X11VNC_DISABLE_SSL_CLIENT_MODE=1 discussed above
                       may also be useful (i.e. the viewer can do a forward
                       connection as it normally does.)

                       IPv6: as of x11vnc 0.9.10 the -connect option should
                       connect to IPv6 hosts properly.  If there are problems
                       you can disable IPv6 by setting -DX11VNC_IPV6=0
                       in CPPFLAGS when configuring.  If there problems
                       connecting to IPv6 hosts consider a relay like the
                       included inet6to4 script or the -proxy option.

<a name="opt-connect_or_exit"></a>-connect_or_exit str   As with -connect, except if none of the reverse
                       connections succeed, then x11vnc shuts down immediately

                       An easier to type alias for this option is '-coe'

                       By the way, if you do not want x11vnc to listen on
                       ANY interface use -rfbport 0  which is handy for the
                       -connect_or_exit mode.

<a name="opt-proxy"></a>-proxy string          Use proxy in string (e.g. host:port) as a proxy for
                       making reverse connections (-connect or -connect_or_exit
                       options).

                       Web proxies are supported, but note by default most of
                       them only support destination connections to ports 443
                       or 563, so this might not be very useful (the viewer
                       would need to listen on that port or the router would
                       have to do a port redirection).

                       A web proxy may be specified by either "host:port"
                       or "http://host:port" (the port is required even if
                       it is the common choices 80 or 8080)

                       SOCKS4, SOCKS4a, and SOCKS5 are also supported.
                       SOCKS proxies normally do not have restrictions on the
                       destination port number.

                       Use a format like this: socks://host:port or
                       socks5://host:port.  Note that ssh -D does not support
                       SOCKS4a, so use socks5://.  For socks:// SOCKS4 is used
                       on a numerical IP and "localhost", otherwise SOCKS4a
                       is used (and so the proxy tries to do the DNS lookup).

                       An experimental mode is "-proxy http://host:port/..."
                       Note the "/" after the port that distinguishes it from
                       a normal web proxy.  The port must be supplied even if
                       it is the default 80\.  For this mode a GET is done to
                       the supplied URL with the string host=H&port=P appended.
                       H and P will be the -connect reverse connect host
                       and port.  Use the string "__END__" to disable the
                       appending.  The basic idea here is that maybe some cgi
                       script provides the actual viewer hookup and tunnelling.
                       How to actually achieve this within cgi, php, etc. is
                       not clear...  A custom web server or apache module
                       would be straight-forward.

                       Another experimental mode is "-proxy ssh://user@host"
                       in which case a SSH tunnel is used for the proxying.
                       "user@" is not needed unless your unix username is
                       different on "host".  For a non-standard SSH port
                       use ssh://user@host:port.  If proxies are chained (see
                       next paragraph) then the ssh one must be the first one.
                       If ssh-agent is not active, then the ssh password needs
                       to be entered in the terminal where x11vnc is running.
                       Examples:

                         -connect localhost:0 -proxy ssh://me@friends-pc:2222

                         -connect snoopy:0 -proxy ssh://ssh.company.com

                       Multiple proxies may be chained together in case one
                       needs to ricochet off of a number of hosts to finally
                       reach the VNC viewer.  Up to 3 may be chained, separate
                       them by commas in the order they are to be connected to.
                       E.g.:  http://host1:port1,socks5://host2:port2 or three
                       like:  first,second,third

                       IPv6: as of x11vnc 0.9.10 the -proxy option should
                       connect to IPv6 hosts properly.  If there are problems
                       you can disable IPv6 by setting -DX11VNC_IPV6=0
                       in CPPFLAGS when configuring.  If there problems
                       connecting to IPv6 hosts consider a relay like the
                       included inet6to4 script.

<a name="opt-vncconnect"></a>-vncconnect            Monitor the VNC_CONNECT X property set by the standard
<a name="opt-novncconnect"></a>-novncconnect          VNC program vncconnect(1).  When the property is
                       set to "host" or "host:port" establish a reverse
                       connection.  Using xprop(1) instead of vncconnect may
                       work (see the FAQ).  The -remote control mechanism uses
                       X11VNC_REMOTE channel, and this option disables/enables
                       it as well.  Default: -vncconnect

                       To use different names for these X11 properties (e.g. to
                       have separate communication channels for multiple
                       x11vnc's on the same display) set the VNC_CONNECT or
                       X11VNC_REMOTE env. vars. to the string you want, for
                       example: -env X11VNC_REMOTE=X11VNC_REMOTE_12345
                       Both sides of the channel must use the same unique name.
                       The same can be done for the internal X11VNC_TICKER
                       property (heartbeat and timestamp) if desired.

<a name="opt-allow"></a>-allow host1[,host2..] Only allow client connections from hosts matching the
                       comma separated list of hostnames or IP addresses.
                       By ending in a ".", it can also be a numerical
                       IP prefix, e.g. "192.168.100." to match a simple
                       subnet, for more control build LibVNCServer with
                       libwrap support (See the FAQ).  If the list contains a
                       "/" it instead is a interpreted as a file containing
                       addresses or prefixes that is re-read each time a new
                       client connects.  Lines can be commented out with the
                       "#" character in the usual way.

                       -allow applies in -ssl mode, but not in -stunnel mode.

                       IPv6: as of x11vnc 0.9.10 a host can be specified
                       in IPv6 numerical format, e.g. 2001:4860:b009::93

                       Env. vars: Set -env X11VNC_DEBUG_ACCESS=1 to print out
                       debugging info during the check_access() call.  Set -env
                       X11VNC_ALLOW_FULLMATCH=1 to force a full string match,
                       that is, no subnet "." matching will be performed.

                       Unix sockets: if -unixsock is being used and you want
                       to limit TCP access also you must also include the
                       path to the unix socket prefixed with "unix=" in the
                       allow list, e.g.: -allow 192.168.100.3,unix=/tmp/mysock
                       If the socket is not a named one, e.g. created via
                       socketpair(2) with -inetd, then you must supply
                       the generic name x11vnc gives to it, e.g. -allow
                       192.168.100.3,UNNAMED_AF_UNIX In both cases it must
                       be an exact string match to be allowed to connect.
                       Note that since you completely control these local
                       non-TCP access methods by file system permissions, etc.,
                       it is not useful to guard against them with -allow,
                       however you still need to have them in the allow list
                       to let them connect.

<a name="opt-localhost"></a>-localhost             Basically the same as "-allow 127.0.0.1".

                       Note: if you want to restrict which network interface
                       x11vnc listens on, see the -listen option below.
                       E.g. "-listen localhost" or "-listen 192.168.3.21".
                       As a special case, the option "-localhost" implies
                       "-listen localhost".

                       A rare case, but for non-localhost -listen usage, if
                       you use the remote control mechanism (-R) to change
                       the -listen interface you may need to manually adjust
                       the -allow list (and vice versa) to avoid situations
                       where no connections (or too many) are allowed.

                       If you do not want x11vnc to listen on ANY TCP interface
                       (evidently you are using -connect or -connect_or_exit,
                       or plan to use remote control: -R connect:host, or to
                       use -unixsock), specify -rfbport 0

                       IPv6: if IPv6 is supported, this option automatically
                       implies the IPv6 loopback address '::1' as well.

<a name="opt-unixsock"></a>-unixsock str          In addition to the regular TCP port, listen on the
                       unix socket (AF_UNIX) 'str' for incoming connections.
                       This mode is for either local connections or a tunnel
                       endpoint where one wants the file permission of the
                       unix socket file to determine what can connect to it.
                       Example:
                                mkdir ~/s; chmod 700 ~/s;
                                x11vnc -unixsock ~/s/mysock -rfbport 0 ...
                       same as:
                                x11vnc -unixsockonly ~/s/mysock ...
                       (see -unixsockonly below.)

                       This mode currently requires the modified libvncserver
                       bundled in the the x11vnc 0.9.13 tarball and later.

                       Note that the SSVNC unix vncviewer can connect to unix
                       sockets, for example: ssvnc -viewer unix=./s/mysock

                       As a special mechanism, if 'str' for either -unixsock
                       or -unixsockonly is of the form "fd=n" where n is a
                       non-negative decimal integer, then instead of creating
                       a unix socket, that file descriptor (assumed already
                       opened and O_RDWR) will be attached as a VNC client.
                       Perhaps the program that execs x11vnc has created a
                       socketpair(2) to communicate over.  Use this mechanism
                       if -inetd (which is basically fd=0) is not flexible
                       enough for you.

<a name="opt-unixsockonly"></a>-unixsockonly str      Listen on unix socket 'str' only, no TCP ports. First
                       note that one can disable all tcp listening ports by
                       specifying '-rfbport 0'. The option '-unixsockonly str'
                       is functionally equivalent to '-unixsock str -rfbport 0'

<a name="opt-listen6"></a>-listen6 str           When in IPv6 listen mode "-6", listen only on the
                       network interface with address "str".  It also works
                       for link scope addresses (fe80::219:dbff:fee5:3f92%eth0)
                       and IPv6 hostname strings (e.g. ipv6.google.com.)
                       Use LibVNCServer -listen option for the IPv4 interface.

<a name="opt-nolookup"></a>-nolookup              Do not use gethostbyname() or gethostbyaddr() to look up
                       host names or IP numbers.  Use this if name resolution
                       is incorrectly set up and leads to long pauses as name
                       lookups time out, etc.

<a name="opt-input"></a>-input string          Fine tuning of allowed user input.  If "string" does
                       not contain a comma "," the tuning applies only to
                       normal clients.  Otherwise the part before "," is
                       for normal clients and the part after for view-only
                       clients.  "K" is for Keystroke input, "M" for
                       Mouse-motion input, "B" for Button-click input, "C"
                       is for Clipboard input, and "F" is for File transfer
                       (ultravnc only).  Their presence in the string enables
                       that type of input.  E.g. "-input M" means normal
                       users can only move the mouse and  "-input KMBCF,M"
                       lets normal users do anything and enables view-only
                       users to move the mouse.  This option is ignored when
                       a global -viewonly is in effect (all input is discarded
                       in that case).

<a name="opt-grabkbd"></a>-grabkbd               When VNC viewers are connected, attempt to the grab
                       the keyboard so a (non-malicious) user sitting at the
                       physical display is not able to enter keystrokes.
                       This method uses XGrabKeyboard(3X11) and so it is
                       not secure and does not rule out the person at the
                       physical display injecting keystrokes by flooding the
                       server with them, grabbing the keyboard himself, etc.
                       Some degree of cooperation from the person at the
                       display is assumed.  This is intended for remote
                       help-desk or educational usage modes.

                       Note: on some recent (12/2010) X servers and/or
                       desktops, -grabkbd no longer works: it prevents the
                       window manager from resizing windows and similar things.
                       Try -ungrabboth below (might not work.)

<a name="opt-grabptr"></a>-grabptr               As -grabkbd, but for the mouse pointer using
                       XGrabPointer(3X11).  Unfortunately due to the way the X
                       server works, the mouse can still be moved around by the
                       user at the physical display, but he will not be able to
                       change window focus with it.  Also some window managers
                       that call XGrabServer(3X11) for resizes, etc, will
                       act on the local user's input.  Again, some degree of
                       cooperation from the person at the display is assumed.

<a name="opt-ungrabboth"></a>-ungrabboth            Whenever there is any input (either keyboard or
                       pointer), ungrab *both* the keyboard and the pointer
                       while injecting the synthetic input.  This is to allow
                       window managers, etc. a chance to grab.

<a name="opt-grabalways"></a>-grabalways            Apply both -grabkbd and -grabptr even when no VNC
                       viewers are connected.  If you only want one of them,
                       use the -R remote control to turn the other back on,
                       e.g. -R nograbptr.

                       (PASSWORDS: Note that the LibVNCServer password options
                        "-rfbauth file" and "-passwd str" are described at
                       the bottom of the help output.)

<a name="opt-viewpasswd"></a>-viewpasswd string     Supply a 2nd password for view-only logins.  The -passwd
                       (full-access) password must also be supplied.

<a name="opt-passwdfile"></a>-passwdfile filename   Specify the LibVNCServer password via the first line
                       of the file "filename" (instead of via -passwd on
                       the command line where others might see it via ps(1)).

                       See the descriptions below for how to supply multiple
                       passwords, view-only passwords, to specify external
                       programs for the authentication, and other features.

                       If the filename is prefixed with "rm:" it will be
                       removed after being read.  Perhaps this is useful in
                       limiting the readability of the file.  In general, the
                       password file should not be readable by untrusted users
                       (BTW: neither should the VNC -rfbauth file: it is NOT
                       encrypted, only obscured with a fixed key).

                       If the filename is prefixed with "read:" it will
                       periodically be checked for changes and reread.  It is
                       guaranteed to be reread just when a new client connects
                       so that the latest passwords will be used.

                       If "filename" is prefixed with "cmd:" then the
                       string after the ":" is run as an external command:
                       the output of the command will be interpreted as if it
                       were read from a password file (see below).  If the
                       command does not exit with 0, then x11vnc terminates
                       immediately.  To specify more than 1000 passwords this
                       way set X11VNC_MAX_PASSWDS before starting x11vnc.
                       The environment variables are set as in -accept.

                       Note that due to the VNC protocol only the first 8
                       characters of a password are used (DES key).

                       If "filename" is prefixed with "custom:" then a
                       custom password checker is supplied as an external
                       command following the ":". The command will be run
                       when a client authenticates.  If the command exits with
                       0 the client is accepted, otherwise it is rejected.
                       The environment variables are set as in -accept.

                       The standard input to the custom command will be a
                       decimal digit "len" followed by a newline. "len"
                       specifies the challenge size and is usually 16 (the
                       VNC spec).  Then follows len bytes which is the random
                       challenge string that was sent to the client. This is
                       then followed by len more bytes holding the client's
                       response (i.e. the challenge string encrypted via DES
                       with the user password in the standard situation).

                       The "custom:" scheme can be useful to implement
                       dynamic passwords or to implement methods where longer
                       passwords and/or different encryption algorithms
                       are used.  The latter will require customizing the VNC
                       client as well.  One could create an MD5SUM based scheme
                       for example.  See also -unixpw_cmd below.

                       File format for -passwdfile:

                       If multiple non-blank lines exist in the file they are
                       all taken as valid passwords.  Blank lines are ignored.
                       Password lines may be "commented out" (ignored) if
                       they begin with the character "#" or the line contains
                       the string "__SKIP__".  Lines may be annotated by use
                       of the "__COMM__" string: from it to the end of the
                       line is ignored.  An empty password may be specified
                       via the "__EMPTY__" string on a line by itself (note
                       your viewer might not accept empty passwords).

                       If the string "__BEGIN_VIEWONLY__" appears on a
                       line by itself, the remaining passwords are used for
                       viewonly access.  For compatibility, as a special case
                       if the file contains only two password lines the 2nd
                       one is automatically taken as the viewonly password.
                       Otherwise the "__BEGIN_VIEWONLY__" token must be
                       used to have viewonly passwords.  (tip: make the 3rd
                       and last line be "__BEGIN_VIEWONLY__" to have 2
                       full-access passwords)

<a name="opt-showrfbauth"></a>-showrfbauth filename  Print to the screen the obscured VNC password kept in
                       the rfbauth file "filename" and then exit.

<a name="opt-usepw"></a>-usepw                 If no other password method was supplied on the command
                       line, first look for ~/.vnc/passwd and if found use it
                       with -rfbauth; next, look for ~/.vnc/passwdfile and
                       use it with -passwdfile; otherwise, prompt the user
                       for a password to create ~/.vnc/passwd and use it with
                       the -rfbauth option.  If none of these succeed x11vnc
                       exits immediately.

<a name="opt-storepasswd"></a>-storepasswd pass file Store password "pass" as the VNC password in the
                       file "file".  Once the password is stored the
                       program exits.  Use the password via "-rfbauth file"

                       If called with no arguments, "x11vnc -storepasswd",
                       the user is prompted for a password and it is stored
                       in the file ~/.vnc/passwd.  Called with one argument,
                       that will be the file to store the prompted password in.

<a name="opt-nopw"></a>-nopw                  Disable the big warning message when you use x11vnc
                       without some sort of password.

<a name="opt-accept"></a>-accept string         Run a command (possibly to prompt the user at the
                       X11 display) to decide whether an incoming client
                       should be allowed to connect or not.  "string" is
                       an external command run via system(3) or some special
                       cases described below.  Be sure to quote "string"
                       if it contains spaces, shell characters, etc.  If the
                       external command returns 0 the client is accepted,
                       otherwise the client is rejected.  See below for an
                       extension to accept a client view-only.

                       If x11vnc is running as root (say from inetd(8) or from
                       display managers xdm(1), gdm(1), etc), think about the
                       security implications carefully before supplying this
                       option (likewise for the -gone option).

                       Environment: The RFB_CLIENT_IP environment variable will
                       be set to the incoming client IP number and the port
                       in RFB_CLIENT_PORT (or -1 if unavailable).  Similarly,
                       RFB_SERVER_IP and RFB_SERVER_PORT (the x11vnc side
                       of the connection), are set to allow identification
                       of the tcp virtual circuit.  The x11vnc process
                       id will be in RFB_X11VNC_PID, a client id number in
                       RFB_CLIENT_ID, and the number of other connected clients
                       in RFB_CLIENT_COUNT.  RFB_MODE will be "accept".
                       RFB_STATE will be PROTOCOL_VERSION, SECURITY_TYPE,
                       AUTHENTICATION, INITIALISATION, NORMAL, or UNKNOWN
                       indicating up to which state the client has achieved.
                       RFB_LOGIN_VIEWONLY will be 0, 1, or -1 (unknown).
                       RFB_USERNAME, RFB_LOGIN_TIME, and RFB_CURRENT_TIME may
                       also be set.

                       If "string" is "popup" then a builtin popup window
                       is used.  The popup will time out after 120 seconds,
                       use "popup:N" to modify the timeout to N seconds
                       (use 0 for no timeout).

                       In the case of "popup" and when the -unixpw option
                       is specified, then a *second* window will be popped
                       up after the user successfully logs in via his UNIX
                       password.  This time the user will be identified as
                       UNIX:username@hostname, the "UNIX:" prefix indicates
                       which user the viewer logged as via -unixpw.  The first
                       popup is only for whether to allow him to even *try*
                       to login via unix password.

                       If "string" is "xmessage" then an xmessage(1)
                       invocation is used for the command.  xmessage must be
                       installed on the machine for this to work.

                       Both "popup" and "xmessage" will present an option
                       for accepting the client "View-Only" (the client
                       can only watch).  This option will not be presented if
                       -viewonly has been specified, in which case the entire
                       display is view only.

                       If the user supplied command is prefixed with something
                       like "yes:0,no:*,view:3 mycommand ..." then this
                       associates the numerical command return code with
                       the actions: accept, reject, and accept-view-only,
                       respectively.  Use "*" instead of a number to indicate
                       the default action (in case the command returns an
                       unexpected value).  E.g. "no:*" is a good choice.

                       Note that x11vnc blocks while the external command
                       or popup is running (other clients may see no updates
                       during this period).  So a person sitting a the physical
                       display is needed to respond to an popup prompt. (use
                       a 2nd x11vnc if you lock yourself out).

                       More -accept tricks: use "popupmouse" to only allow
                       mouse clicks in the builtin popup to be recognized.
                       Similarly use "popupkey" to only recognize
                       keystroke responses.  These are to help avoid the
                       user accidentally accepting a client by typing or
                       clicking. All 3 of the popup keywords can be followed
                       by +N+M to supply a position for the popup window.
                       The default is to center the popup window.
<a name="opt-afteraccept"></a>-afteraccept string    As -accept, except to run a user supplied command after
                       a client has been accepted and authenticated. RFB_MODE
                       will be set to "afteraccept" and the other RFB_*
                       variables are as in -accept.  Unlike -accept, the
                       command return code is not interpreted by x11vnc.
                       Example: -afteraccept 'killall xlock &'
<a name="opt-gone"></a>-gone string           As -accept, except to run a user supplied command when
                       a client goes away (disconnects).  RFB_MODE will be
                       set to "gone" and the other RFB_* variables are as
                       in -accept.  The "popup" actions apply as well.
                       Unlike -accept, the command return code is not
                       interpreted by x11vnc.  Example: -gone 'xlock &'

<a name="opt-unixpw"></a>-unixpw [list]         Use Unix username and password authentication.  x11vnc
                       will use the su(1) program to verify the user's
                       password.  [list] is an optional comma separated list
                       of allowed Unix usernames.  If the [list] string begins
                       with the character "!" then the entire list is taken
                       as an exclude list.  See below for per-user options
                       that can be applied.

                       A familiar "login:" and "Password:" dialog is
                       presented to the user on a black screen inside the
                       vncviewer.  The connection is dropped if the user fails
                       to supply the correct password in 3 tries or does not
                       send one before a 45 second timeout.  Existing clients
                       are view-only during this period.

                       If the first character received is "Escape" then the
                       unix username will not be displayed after "login:"
                       as it is typed.  This could be of use for VNC viewers
                       that automatically type the username and password.

                       Since the detailed behavior of su(1) can vary from
                       OS to OS and for local configurations, test the mode
                       before deployment to make sure it is working properly.
                       x11vnc will attempt to be conservative and reject a
                       login if anything abnormal occurs.

                       One case to note: FreeBSD and the other BSD's by
                       default it is impossible for the user running x11vnc to
                       validate his *own* password via su(1) (commenting out
                       the pam_self.so entry in /etc/pam.d/su eliminates this
                       behavior).  So the x11vnc login will always *FAIL* for
                       this case (even when the correct password is supplied).

                       A possible workaround for this on *BSD would be to
                       start x11vnc as root with the "-users +nobody" option
                       to immediately switch to user nobody where the su'ing
                       will proceed normally.

                       Another source of potential problems are PAM modules
                       that prompt for extra info, e.g. password aging modules.
                       These logins will fail as well even when the correct
                       password is supplied.

                       **IMPORTANT**: to prevent the Unix password being sent
                       in *clear text* over the network, one of two schemes
                       will be enforced: 1) the -ssl builtin SSL mode, or 2)
                       require both -localhost and -stunnel be enabled.

                       Method 1) ensures the traffic is encrypted between
                       viewer and server.  A PEM file will be required, see the
                       discussion under -ssl below (under some circumstances
                       a temporary one can be automatically generated).

                       Method 2) requires the viewer connection to appear
                       to come from the same machine x11vnc is running on
                       (e.g. from a ssh -L port redirection).  And that the
                       -stunnel SSL mode be used for encryption over the
                       network. (see the description of -stunnel below).

                       Note: as a convenience, if you ssh(1) in and start
                       x11vnc it will check if the environment variable
                       SSH_CONNECTION is set and appears reasonable.  If it
                       does, then the -ssl or -stunnel requirement will be
                       dropped since it is assumed you are using ssh for the
                       encrypted tunnelling.  -localhost is still enforced.
                       Use -ssl or -stunnel to force SSL usage even if
                       SSH_CONNECTION is set.

                       To override the above restrictions you can set
                       environment variables before starting x11vnc:

                       Set UNIXPW_DISABLE_SSL=1 to disable requiring either
                       -ssl or -stunnel (as under SSH_CONNECTION.)  Evidently
                       you will be using a different method to encrypt the
                       data between the vncviewer and x11vnc: perhaps ssh(1)
                       or an IPSEC VPN. -localhost is still enforced (however,
                       see the next paragraph.)

                       Set UNIXPW_DISABLE_LOCALHOST=1 to disable the -localhost
                       requirement in -unixpw modes.  One should never do this
                       (i.e. allow the Unix passwords to be sniffed on the
                       network.)  This also disables the localhost requirement
                       for reverse connections (see below.)

                       Note that use of -localhost with ssh(1) (and no -unixpw)
                       is roughly the same as requiring a Unix user login
                       (since a Unix password or the user's public key
                       authentication is used by sshd on the machine where
                       x11vnc runs and only local connections from that machine
                       are accepted).

                       Regarding reverse connections (e.g. -R connect:host
                       and -connect host), when the -localhost constraint is
                       in effect then reverse connections can only be used
                       to connect to the same machine x11vnc is running on
                       (default port 5500).  Please use a ssh or stunnel port
                       redirection to the viewer machine to tunnel the reverse
                       connection over an encrypted channel.

                       In -inetd mode the Method 1) will be enforced (not
                       Method 2).  With -ssl in effect reverse connections
                       are disabled.  If you override this via env. var, be
                       sure to also use encryption from the viewer to inetd.
                       Tip: you can also have your own stunnel spawn x11vnc
                       in -inetd mode (thereby bypassing inetd).  See the FAQ
                       for details.

                       The user names in the comma separated [list] may have
                       per-user options after a ":", e.g. "fred:opts"
                       where "opts" is a "+" separated list of
                       "viewonly", "fullaccess", "input=XXXX", or
                       "deny", e.g. "karl,wally:viewonly,boss:input=M".
                       For "input=" it is the K,M,B,C described under -input.

                       If an item in the list is "*" that means those
                       options apply to all users.  It ALSO implies all users
                       are allowed to log in after supplying a valid password.
                       Use "deny" to explicitly deny some users if you use
                       "*" to set a global option.  If [list] begins with the
                       "!" character then "*" is ignored for checking if
                       the user is allowed, but the option values associated
                       with it do apply as normal.

                       There are also some utilities for checking passwords
                       if [list] starts with the "%" character.  See the
                       quick_pw() function for more details.  Description:
                       "%-" or "%stdin" means read one line from stdin
                       of form user:pass. "%stdin2" means read the username
                       from the first stdin line and the password from the
                       second stdin line.  "%pipe" means the first line of
                       stdin is user:pass, if UNIXPW_CMD_STDIN is set then that
                       string is piped into the UNIXPW_CMD command (see next
                       paragraph), otherwise the 2nd line of stdin is read,
                       if it a positive number that many bytes are read from
                       stdin and are piped into the command, if it is -1 then
                       one more line, up to 8000 bytes, is read from stdin and
                       piped to the command.  "%env" means user:pass is in
                       UNIXPW env var.  A leading "%/" or "%." means read
                       the first line from the filename that follows after the
                       % character. % by itself means prompt for the username
                       and password.  Otherwise: %user:pass   For example:
                       -unixpw %fred:swordfish  For the other cases user:pass
                       is read from the indicated source.  If the password is
                       correct 'Y user' is printed and the program exit code
                       is 0\.  If the password is incorrect it prints 'N user'
                       and the exit code is 1\.  If there is some other error
                       the exit code is 2\.  This feature enables x11vnc to be
                       a general unix user password checking tool; it could
                       be used from scripts or other programs.  These %
                       password checks, except for "%pipe", also apply to
                       the -unixpw_nis and -unixpw_cmd options.

                       For the % password check, if the env. var. UNIXPW_CMD
                       is set to a command then it is run as the user (assuming
                       the password is correct.)  The output of the command is
                       not printed, the program or script must manage that by
                       some other means.  The exit code of x11vnc will depend
                       on the exit code of the command that is run.

                       When interacting with /bin/su to login x11vnc tries
                       to emulate typing in the pty, set X11VNC_SLOW_PW_MS to
                       tune this (default 50 ms between characters.)

                       Use -nounixpw to disable unixpw mode if it was enabled
                       earlier in the cmd line (e.g. -svc mode)

<a name="opt-unixpw_nis"></a>-unixpw_nis [list]     As -unixpw above, however do not use su(1) but rather
                       use the traditional getpwnam(3) + crypt(3) method to
                       verify passwords. All of the above -unixpw options and
                       constraints apply.

                       This mode requires that the encrypted passwords be
                       readable.  Encrypted passwords stored in /etc/shadow
                       will be inaccessible unless x11vnc is run as root.

                       This is called "NIS" mode simply because in most
                       NIS setups user encrypted passwords are accessible
                       (e.g. "ypcat passwd") by an ordinary user and so that
                       user can authenticate ANY user.

                       NIS is not required for this mode to work (only that
                       getpwnam(3) return the encrypted password is required),
                       but it is unlikely it will work (as an ordinary user)
                       for most modern environments unless NIS is available.
                       On the other hand, when x11vnc is run as root it will
                       be able to to access /etc/shadow even if NIS is not
                       available (note running as root is often done when
                       running x11vnc from inetd and xdm/gdm/kdm).

                       Looked at another way, if you do not want to use the
                       su(1) method provided by -unixpw (i.e. su_verify()), you
                       can run x11vnc as root and use -unixpw_nis.  Any users
                       with passwords in /etc/shadow can then be authenticated.

                       In -unixpw_nis mode, under no circumstances is x11vnc's
                       user password verifying function based on su called
                       (i.e. the function su_verify() that runs /bin/su
                       in a pseudoterminal to verify passwords.)  However,
                       if -unixpw_nis is used in conjunction with the -find
                       and -create -display WAIT:... modes then, if x11vnc is
                       running as root, /bin/su may be called externally to
                       run the find or create commands.

<a name="opt-unixpw_cmd"></a>-unixpw_cmd cmd        As -unixpw above, however do not use su(1) but rather
                       run the externally supplied command "cmd".  The first
                       line of its stdin will be the username and the second
                       line the received password.  If the command exits
                       with status 0 (success) the VNC user will be accepted.
                       It will be rejected for any other return status.

                       Dynamic passwords and non-unix passwords, e.g. LDAP,
                       can be implemented this way by providing your own custom
                       helper program.  Note that the remote viewer is given 3
                       tries to enter the correct password, and so the program
                       may be called in a row that many (or more) times.

                       If a list of allowed users is needed to limit who can
                       log in, use -unixpw [list] in addition to this option.

                       In FINDDISPLAY and FINDCREATEDISPLAY modes the "cmd"
                       will also be run with the RFB_UNIXPW_CMD_RUN env. var.
                       non-empty and set to the corresponding display
                       find/create command.  The first two lines of input are
                       the username and passwd as in the normal case described
                       above.  To support FINDDISPLAY and FINDCREATEDISPLAY,
                       "cmd" should run the requested command as the user
                       (and most likely refusing to run it if the password is
                       not correct.)  Here is an example script (note it has
                       a hardwired bogus password "abc"!)

                         #!/bin/sh
                         # Example x11vnc -unixpw_cmd script.
                         # Read the first two lines of stdin (user and passwd)
                         read user
                         read pass

                         debug=0
                         if [ $debug = 1 ]; then
                         	echo "user: $user" 1>&2
                         	echo "pass: $pass" 1>&2
                         	env | egrep -i 'rfb|vnc' 1>&2
                         fi

                         # Check if the password is valid.
                         # (A real example would use ldap lookup, etc!)
                         if [ "X$pass" != "Xabc" ]; then
                         	exit 1	# incorrect password
                         fi

                         if [ "X$RFB_UNIXPW_CMD_RUN" = "X" ]; then
                         	exit 0	# correct password
                         else
                         	# Run the requested command (finddisplay)
                         	if [ $debug = 1 ]; then
                         		echo "run: $RFB_UNIXPW_CMD_RUN" 1>&2
                         	fi
                         	exec /bin/su - "$user" -c "$RFB_UNIXPW_CMD_RUN"
                         fi
                         exit 1

                       In -unixpw_cmd mode, under no circumstances is x11vnc's
                       user password verifying function based on su called
                       (i.e. the function su_verify() that runs /bin/su in a
                       pseudoterminal to verify passwords.)  It is up to the
                       supplied unixpw_cmd to do user switching if desired
                       and if it has the permissions to do so.

                       See also "-passwdfile custom:..." above for a non
                       unix username based custom password checking interface.

<a name="opt-find"></a>-find                  Find the user's display using FINDDISPLAY. This
                       is an alias for "-display WAIT:cmd=FINDDISPLAY".

                       Note: if a -display occurs later on the command line
                       it will override the -find setting.

                       For this and the next few options see -display WAIT:...
                       below for all of the details.

<a name="opt-finddpy"></a>-finddpy               Run the FINDDISPLAY program, print out the found
                       display (if any) and exit.  Output is like: DISPLAY=:0.0
                       DISPLAY=:0.0,XPID=12345 or DISPLAY=:0.0,VT=7\.  XPID is
                       the process ID of the found X server.  VT is the Linux
                       virtual terminal of the X server.
<a name="opt-listdpy"></a>-listdpy               Have the FINDDISPLAY program list all of your displays
                       (i.e. all the X displays on the local machine that you
                       have access rights to).  x11vnc then exits.

<a name="opt-findauth"></a>-findauth [disp]       Apply the -find/-finddpy heuristics to try to guess
                       the XAUTHORITY file for DISPLAY 'disp'.  If 'disp'
                       is not supplied, then the value in the -display on
                       the cmdline is used; failing that $DISPLAY is used;
                       and failing that ":0" is used.  x11vnc then exits.

                       If nothing is printed out, that means no XAUTHORITY was
                       found for 'disp'; i.e. failure.  If "XAUTHORITY="
                       is printed out, that means use the default (i.e. do
                       not set XAUTHORITY).  If "XAUTHORITY=/path/to/file"
                       is printed out, then use that file.

                       XDM/GDM/KDM: if you are running x11vnc as root and want
                       to find the XAUTHORITY before anyone has logged into an
                       X session yet, use: x11vnc -env FD_XDM=1 -findauth ...
                       (This will also find the XAUTHORITY if a user is already
                       logged into the X session.)  When running as root,
                       FD_XDM=1 will be tried if the initial -findauth fails.

<a name="opt-create"></a>-create                First try to find the user's display using FINDDISPLAY,
                       if that doesn't succeed create an X session via the
                       FINDCREATEDISPLAY method.  This is an alias for
                       "-display WAIT:cmd=FINDCREATEDISPLAY-Xvfb".

                       Note: if a -display occurs later on the command line
                       it will override the -create setting.

                       SSH NOTE: for both -find and -create you can (should!)
                       add the "-localhost" option to force SSH tunnel access.

<a name="opt-xdummy"></a>-xdummy                As in -create, except Xdummy instead of Xvfb.
<a name="opt-xvnc"></a>-xvnc                  As in -create, except Xvnc instead of Xvfb.
<a name="opt-xvnc_redirect"></a>-xvnc_redirect         As in -create, except Xvnc.redirect instead of Xvfb.
<a name="opt-xdummy_xvfb"></a>-xdummy_xvfb           Sets WAIT:cmd=FINDCREATEDISPLAY-Xdummy,Xvfb

<a name="opt-create_xsrv"></a>-create_xsrv str       Sets WAIT:cmd=FINDCREATEDISPLAY-<str>  Can be on cmdline
                       after anything that sets WAIT:.. and other things
                       (e.g. -svc, -xdmsvc) to adjust the X server list.
                       Example: -svc ... -create_xsrv Xdummy,X

<a name="opt-svc"></a>-svc                   Terminal services mode based on SSL access.  Alias for
                       -display WAIT:cmd=FINDCREATEDISPLAY-Xvfb -unixpw -users
                       unixpw= -ssl SAVE   Also "-service".

                       Note: if a -display, -unixpw, -users, or -ssl occurs
                       later on the command line it will override the -svc
                       setting.

<a name="opt-svc_xdummy"></a>-svc_xdummy            As -svc except Xdummy instead of Xvfb.
<a name="opt-svc_xvnc"></a>-svc_xvnc              As -svc except Xvnc instead of Xvfb.
<a name="opt-svc_xdummy_xvfb"></a>-svc_xdummy_xvfb       As -svc with Xdummy,Xvfb.

<a name="opt-xdmsvc"></a>-xdmsvc                Display manager Terminal services mode based on SSL.
                       Alias for -display WAIT:cmd=FINDCREATEDISPLAY-Xvfb.xdmcp
                       -unixpw -users unixpw= -ssl SAVE  Also "-xdm_service".

                       Note: if a -display, -unixpw, -users, or -ssl occurs
                       later on the command line it will override the -xdmsvc
                       setting.

                       To create a session a user will have to first log in
                       to the -unixpw dialog and then log in again to the
                       XDM/GDM/KDM prompt.  Subsequent re-connections will
                       only require the -unixpw password.  See the discussion
                       under -display WAIT:... for more details about XDM,
                       etc configuration.

                       Remember to enable XDMCP in the xdm-config, gdm.conf,
                       or kdmrc configuration file.  See -display WAIT: for
                       more info.

<a name="opt-sshxdmsvc"></a>-sshxdmsvc             Display manager Terminal services mode based on SSH.
                       Alias for -display WAIT:cmd=FINDCREATEDISPLAY-Xvfb.xdmcp
                       -localhost.

                       The -localhost option constrains connections to come
                       in via a SSH tunnel (which will require a login).
                       To create a session a user will also have to log into
                       the XDM GDM KDM prompt. Subsequent re-connections will
                       only only require the SSH login.  See the discussion
                       under -display WAIT:... for more details about XDM,
                       etc configuration.

                       Remember to enable XDMCP in the xdm-config, gdm.conf,
                       or kdmrc configuration file.  See -display WAIT: for
                       more info.

<a name="opt-unixpw_system_greeter"></a>-unixpw_system_greeter Present a "Press 'Escape' for System Greeter" option
                       to the connecting VNC client in combined -unixpw
                       and xdmcp FINDCREATEDISPLAY modes (e.g. -xdmsvc).

                       Normally in a -unixpw mode the VNC client must
                       supply a valid username and password to gain access.
                       However, if -unixpw_system_greeter is supplied AND
                       the FINDCREATEDISPLAY command matches 'xdmcp', then
                       the user has the option to press Escape and then get a
                       XDM/GDM/KDM login/greeter panel instead. They will then
                       supply a username and password directly to the greeter.

                       Otherwise, in xdmcp FINDCREATEDISPLAY mode the user
                       must supply his username and password TWICE.  First to
                       the initial unixpw login dialog, and second to the
                       subsequent XDM/GDM/KDM greeter.  Note that if the user
                       re-connects and supplies his username and password in
                       the unixpw dialog the xdmcp greeter is skipped and
                       he is connected directly to his existing X session.
                       So the -unixpw_system_greeter option avoids the extra
                       password at X session creation time.

                       Example:  x11vnc -xdmsvc -unixpw_system_greeter
                       See -unixpw and -display WAIT:... for more info.

                       The special options after a colon at the end of the
                       username (e.g. user:solid) described under -display
                       WAIT: are also applied in this mode if they are typed
                       in before the user hits Escape.  The username is ignored
                       but the colon options are not.

                       The default message is 2 lines in a small font, set
                       the env. var. X11VNC_SYSTEM_GREETER1=true for a 1 line
                       message in a larger font.

                       If the user pressed Escape the FINDCREATEDISPLAY command
                       will be run with the env. var. X11VNC_XDM_ONLY=1.

                       Remember to enable XDMCP in the xdm-config, gdm.conf,
                       or kdmrc configuration file.  See -display WAIT: for
                       more info.

<a name="opt-redirect"></a>-redirect port         As in FINDCREATEDISPLAY-Xvnc.redirect mode except
                       redirect immediately (i.e. without X session finding
                       or creation) to a VNC server listening on port. You
                       can also supply host:port to redirect to a different
                       machine.

                       If 0 <= port < 200 it is taken as a VNC display (5900 is
                       added to get the actual port), if port < 0 then -port
                       is used.

                       Probably the only reason to use the -redirect option
                       is in conjunction with SSL support, e.g. -ssl SAVE.
                       This provides an easy way to add SSL encryption to a VNC
                       server that does not support SSL (e.g. Xvnc or vnc.so)
                       In fact, the protocol does not even need to be VNC,
                       and so "-rfbport port1 -ssl SAVE -redirect host:port2"
                       can act as a replacement for stunnel(1).

                       This mode only allows one redirected connection.
                       The -forever option does not apply.  Use -inetd or
                       -loop for persistent service.

<a name="opt-display_WAIT"></a>-display_WAIT :...      A special usage mode for the normal -display option.
                       Useful with -unixpw, but can be used independently
                       of it.  If the display string begins with WAIT: then
                       x11vnc waits until a VNC client connects before opening
                       the X display (or -rawfb device).

                       This could be useful for delaying opening the display
                       for certain usage modes (say if x11vnc is started at
                       boot time and no X server is running or users logged
                       in yet).

                       If the string is, e.g. WAIT:0.0 or WAIT:1, i.e. "WAIT"
                       in front of a normal X display, then that indicated
                       display is used.

                       One can also insert a geometry between colons, e.g.
                       WAIT:1280x1024:... to set the size of the display the
                       VNC client first attaches to since some VNC viewers
                       will not automatically adjust to a new framebuffer size.

                       A more interesting case is like this:

                            WAIT:cmd=/usr/local/bin/find_display

                       in which case the command after "cmd=" is run to
                       dynamically work out the DISPLAY and optionally the
                       XAUTHORITY data.  The first line of the command output
                       must be of the form DISPLAY=<xdisplay>.  On Linux
                       if the virtual terminal is known append ",VT=n" to
                       this string and the chvt(1) program will also be run.
                       Any remaining output is taken as XAUTHORITY data.
                       It can be either of the form XAUTHORITY=<file> or raw
                       xauthority data for the display. For example;

                            xauth extract - $DISPLAY"

                       NOTE: As specified in the previous paragraph, you can
                       supply your own WAIT:cmd=... program or script, BUT
                       there are two very useful *BUILT-IN* ones: FINDDISPLAY
                       (alias -find above) and FINDCREATEDISPLAY (alias -create
                       above.)  Most people use these instead of creating
                       their own script.  Read the following (especially the
                       BUILT-IN modes sections) to see how to configure these
                       two useful builtin -display WAIT: modes.

                       In the case of -unixpw (and -unixpw_nis only if x11vnc
                       is running as root), then the cmd= command is run
                       as the user who just authenticated via the login and
                       password prompt.

                       In the case of -unixpw_cmd, the commands will also be
                       run as the logged-in user, as long as the user-supplied
                       helper program supports RFB_UNIXPW_CMD_RUN (see the
                       -unixpw_cmd option.)

                       Also in the case of -unixpw, the user logging in can
                       place a colon at the end of her username and supply
                       a few options: scale=, scale_cursor= (or sc=), solid
                       (or so), id=, clear_mods (or cm), clear_keys (or
                       ck), clear_all (or ca), repeat, speeds= (or sp=),
                       readtimeout= (or rd=), viewonly (or vo), nodisplay=
                       (or nd=), rotate= (or ro=), or noncache (or nc),
                       all separated by commas if there is more than one.
                       After the user logs in successfully, these options will
                       be applied to the VNC screen.  For example,

                          login: fred:scale=3/4,sc=1,repeat
                          Password: ...

                          login: runge:sp=modem,rd=120,solid

                       for convenience m/n implies scale= e.g. fred:3/4  If you
                       type and enter your password incorrectly, to retrieve
                       your long "login:" line press the Up arrow once
                       (before typing anything else).

                       Most of these colon options only apply to the builtin
                       FINDDISPLAY and FINDCREATEDISPLAY modes, but note
                       that they are passed to the extrenal command in the
                       environment as well and so could be used.

                       In the login panel, press F1 to get a list of the
                       available options that you can add after the username.

                       Another option is "geom=WxH" or "geom=WxHxD" (or
                       ge=). This only has an effect in FINDCREATEDISPLAY
                       mode when a virtual X server such as Xvfb is going
                       to be created.  It sets the width and height of
                       the new display, and optionally the color depth as
                       well.

                       You can also supply "gnome", "kde", "twm",
                       "fvwm", "mwm", "dtwm", "wmaker", "xfce",
                       "lxde", "enlightenment", "Xsession", or
                       "failsafe" (same as "xterm") to have the created
                       display use that mode for the user session.

                       Specify "tag=..." to set the unique FD_TAG desktop
                       session tag described below.  Note: this option will
                       be ignored if the FD_TAG env. var. is already set or
                       if the viewer-side supplied value is not completely
                       composed of alphanumeric or '_' or '-' characters.

                       User preferences file: Instead of having the user type
                       in geom=WxH,... etc. every time he logs in to find
                       or create his X session, if you set FD_USERPREFS to
                       a string that does not contain the "/" character,
                       then the user's home directory is prepended to that
                       string and if the file exists its first line is read
                       and appended to any options he supplied at the login:
                       prompt.  For example -env FD_USERPREFS=.x11vnc_create
                       and the user put "geom=1600x1200" in his
                       ~/.x11vnc_create file.

                       To disable the option setting set the environment
                       variable X11VNC_NO_UNIXPW_OPTS=1 before starting x11vnc.
                       To set any other options, the user can use the gui
                       (x11vnc -gui connect) or the remote control method
                       (x11vnc -R opt:val) during his VNC session.

                       So we see the combination of -display WAIT:cmd=... and
                       -unixpw allows automatic pairing of an unix
                       authenticated VNC user with his desktop.  This could
                       be very useful on SunRays and also any system where
                       multiple users share a given machine.  The user does
                       not need to remember special ports or passwords set up
                       for his desktop and VNC.

                       A nice way to use WAIT:cmd=... is out of inetd(8)
                       (it automatically forks a new x11vnc for each user).
                       You can have the x11vnc inetd spawned process run as,
                       say, root or nobody.  When run as root (for either inetd
                       or display manager), you can also supply the option
                       "-users unixpw=" to have the x11vnc process switch to
                       the user as well.  Note: there will be a 2nd SSL helper
                       process that will not switch, but it is only encoding
                       and decoding the encrypted stream at that point.

                       BUILT-IN modes:

                       -- Automatic Finding of User X Sessions --

                       As a special case, WAIT:cmd=FINDDISPLAY will run a
                       script that works on most Unixes to determine a user's
                       DISPLAY variable and xauthority data (see who(1)).

                       NOTE: The option "-find" is an alias for this mode.

                       To have this default script printed to stdout (e.g. for
                       customization) run with WAIT:cmd=FINDDISPLAY-print To
                       have the script run to print what display it would find
                       use "-finddpy" or WAIT:cmd=FINDDISPLAY-run

                       The standard script runs xdpyinfo(1) run on potential
                       displays.  If your X server(s) have a login greeter
                       that exclusively grabs the Xserver, then xdpyinfo
                       blocks forever and this mode will not work.  See
                       www.karlrunge.com/x11vnc/faq.html#faq-display-manager
                       for how to disable this for dtgreet on Solaris and
                       possibly for other greeters.

                       In -find/cmd=FINDDISPLAY mode, if you set FD_XDM=1,
                       e.g. 'x11vnc -env FD_XDM=1 -find ...' and x11vnc is
                       running as root (e.g. inetd) then it will try to find
                       the XAUTHORITY file of a running XDM/GDM/KDM login
                       greeter (i.e. no user has logged into an X session yet.)

                       As another special case, WAIT:cmd=HTTPONCE will allow
                       x11vnc to service one http request and then exit.
                       This is usually done in -inetd mode to run on, say,
                       port 5800 and allow the Java vncviewer to be downloaded
                       by client web browsers.  For example:

                        5815 stream tcp nowait root /usr/sbin/tcpd /.../x11vnc \
                          -inetd -q -http_ssl -prog /.../x11vnc \
                          -display WAIT:cmd=HTTPONCE

                       Where /.../x11vnc is the full path to x11vnc.
                       It is used in the Apache SSL-portal example (see FAQ).

                       In this mode you can set X11VNC_SKIP_DISPLAY to a
                       comma separated list of displays (e.g. ":0,:1") to
                       ignore in the finding process.  The ":" is optional.
                       Ranges n-m e.g. 0-20 can also be supplied. This string
                       can also be set by the connecting user via "nd="
                       using "+" instead of ","  If "nd=all" or you set
                       X11VNC_SKIP_DISPLAY=all then all display finding fails
                       as if you set X11VNC_FINDDISPLAY_ALWAYS_FAILS=1 (below.)

                       On some systems lsof(1) can be very slow.  Set the
                       env. var. FIND_DISPLAY_NO_LSOF=1 to skip using lsof to
                       try to find the Linux VT the X server is running on.
                       set FIND_DISPLAY_NO_VT_FIND=1 to avoid looking at all.

                       -- Automatic Creation of User X Sessions --

                       An interesting option is WAIT:cmd=FINDCREATEDISPLAY
                       that is like FINDDISPLAY in that is uses the same method
                       to find an existing display.  However, if it does not
                       find one it will try to *start* up an X server session
                       for the user.  This is the only time x11vnc tries to
                       actually start up an X server.

                       NOTE: The option "-create" is an alias for this mode.

                       It will start looking for an open display number at :20
                       Override via X11VNC_CREATE_STARTING_DISPLAY_NUMBER=n
                       By default 80 X displays are allowed (i.e. going to :99)
                       Override via X11VNC_CREATE_MAX_DISPLAYS=n

                       For its heuristics, the create display script sets
                       LC_ALL=C so that command output is uniform.  By default
                       it will try to restore LC_ALL right before starting the
                       user session.  However, if you don't mind it keeping
                       LC_ALL=C set the env. var.: X11VNC_CREATE_LC_ALL_C_OK=1

                       By default FINDCREATEDISPLAY will try Xvfb and then
                       Xdummy:

                       The Xdummy wrapper is part of the x11vnc source code
                       (x11vnc/misc/Xdummy)  It should be available in PATH
                       and have run "Xdummy -install" once to create the
                       shared library.  Xdummy only works on Linux.  As of
                       12/2009 it no longer needs to be run as root, and the
                       default is to not run as root.  In some circumstances
                       permissions may require running it as root, in these
                       cases specify FD_XDUMMY_RUN_AS_ROOT=1, this is the same
                       as supplying -root to the Xdummy cmdline.

                       Xvfb is available on most platforms and does not
                       require root.

                       An advantage of Xdummy over Xvfb is that Xdummy supports
                       RANDR dynamic screen resizing.

                       When x11vnc exits (i.e. user disconnects) the X
                       server session stays running in the background.
                       The FINDDISPLAY will find it directly next time.
                       The user must exit the X session in the usual way for
                       it to terminate (or kill the X server process if all
                       else fails).

                       To troubleshoot the FINDCREATEDISPLAY mechanism,
                       set the following env. var. to an output log file,
                       e.g -env CREATE_DISPLAY_OUTPUT=/tmp/mydebug.txt

                       So this is a somewhat odd mode for x11vnc in that it
                       will start up and poll virtual X servers!  This can
                       be used from, say, inetd(8) to provide a means of
                       definitely getting a desktop (either real or virtual)
                       on the machine.  E.g. a desktop service:

                         5900 stream tcp nowait root /usr/sbin/tcpd /.../x11vnc
                          -inetd -q -http -ssl SAVE -unixpw -users unixpw=\
                          -passwd secret -prog /.../x11vnc \
                          -display WAIT:cmd=FINDCREATEDISPLAY

                       Where /.../x11vnc is the full path to x11vnc.

                       See the -svc/-service option alias above.

                       If for some reason you do not want x11vnc to ever
                       try to find an existing display set the env. var
                       X11VNC_FINDDISPLAY_ALWAYS_FAILS=1 (also -env ...)
                       This is the same as setting X11VNC_SKIP_DISPLAY=all or
                       supplying "nd=all" after "username:"

                       Use WAIT:cmd=FINDCREATEDISPLAY-print to print out the
                       script that is used for this.

                       You can specify the preferred X server order via e.g.,
                       WAIT:cmd=FINDCREATEDISPLAY-Xdummy,Xvfb,X  and/or leave
                       out ones you do not want.  The the case "X" means try
                       to start up a real, hardware X server using xinit(1)
                       or startx(1).  If there is already an X server running
                       the X case may only work on Linux (see startx(1)).

                       "Xvnc" will start up a VNC X server (real-
                       or tight-vnc, e.g. use if Xvfb is not available).
                       "Xsrv" will start up the server program in the
                       variable "FD_XSRV" if it is non-empty. You can make
                       this be a wrapper script if you like (it must handle :N,
                       -geometry, and -depth and other X server options).

                       You can set the environment variable FD_GEOM (or
                       X11VNC_CREATE_GEOM) to WxH or WxHxD to set the width
                       and height and optionally the color depth of the
                       created display.  You can also set FD_SESS to be the
                       session (short name of the windowmanager: kde, gnome,
                       twm, failsafe, etc.). FD_OPTS contains extra options
                       to pass to the X server. You can also set FD_PROG to
                       be the full path to the session/windowmanager program.

                       More FD tricks:  FD_CUPS=port or FD_CUPS=host:port
                       will set the cups printing environment.  Similarly for
                       FD_ESD=port or FD_ESD=host:port for esddsp sound
                       redirection.  Set FD_EXTRA to a command to be run a
                       few seconds after the X server starts up.  Set FD_TAG
                       to be a unique name for the session, it is set as an
                       X property, that makes FINDDISPLAY only find sessions
                       with that tag value.

                       Set FD_XDMCP_IF to the network interface that the
                       display manager is running on; default is 'localhost'
                       but you may need to set it to '::1' on some IPv6 only
                       systems or misconfigured display managers.

                       Set FD_NOLISTEN to override the default '-nolisten tcp'

                       If you want the FINDCREATEDISPLAY session to contact an
                       XDMCP login manager (xdm/gdm/kdm) on the same machine,
                       then use "Xvfb.xdmcp" instead of "Xvfb", etc.
                       The user will have to supply his username and password
                       one more time (but he gets to select his desktop type
                       so that can be useful).  For this to work, you will
                       need to enable localhost XDMCP (udp port 177) for the
                       display manager.  This seems to be:

                        for gdm in gdm.conf:   Enable=true in section [xdmcp]
                        for kdm in kdmrc:      Enable=true in section [Xdmcp]
                        for xdm in xdm-config: DisplayManager.requestPort: 177

                       See the shorthand options above "-svc", "-xdmsvc"
                       and "-sshxdmsvc" that specify the above options for
                       some useful cases.

                       If you set the env. var WAITBG=1 x11vnc will go into
                       the background once listening in wait mode.

                       Another special mode is FINDCREATEDISPLAY-Xvnc.redirect,
                       (or FINDDISPLAY-Xvnc.redirect).  In this case it will
                       start up Xvnc as above if needed, but instead of
                       polling it in its normal way, it simply does a socket
                       redirection of the connected VNC viewer to the Xvnc.

                       So in Xvnc.redirect x11vnc does no VNC but merely
                       transfers the data back and forth.  This should be
                       faster then x11vnc's polling method, but not as fast
                       as connecting directly to the Xvnc with the VNC Viewer.
                       The idea here is to take advantage of x11vnc's display
                       finding/creating scheme, SSL, and perhaps a few others.
                       Most of x11vnc's options do not apply in this mode.

                       Xvnc.redirect should also work for the vnc.so X server
                       module for the h/w display however it will work only
                       for finding the display and the user must already be
                       logged into the X console.

<a name="opt-vencrypt"></a>-vencrypt mode         The VeNCrypt extension to the VNC protocol allows
                       encrypted SSL/TLS connections.  If the -ssl mode is
                       enabled, then VeNCrypt is enabled as well BY DEFAULT
                       (they both use a SSL/TLS tunnel, only the protocol
                       handshake is a little different.)

                       To control when and how VeNCrypt is used, specify the
                       mode string.  If mode is "never", then VeNCrypt is
                       not used.  If mode is "support" (the default) then
                       VeNCrypt is supported.  If mode is "only", then the
                       similar and older ANONTLS protocol is not simultaneously
                       supported.  x11vnc's normal SSL mode (vncs://) will be
                       supported under -ssl unless you set mode to "force".

                       If mode is prefixed with "nodh:", then Diffie Hellman
                       anonymous key exchange is disabled.  If mode is prefixed
                       with "nox509:", then X509 key exchange is disabled.

                       To disable all Anonymous Diffie-Hellman access
                       (susceptible to Man-In-The-Middle attack) you will need
                       to supply "-vencrypt nodh:support -anontls never"
                       or "-vencrypt nodh:only"

                       If mode is prefixed with "newdh:", then new Diffie
                       Hellman parameters are generated for each connection
                       (this can be time consuming: 1-60 secs; see -dhparams
                       below for a faster way) rather than using the
                       fixed values in the program.  Using fixed, publicly
                       known values is not known to be a security problem.
                       This setting applies to ANONTLS as well.

                       Long example: -vencrypt newdh:nox509:support

                       Also, if mode is prefixed with "plain:", then
                       if -unixpw mode is active the VeNCrypt "*Plain"
                       username+passwd method is enabled for Unix logins.
                       Otherwise in -unixpw mode the normal login panel is
                       provided.

                       You *MUST* supply the -ssl option for VeNCrypt to
                       be active.  The -vencrypt option only fine-tunes its
                       operation.

<a name="opt-anontls"></a>-anontls mode          The ANONTLS extension to the VNC protocol allows
                       encrypted SSL/TLS connections.  If the -ssl mode is
                       enabled, then ANONTLS is enabled as well BY DEFAULT
                       (they both use a SSL/TLS tunnel, only the protocol
                       handshake is a little different.)

                       ANONTLS is an older SSL/TLS mode introduced by vino.

                       It is referred to as 'TLS' for its registered VNC
                       security-type name, but we use the more descriptive
                       'ANONTLS' here because it provides only Anonymous
                       Diffie-Hellman encrypted connections, and hence no
                       possibility for certificate authentication.

                       To control when and how ANONTLS is used, specify the
                       mode string.  If mode is "never", then ANONTLS is not
                       used.  If mode is "support" (the default) then ANONTLS
                       is supported.  If mode is "only", then the similar
                       VeNCrypt protocol is not simultaneously supported.
                       x11vnc's normal SSL mode (vncs://) will be supported
                       under -ssl unless you set mode to "force".

                       If mode is prefixed with "newdh:", then new Diffie
                       Hellman parameters are generated for each connection
                       (this can be time consuming: 1-60 secs; see -dhparams
                       below for a faster way) rather than using the
                       fixed values in the program.  Using fixed, publicly
                       known values is not known to be a security problem.
                       This setting applies to VeNCrypt as well.  See the
                       description of "plain:" under -vencrypt.

                       Long example: -anontls newdh:plain:support

                       You *MUST* supply the -ssl option for ANONTLS to
                       be active.  The -anontls option only fine-tunes its
                       operation.

<a name="opt-sslonly"></a>-sslonly               Same as: "-vencrypt never -anontls never"  i.e. it
                       disables the VeNCrypt and ANONTLS encryption methods
                       and only allows standard SSL tunneling.  You must also
                       supply the -ssl ... option (see below.)

<a name="opt-dhparams"></a>-dhparams file         For some operations a set of Diffie Hellman parameters
                       (prime and generator) is needed.  If so, use the
                       parameters in "file". In particular, the VeNCrypt and
                       ANONTLS anonymous DH mode need them.  By default a
                       fixed set is used. If you do not want to do that you
                       can specify "newdh:" to the -vencrypt and -anontls
                       options to generate a new set each session.  If that
                       is too slow for you, use -dhparams file to a set you
                       created manually via "openssl dhparam -out file 1024"

<a name="opt-nossl"></a>-nossl                 Disable the -ssl option (see below). Since -ssl is off
                       by default -nossl would only be used on the commandline
                       to unset any *earlier* -ssl option (or -svc...)

<a name="opt-ssl"></a>-ssl [pem]             Use the openssl library (www.openssl.org) to provide a
                       built-in encrypted SSL/TLS tunnel between VNC viewers
                       and x11vnc.  This requires libssl support to be
                       compiled into x11vnc at build time.  If x11vnc is not
                       built with libssl support it will exit immediately when
                       -ssl is prescribed.  See the -stunnel option below for
                       an alternative.

                       The VNC Viewer-side needs to support SSL/TLS as well.
                       See this URL and also the discussion below for
                       ideas on how to enable SSL support for the viewer:
                       http://www.karlrunge.com/x11vnc/faq.html#faq-ssl-tun
                       nel-viewers .  x11vnc provides an SSL enabled Java
                       viewer applet in the classes/ssl directory (-http or
                       -httpdir options.)  The SSVNC viewer package supports
                       SSL tunnels too.

                       If the VNC Viewer supports VeNCrypt or ANONTLS (vino's
                       encryption mode) they are also supported by the -ssl
                       mode (see the -vencrypt and -anontls options for more
                       info; use -sslonly to disable both of them.)

                       Use "-ssl /path/to/mycert.pem" to specify an SSL
                       certificate file in PEM format to use to identify and
                       provide a key for this server.  See openssl(1) for more
                       info about PEMs and the -sslGenCert and "-ssl SAVE"
                       options below for how to create them.

                       The connecting VNC viewer SSL tunnel can (at its option)
                       authenticate this server if it has the public key part
                       of the certificate (or a common certificate authority,
                       CA, is a more sophisticated way to verify this server's
                       cert, see -sslGenCA below).  This authentication is
                       done to prevent Man-In-The-Middle attacks.  Otherwise,
                       if the VNC viewer simply accepts this server's key
                       WITHOUT verification, the traffic is protected from
                       passive sniffing on the network, but *NOT* from
                       Man-In-The-Middle attacks. There are hacker tools
                       like dsniff/webmitm and cain that implement SSL
                       Man-In-The-Middle attacks.

                       If [pem] is empty or the string "SAVE" then the
                       openssl(1) command must be available to generate the
                       certificate the first time.  A self-signed certificate
                       is generated (see -sslGenCA and -sslGenCert for use
                       of a Certificate Authority.)  It will be saved to the
                       file ~/.vnc/certs/server.pem.  On subsequent calls if
                       that file already exists it will be used directly.

                       Use "SAVE_NOPROMPT" to avoid being prompted to
                       protect the generated key with a passphrase.  However in
                       -inetd and -bg modes there will be no prompting for a
                       passphrase in either case.

                       If [pem] is "SAVE_PROMPT" the server.pem certificate
                       will be created based on your answers to its prompts for
                       all info such as OrganizationalName, CommonName, etc.

                       Use "SAVE-<string>" and "SAVE_PROMPT-<string>"
                       to refer to the file ~/.vnc/certs/server-<string>.pem
                       instead (it will be generated if it does not already
                       exist).  E.g. "SAVE-charlie" will store to the file
                       ~/.vnc/certs/server-charlie.pem

                       Examples: x11vnc -ssl SAVE -display :0 ...
                                 x11vnc -ssl SAVE-someother -display :0 ...

                       If [pem] is "TMP" and the openssl(1) utility
                       command exists in PATH, then a temporary, self-signed
                       certificate will be generated for this session.  If
                       openssl(1) cannot be used to generate a temporary
                       certificate x11vnc exits immediately.  The temporary
                       cert will be discarded when x11vnc exits.

                       If successful in using openssl(1) to generate a
                       temporary certificate in "SAVE" or "TMP" creation
                       modes, the public part of it will be displayed to stderr
                       (e.g. one could copy it to the client-side to provide
                       authentication of the server to VNC viewers.)

                       NOTE: In "TMP" mode, unless you safely copy the
                       public part of the temporary Cert to the viewer for
                       authenticate *every time* (unlikely...), then only
                       passive sniffing attacks are prevented and you are
                       still open to Man-In-The-Middle attacks.  This is
                       why the default "SAVE" mode is preferred (and more
                       sophisticated CA mode too).  Only with saved keys AND
                       the VNC viewer authenticating them (via the public
                       certificate), are Man-In-The-Middle attacks prevented.

                       If [pem] is "ANON" then the Diffie-Hellman anonymous
                       key exchange method is used.  In this mode there
                       are *no* SSL certificates and so it is not possible
                       to authenticate either the VNC server or VNC client.
                       Thus only passive network sniffing attacks are avoided:
                       the "ANON" method is susceptible to Man-In-The-Middle
                       attacks.  "ANON" is not recommended; instead use
                       a SSL PEM you created or the default "SAVE" method.

                       See -ssldir below to use a directory besides the
                       default ~/.vnc/certs

                       If your x11vnc binary was not compiled with OpenSSL
                       library support, use of the -ssl option will induce an
                       immediate failure and exit.  For such binaries, consider
                       using the -stunnel option for SSL encrypted connections.

                       Misc Info: In temporary cert creation mode "TMP", set
                       the env. var. X11VNC_SHOW_TMP_PEM=1 to have x11vnc print
                       out the entire certificate, including the PRIVATE KEY
                       part, to stderr.  There are better ways to get/save this
                       info.  See "SAVE" above and "-sslGenCert" below.

<a name="opt-ssltimeout"></a>-ssltimeout n          Set SSL read timeout to n seconds.  In some situations
                       (i.e. an iconified viewer in Windows) the viewer stops
                       talking and the connection is dropped after the default
                       timeout (25s for about the first minute, 43200s later).
                       Set to zero to poll forever.  Set to a negative value
                       to use the builtin setting.

                       Note that this value does NOT apply to the *initial* ssl
                       init connection.  The default timeout for that is 20sec.
                       Use -env SSL_INIT_TIMEOUT=n to modify it.

<a name="opt-sslnofail"></a>-sslnofail             Exit at the first SSL connection failure. Useful when
                       scripting SSL connections (e.g. x11vnc is started via
                       ssh) and you do not want x11vnc waiting around for more
                       connections, tying up ports, etc.

<a name="opt-ssldir"></a>-ssldir dir            Use "dir" as an alternate ssl certificate and key
                       management toplevel directory.  The default is
                       ~/.vnc/certs

                       This directory is used to store server and other
                       certificates and keys and also other materials.  E.g. in
                       the simplest case, "-ssl SAVE" will store the x11vnc
                       server cert in dir/server.pem

                       Use of alternate directories via -ssldir allows you to
                       manage multiple VNC Certificate Authority (CA) keys.
                       Another use is if ~/.vnc/cert is on an NFS share you
                       might want your certificates and keys to be on a local
                       filesystem to prevent network snooping (for example
                       -ssldir /var/lib/x11vnc-certs).

                       -ssldir affects nearly all of the other -ssl* options,
                       e.g. -ssl SAVE, -sslGenCert, etc..

<a name="opt-sslverify"></a>-sslverify path        For either of the -ssl or -stunnel modes, use "path"
                       to provide certificates to authenticate incoming VNC
                       *Client* connections (normally only the server is
                       authenticated in SSL.)  This can be used as a method
                       to replace standard password authentication of clients.

                       If "path" is a directory it contains the client (or CA)
                       certificates in separate files.  If path is a file,
                       it contains one or more certificates. See special tokens
                       below.  These correspond to the "CApath = dir" and
                       "CAfile = file" stunnel options.  See the stunnel(8)
                       manpage for details.

                       Examples:
                              x11vnc -ssl -sslverify ~/my.crt
                              x11vnc -ssl -sslverify ~/my_pem_dir/

                       Note that if path is a directory, it must contain
                       the certs in separate files named like <HASH>.0, where
                       the value of <HASH> is found by running the command
                       "openssl x509 -hash -noout -in file.crt". Evidently
                       one uses <HASH>.1 if there is a collision...

                       The the key-management utility "-sslCertInfo HASHON"
                       and "-sslCertInfo HASHOFF" will create/delete these
                       hashes for you automatically (via symlink) in the HASH
                       subdirs it manages.  Then you can point -sslverify to
                       the HASH subdir.

                       Special tokens: in -ssl mode, if "path" is not a file or
                       a directory, it is taken as a comma separated list of
                       tokens that are interpreted as follows:

                       If a token is "CA" that means load the CA/cacert.pem
                       file from the ssl directory.  If a token is "clients"
                       then all the files clients/*.crt in the ssl directory
                       are loaded.  Otherwise the file clients/token.crt
                       is attempted to be loaded.  As a kludge, use a token
                       like ../server-foo to load a server cert if you find
                       that necessary.

                       Use -ssldir to use a directory different from the
                       ~/.vnc/certs default.

                       Note that if the "CA" cert is loaded you do not need
                       to load any of the certs that have been signed by it.
                       You will need to load any additional self-signed certs
                       however.

                       Examples:
                              x11vnc -ssl -sslverify CA
                              x11vnc -ssl -sslverify self:fred,self:jim
                              x11vnc -ssl -sslverify CA,clients

                       Usually "-sslverify CA" is the most effective.
                       See the -sslGenCA and -sslGenCert options below for
                       how to set up and manage the CA framework.

                       Note that if the Client's (vncviewer) certificate
                       has been signed by a well-known CA then the CA's
                       certificate may already be installed on the system.
                       So, for example, on a debian based system one could
                       use: -sslverify /etc/ssl/certs.

                       NOTE: the following utilities, -sslGenCA, -sslGenCert,
                       -sslEncKey, -sslCertInfo, and -sslCRL are provided for
                       completeness, but for casual usage they are overkill.

                       They provide VNC Certificate Authority (CA) key creation
                       and server / client key generation and signing.  So they
                       provide a basic Public Key management framework for
                       VNC-ing with x11vnc. (note that they require openssl(1)
                       be installed on the system)

                       However, the simplest usage mode, "-ssl TMP" (where
                       x11vnc automatically generates its own, self-signed,
                       temporary key and the VNC viewers always accept it,
                       e.g. accepting via a dialog box) is probably safe enough
                       for most scenarios.  CA management is not needed.

                       To protect against Man-In-The-Middle attacks the "TMP"
                       mode can be improved by using "-ssl SAVE" (same as
                       "-ssl", i.e. the default) to have x11vnc create a
                       longer term self-signed certificate, and then (safely)
                       copy the corresponding public key cert to the desired
                       client machines (care must be taken the private key part
                       is not stolen; you will be prompted for a passphrase).

                       So keep in mind no CA key creation or management
                       (-sslGenCA and -sslGenCert) is needed for either of
                       the above two common usage modes.

                       One might want to use -sslGenCA and -sslGenCert
                       if you had a large number of VNC client and server
                       workstations.  That way the administrator could generate
                       a single CA key with -sslGenCA and distribute its
                       certificate part to all of the workstations.

                       Next, he could create signed VNC server keys
                       (-sslGenCert server ...) for each workstation or user
                       that then x11vnc would use to authenticate itself to
                       any VNC client that has the CA cert.

                       Optionally, the admin could also make it so the
                       VNC clients themselves are authenticated to x11vnc
                       (-sslGenCert client ...)  For this -sslverify would be
                       pointed to the CA cert (and/or self-signed certs).

                       x11vnc will be able to use all of these cert and
                       key files.  On the VNC client side, they will need to
                       be "imported" somehow.  Web browsers have "Manage
                       Certificates" actions as does the Java applet plugin
                       Control Panel.  stunnel can also use these files (see
                       the ss_vncviewer example script in the FAQ and SSVNC.)

<a name="opt-sslCRL"></a>-sslCRL path           Set the Certificate Revocation Lists (CRL) to "path".
                       This setting applies for both -ssl and -stunnel modes.

                       If path is a file, the file contains one or more CRLs
                       in PEM format.  If path is a directory, it contains
                       hash named files of CRLs in the usual OpenSSL manner.
                       See the OpenSSL and stunnel(8) documentation for
                       more info.

                       This option only applies if -sslverify has been
                       supplied: it checks for revocation along the
                       certificate chain used to verify the VNC client.
                       The -sslCRL setting will be ignored when -sslverify is
                       not specified.

                       Note that if a CRL's expiration date has passed, all
                       SSL connections will fail regardless of if they are
                       related to the subject of the CRL or not.

                       Only rarely will one's x11vnc -ssl infrastructure be so
                       large that this option would be useful (since normally
                       maintaining the contents of the -sslverify file or
                       directory should be enough.)  However, when using
                       x11vnc with a Certificate Authority (see -sslGenCA)
                       to authenticate Clients via SSL/TLS, the -sslCRL option
                       can be useful to revoke users' certs whose private SSL
                       keys were lost or stolen (e.g. laptop.)  This way a new
                       CA cert+key does not need to be created and new signed
                       client keys generated and distributed to all users.

                       To create a CRL file with revoked certificates the
                       commands 'openssl ca -revoke ...' and 'openssl ca
                       -gencrl ...' are useful.  (Run them in ~/.vnc/certs)

<a name="opt-sslGenCA"></a>-sslGenCA [dir]        Generate your own Certificate Authority private key,
                       certificate, and other files in directory [dir].
                       x11vnc then exits.

                       If [dir] is not supplied, a -ssldir setting is used,
                       or otherwise ~/.vnc/certs is used.

                       This command also creates directories where server and
                       client certs and keys will be stored.  The openssl(1)
                       program must be installed on the system and available
                       in PATH.

                       After the CA files and directories are created the
                       x11vnc command exits; the VNC server is not run.

                       You will be prompted for information to put into the CA
                       certificate.  The info does not have to be accurate just
                       as long as clients accept the cert for VNC connections.
                       You will also need to supply a passphrase of at least
                       4 characters for the CA private key.

                       Once you have generated the CA you can distribute
                       its certificate part, [dir]/CA/cacert.pem, to other
                       workstations where VNC viewers will be run.  One will
                       need to "import" this certificate in the applications,
                       e.g. Web browser, Java applet plugin, stunnel, etc.
                       Next, you can create and sign keys using the CA with
                       the -sslGenCert option below.

                       Examples:
                                x11vnc -sslGenCA
                                x11vnc -sslGenCA  ~/myCAdir
                                x11vnc -ssldir ~/myCAdir -sslGenCA

                       (the last two lines are equivalent)

<a name="opt-sslGenCert"></a>-sslGenCert type name  Generate a VNC server or client certificate and private
                       key pair signed by the CA created previously with
                       -sslGenCA.  The openssl(1) program must be installed
                       on the system and available in PATH.

                       After the Certificate is generated x11vnc exits; the
                       VNC server is not run.

                       The type of key to be generated is the string "type".
                       It is either "server" (i.e. for use by x11vnc) or
                       "client" (for a VNC viewer).  Note that typically
                       only "server" is used: the VNC clients authenticate
                       themselves by a non-public-key method (e.g. VNC or
                       unix password).  "type" is required.

                       An arbitrary default name you want to associate with
                       the key is supplied by the "name" string.  You can
                       change it at the various prompts when creating the key.
                       "name" is optional.

                       If name is left blank for clients keys then "nobody"
                       is used.  If left blank for server keys, then the
                       primary server key: "server.pem" is created (this
                       is the saved one referenced by "-ssl SAVE" when the
                       server is started)

                       If "name" begins with the string "self:" then
                       a self-signed certificate is created instead of one
                       signed by your CA key.

                       If "name" begins with the string "req:" then only a
                       key (.key) and a certificate signing *request* (.req)
                       are generated.  You can then send the .req file to
                       an external CA (even a professional one, e.g. Thawte)
                       and then combine the .key and the received cert into
                       the .pem file with the same basename.

                       The distinction between "server" and "client" is
                       simply the choice of output filenames and sub-directory.
                       This makes it so the -ssl SAVE-name option can easily
                       pick up the x11vnc PEM file this option generates.
                       And similarly makes it easy for the -sslverify option
                       to pick up your client certs.

                       There is nothing special about the filename or directory
                       location of either the "server" and "client" certs.
                       You can rename the files or move them to wherever
                       you like.

                       Precede this option with -ssldir [dir] to use a
                       directory other than the default ~/.vnc/certs You will
                       need to run -sslGenCA on that directory first before
                       doing any -sslGenCert key creation.

                       Note you cannot recreate a cert with exactly the same
                       distiguished name (DN) as an existing one.  To do so,
                       you will need to edit the [dir]/CA/index.txt file to
                       delete the line.

                       Similar to -sslGenCA, you will be prompted to fill
                       in some information that will be recorded in the
                       certificate when it is created.

                       Tip: if you know the fully-qualified hostname other
                       people will be connecting to, you can use that as the
                       CommonName "CN" to avoid some applications (e.g. web
                       browsers and java plugin) complaining that it does not
                       match the hostname.

                       You will also need to supply the CA private key
                       passphrase to unlock the private key created from
                       -sslGenCA.  This private key is used to sign the server
                       or client certificate.

                       The "server" certs can be used by x11vnc directly by
                       pointing to them via the -ssl [pem] option.  The default
                       file will be ~/.vnc/certs/server.pem.  This one would
                       be used by simply typing -ssl SAVE.  The pem file
                       contains both the certificate and the private key.
                       server.crt file contains the cert only.

                       The "client" cert + private key file will need
                       to be copied and imported into the VNC viewer
                       side applications (Web browser, Java plugin,
                       stunnel, etc.)  Once that is done you can delete the
                       "client" private key file on this machine since
                       it is only needed on the VNC viewer side.  The,
                       e.g. ~/.vnc/certs/clients/<name>.pem contains both
                       the cert and private key.  The <name>.crt contains the
                       certificate only.

                       NOTE: It is very important to know one should
                       generate new keys with a passphrase.  Otherwise if an
                       untrusted user steals the key file he could use it to
                       masquerade as the x11vnc server (or VNC viewer client).
                       You will be prompted whether to encrypt the key with
                       a passphrase or not.  It is recommended that you do.
                       One inconvenience to a passphrase is that it must
                       be typed in EVERY time x11vnc or the client app is
                       started up.

                       Examples:

                               x11vnc -sslGenCert server
                               x11vnc -ssl SAVE -display :0 ...

                       and then on viewer using ss_vncviewer stunnel wrapper
                       (see the FAQ):
                               ss_vncviewer -verify ./cacert.crt hostname:0

                       (this assumes the cacert.crt cert from -sslGenCA
                       was safely copied to the VNC viewer machine where
                       ss_vncviewer is run)

                       Example using a name:

                               x11vnc -sslGenCert server charlie
                               x11vnc -ssl SAVE-charlie -display :0 ...

                       Example for a client certificate (rarely used):

                               x11vnc -sslGenCert client roger
                               scp ~/.vnc/certs/clients/roger.pem somehost:.
                               rm  ~/.vnc/certs/clients/roger.pem

                       x11vnc is then started with the option -sslverify
                       ~/.vnc/certs/clients/roger.crt (or simply -sslverify
                       roger), and on the viewer user on somehost could do
                       for example:

                               ss_vncviewer -mycert ./roger.pem hostname:0

                       If you set the env. var REQ_ARGS='...' it will be
                       passed to openssl req(1).  A common use would be
                       REQ_ARGS='-days 1095' to bump up the expiration date
                       (3 years in this case).

<a name="opt-sslEncKey"></a>-sslEncKey pem         Utility to encrypt an existing PEM file with a
                       passphrase you supply when prompted.  For that key to be
                       used (e.g. by x11vnc) the passphrase must be supplied
                       each time.

                       The "SAVE" notation described under -ssl applies as
                       well. (precede this option with -ssldir [dir] to refer
                       a directory besides the default ~/.vnc/certs)

                       The openssl(1) program must be installed on the system
                       and available in PATH.  After the Key file is encrypted
                       the x11vnc command exits; the VNC server is not run.

                       Examples:
                               x11vnc -sslEncKey /path/to/foo.pem
                               x11vnc -sslEncKey SAVE
                               x11vnc -sslEncKey SAVE-charlie

<a name="opt-sslCertInfo"></a>-sslCertInfo pem       Prints out information about an existing PEM file.
                       In addition the public certificate is also printed.
                       The openssl(1) program must be in PATH. Basically the
                       command "openssl x509 -text" is run on the pem.

                       After the info is printed the x11vnc command exits;
                       the VNC server is not run.

                       The "SAVE" notation described under -ssl applies
                       as well.

                       Using  "LIST" will give a list of all certs being
                       managed (in the ~/.vnc/certs dir, use -ssldir to refer
                       to another dir).  "ALL" will print out the info for
                       every managed key (this can be very long).  Giving a
                       client or server cert shortname will also try a lookup
                       (e.g. -sslCertInfo charlie).  Use "LISTL" or "LL"
                       for a long (ls -l style) listing.

                       Using "HASHON" will create subdirs [dir]/HASH and
                       [dir]/HASH with OpenSSL hash filenames (e.g. 0d5fbbf1.0)
                       symlinks pointing up to the corresponding *.crt file.
                       ([dir] is ~/.vnc/certs or one given by -ssldir.)
                       This is a useful way for other OpenSSL applications
                       (e.g. stunnel) to access all of the certs without
                       having to concatenate them.  x11vnc will not use them
                       unless you specifically reference them.  "HASHOFF"
                       removes these HASH subdirs.

                       The LIST, LISTL, LL, ALL, HASHON, HASHOFF words can
                       also be lowercase, e.g. "list".

<a name="opt-sslDelCert"></a>-sslDelCert pem        Prompts you to delete all .crt .pem .key .req files
                       associated with [pem].  x11vnc then exits. "SAVE"
                       and lookups as in -sslCertInfo apply as well.

<a name="opt-sslScripts"></a>-sslScripts            Prints out both the 'genCA' and 'genCert' x11vnc
                       openssl wrapper scripts for you to examine, modify, etc.
                       The scripts are printed to stdout and then the x11vnc
                       program exits.

<a name="opt-stunnel"></a>-stunnel [pem]         Use the stunnel(8) (stunnel.mirt.net) to provide an
                       encrypted SSL tunnel between viewers and x11vnc.

                       This external tunnel method was implemented prior to the
                       integrated -ssl encryption described above.  It still
                       works well and avoids the requirement of linking with
                       the OpenSSL libraries.  This mode requires stunnel
                       to be installed on the system and available via PATH
                       (n.b. stunnel is often installed in sbin directories).
                       Version 4.x of stunnel is assumed (but see -stunnel3
                       below.)

                       [pem] is optional, use "-stunnel /path/to/stunnel.pem"
                       to specify a PEM certificate file to pass to stunnel.
                       See the -ssl option for more info on certificate files.

                       Whether or not your stunnel has its own certificate
                       depends on your stunnel configuration; stunnel often
                       generates one at install time.  See your stunnel
                       documentation for details.  In any event, if you want to
                       use this certificate you must supply the full path to it
                       as [pem].  Note: the file may only be readable by root.

                       [pem] may also be the special strings "TMP", "SAVE",
                       and "SAVE..." as described in the -ssl option.
                       If [pem] is not supplied, "SAVE" is assumed.

                       Note that the VeNCrypt, ANONTLS, and "ANON" modes
                       are not supported in -stunnel mode.

                       stunnel is started up as a child process of x11vnc and
                       any SSL connections stunnel receives are decrypted and
                       sent to x11vnc over a local socket.  The strings
                       "The SSL VNC desktop is ..." and "SSLPORT=..."
                       are printed out at startup to indicate this.

                       The -localhost option is enforced by default to avoid
                       people routing around the SSL channel.  Use -env
                       STUNNEL_DISABLE_LOCALHOST=1 to disable this security
                       requirement.

                       Set -env STUNNEL_DEBUG=1 for more debugging printout.

                       Set -env STUNNEL_PROG=xxx to the full path of stunnel
                       program you want to be used (e.g. /usr/bin/stunnel4).

                       Set -env STUNNEL_LISTEN=xxx to the address of the
                       network interface to listen on (the default is to listen
                       on all interfaces), e.g. STUNNEL_LISTEN=192.168.1.100.

                       A simple way to add IPv6 support is STUNNEL_LISTEN=::

                       Your VNC viewer will also need to be able to connect
                       via SSL.  Unfortunately not too many do this.  See the
                       information about SSL viewers under the -ssl option.
                       The x11vnc project's SSVNC is an option.

                       Also, in the x11vnc distribution, patched TightVNC
                       and UltraVNC Java applet jar files are provided in
                       the classes/ssl directory that do SSL connections.
                       Enable serving them with the -http, -http_ssl, or
                       -httpdir (see the option descriptions for more info.)

                       Note that for the Java viewer applet usage the
                       "?PORT=xxxx" in the various URLs printed at startup
                       will need to be supplied to the web browser to connect
                       properly.

                       Currently the automatic "single port" HTTPS mode of
                       -ssl is not fully supported in -stunnel mode.  However,
                       it can be emulated via:

                         % x11vnc -stunnel -http_ssl -http_oneport ...

                       In general, it is also not too difficult to set up
                       an stunnel or other SSL tunnel on the viewer side.
                       A simple example on Unix using stunnel 3.x is:

                         % stunnel -c -d localhost:5901 -r remotehost:5900
                         % vncviewer localhost:1

                       For Windows, stunnel has been ported to it and there
                       are probably other such tools available.  See the FAQ
                       and SSVNC for more examples.

<a name="opt-stunnel3"></a>-stunnel3  [pem]       Use version 3.x stunnel command line syntax instead of
                       version 4.x.  The -http/-httpdir Java applet serving
                       is currently not available in this mode.

<a name="opt-enc"></a>-enc cipher:keyfile    Use symmetric encryption with cipher "cipher"
                       and secret key data in "keyfile".  If keyfile is
                       pw=<string> then "string" is used as the key data.

                       NOTE: It is recommended that you use SSL via the -ssl
                       option instead of this option because SSL is well
                       understood and takes great care to establish unique
                       session keys and is more compatible with other software.
                       Use this option if you do not want to deal with SSL
                       certificates for authentication and do not want to
                       use SSH but want some encryption for your VNC session.
                       Or if you must interface with a symmetric key tunnel
                       that you do not have control over.

                       Note that this mode will NOT work with the UltraVNC DSM
                       plugins because they alter the RFB protocol in addition
                       to tunnelling with the symmetric cipher (an unfortunate
                       choice of implementation...)

                       cipher can be one of:  arc4, aesv2, aes-cfb, blowfish,
                       aes256, or 3des.  See the OpenSSL documentation for
                       more info.  The keysize is 128 bits (except for aes256).
                       Here is one way to make a keyfile with that many bits:

                            dd if=/dev/random of=./my.key bs=16 count=1

                       you will need to securely share this key with the other
                       side of the VNC connection (See SSVNC for examples).

                       Example:  -enc blowfish:./my.key
                       Example:  -enc blowfish:pw=swordfish

                       By default 16 bytes of random salt followed by 16 bytes
                       of random initialization vector are sent at the very
                       beginning of the stream.  The other side must read these
                       and initialize their cipher with them.  These values
                       make the session key unique (without them the security
                       is minimal).  Similarly, the other side must send us
                       its random salt and IV with those same lengths.

                       The salt and key data are combined to create a session
                       key using an md5 hash as described in EVP_BytesToKey(3).

                       The exact call is: EVP_BytesToKey(Cipher, EVP_md5(),
                       salt, keydata, len, 1, keystr, NULL);  where salt is
                       the random data as described above, and keydata is the
                       shared secret key data.  keystr is the resulting session
                       key.  The cipher is then seeded with keystr and uses
                       the random initialization vector as its first block.

                       To modify the amount of random salt and initialization
                       vector use cipher@n,m where n is the salt length and
                       m the initialization vector length.  E.g.

                                 -enc aes-cfb@8,16:./my.key

                       It is not a good idea to set either one to zero,
                       although you may be forced to if the other side of the
                       tunnel is not under your control.

                       To skip the salt and EVP_BytesToKey MD5 entirely (no
                       hashing is done: the keydata is directly inserted into
                       the cipher) specify "-1" for the salt, e.g.

                                 -enc blowfish@-1,16:./my.key

                       The message digest can also be changed to something
                       besides the default MD5\.  Use cipher@md+n,m where "md"
                       can be one of sha, sha1, md5, or ripe.  For example:

                                 -enc arc4@sha+8,16:./my.key

                       The SSVNC vnc viewer project supplies a symmetric
                       encryption tool named "ultravnc_dsm_helper" that can
                       be used on the viewer side.  For example:

                       ssvncviewer exec='ultravnc_dsm_helper arc4 my.key 0 h:p'

                       (or replace 'ssvncviewer' with 'ssvnc -viewer')
                       where h:p is the hostname and port of the x11vnc server.
                       ultravnc_dsm_helper may also be used standalone to
                       provide a symmetric encryption tunnel for any viewer
                       or server (VNC or otherwise.) The cipher (1st arg)
                       is basically the same syntax as we use above.

                       Also see the 'Non-Ultra DSM' SSVNC option for the
                       'UltraVNC DSM Encryption Plugin' advanced option.

                       For both ways of using the viewer, you can specify the
                       salt,ivec sizes (in GUI or, e.g. arc4@8,16).

<a name="opt-https"></a>-https [port]          Use a special, separate HTTPS port (-ssl and
                       -stunnel modes only) for HTTPS Java viewer applet
                       downloading. I.e. not 5900 and not 5800 (the defaults.)

                       BACKGROUND: In -ssl mode, it turns out you can use the
                       single VNC port (e.g. 5900) for both VNC and HTTPS
                       connections. (HTTPS is used to retrieve a SSL-aware
                       VncViewer.jar applet that is provided with x11vnc).
                       Since both use SSL the implementation was extended to
                       detect if HTTP traffic (i.e. GET) is taking place and
                       handle it accordingly.  The URL would be, e.g.:

                       https://mymachine.org:5900/

                       This is convenient for firewalls, etc, because only one
                       port needs to be allowed in.  However, this heuristic
                       adds a few seconds delay to each connection and can be
                       unreliable (especially if the user takes much time to
                       ponder the Certificate dialogs in his browser, Java VM,
                       or VNC Viewer applet.  That's right 3 separate "Are
                       you sure you want to connect?" dialogs!)

                       END OF BACKGROUND.

                       USAGE: So use the -https option to provide a separate,
                       more reliable HTTPS port that x11vnc will listen on.  If
                       [port] is not provided (or is 0), one is autoselected.
                       The URL to use is printed out at startup.

                       The SSL Java applet directory is specified via the
                       -httpdir option.  If not supplied, -https will try
                       to guess the directory as though the -http option
                       was supplied.

<a name="opt-httpsredir"></a>-httpsredir [port]     In -ssl mode with the Java applet retrieved via HTTPS,
                       when the HTML file containing applet parameters
                       ('index.vnc' or 'proxy.vnc') is sent do NOT set the
                       applet PORT parameter to the actual VNC port but set it
                       to "port" instead.  If "port" is not supplied, then
                       the port number is guessed from the Host: HTTP header.

                       This is useful when an incoming TCP connection
                       redirection is performed by a router/gateway/firewall
                       from one port to an internal machine where x11vnc is
                       listening on a different port. The Java applet needs to
                       connect to the firewall/router port, not the VNC port
                       on the internal workstation. For example, one could
                       redir from mygateway.com:443 to workstation:5900.

                       This spares the user from having to type in
                       https://mygateway.com/?PORT=443 into their web
                       browser. Note that port 443 is the default https port;
                       other ports must be explicitly indicated, for example:
                       https://mygateway.com:8000/?PORT=8000\.  To avoid having
                       to include the PORT= in the browser URL, simply supply
                       "-httpsredir" to x11vnc.

                       This option does not work in -stunnel mode.

                       More tricks: set the env var X11VNC_EXTRA_HTTPS_PARAMS
                       to be extra URL parameters to use.  This way you do
                       not need to specify extra PARAMS in the index.vnc file.
                       E.g. x11vnc -env X11VNC_EXTRA_HTTPS_PARAMS='?GET=1' ...

                       If you do not want to expose the non-SSL HTTP port to
                       the network (i.e. you just want the single VNC/HTTPS
                       port, e.g. 5900, open for connections) then specify the
                       option -env X11VNC_HTTP_LISTEN_LOCALHOST=1  This way
                       the connection to the LibVNCServer httpd server will
                       only be available on localhost (note that in -ssl mode,
                       HTTPS requests are redirected from SSL to the non-SSL
                       LibVNCServer HTTP server.)

<a name="opt-http_oneport"></a>-http_oneport          For UN-encrypted connections mode (i.e. no -ssl,
                       -stunnel, or -enc options), allow the Java VNC Viewer
                       applet to be downloaded thru the VNC port via HTTP.

                       That is to say, you can use a single port for Java
                       applet viewer connections by using a URL in your web
                       browser like this, for example:

                       http://hostname:5900

                       The regular, two-port mode, URL http://hostname:5800
                       will continue to work as well.

                       As mentioned above, this mode will NOT work with
                       the -ssl, -stunnel, or -enc encryption options.
                       Note that is it equivalent to '-enc none' (i.e. it
                       uses the same detection mechanism as for HTTPS, but
                       with no encryption.)

                       HTTPS single-port is on by default in -ssl encrypted
                       mode (and -enc too), so you only need -http_oneport
                       when doing non-SSL encrypted connections.

                       This mode could also be useful for SSH tunnels since
                       it means only one port needs to be redirected.

                       The -httpsredir option may also be useful for this
                       mode when using an SSH tunnel as well as for router
                       port redirections.

                       Note that the -env X11VNC_HTTP_LISTEN_LOCALHOST=1
                       option described above under -httpsredir applies for
                       the LibVNCServer httpd server in all cases (ssl or not.)

<a name="opt-ssh"></a>-ssh user@host:disp    Create a remote listening port on machine "host"
                       via a SSH tunnel using the -R rport:localhost:lport
                       method. lport will be the local x11vnc listening port,
                       so a connection to rport (5900+disp) on "host"
                       will reach x11vnc.  E.g. fred@snoopy.com:0

                       This could be useful if a firewall/router prevents
                       incoming connections to the x11vnc machine, but
                       the ssh machine "host" can be reached by the VNC
                       viewer. "user@" is not needed unless the remote unix
                       username differs from the current one.

                       By default the remote sshd is usually configured to
                       listen only on localhost for rport, so the viewer may
                       need to ssh -L redir to "host" as well (See SSVNC to
                       automate this).  The sshd setting GatewayPorts enables
                       listening on all interfaces for rport; viewers can
                       reach it more easily.

                       "disp" is the VNC display for the remote SSH side,
                       e.g. 0 corresponds to port 5900, etc.  If disp is
                       greater than 200 the value is used as the port.  Use a
                       negative value to force a low port, e.g. host:-80 will
                       use port 80.

                       If ssh-agent is not active, then the ssh password needs
                       to be entered in the terminal where x11vnc is running.

                       By default the remote ssh will issue a 'sleep 300' to
                       wait for the incoming connection for 5 mins.  To modify
                       this use user@host:disp+secs.

                       If the remote SSH server is on a non-standard port
                       (i.e. not 22) use user@host:port:disp+secs.

                       Note that the ssh process MAY NOT be killed when
                       x11vnc exits.  It tries by looking at ps(1) output.

<a name="opt-users"></a>-users list            If x11vnc is started as root (say from inetd(8) or from
                       display managers xdm(1), gdm(1), etc), then as soon
                       as possible after connections to the X display are
                       established try to switch to one of the users in the
                       comma separated "list".  If x11vnc is not running as
                       root this option is ignored.

                       Why use this option?  In general it is not needed since
                       x11vnc is already connected to the X display and can
                       perform its primary functions.  The option was added
                       to make some of the *external* utility commands x11vnc
                       occasionally runs work properly.  In particular under
                       GNOME and KDE to implement the "-solid color" feature
                       external commands (gconftool-2 and dcop) unfortunately
                       must be run as the user owning the desktop session.
                       Since this option switches userid it also affects the
                       userid used to run the processes for the -accept and
                       -gone options.  It also affects the ability to read
                       files for options such as -connect, -allow, and -remap
                       and also the ultra and tight filetransfer feature if
                       enabled.  Note that the -connect file is also sometimes
                       written to.

                       So be careful with this option since in some situations
                       its use can decrease security.

                       In general the switch to a user will only take place
                       if the display can still be successfully opened as that
                       user (this is primarily to try to guess the actual owner
                       of the session). Example: "-users fred,wilma,betty".
                       Note that a malicious local user "barney" by
                       quickly using "xhost +" when logging in may possibly
                       get the x11vnc process to switch to user "fred".
                       What happens next?

                       Under display managers it may be a long time before
                       the switch succeeds (i.e. a user logs in).  To instead
                       make it switch immediately regardless if the display
                       can be reopened prefix the username with the "+"
                       character. E.g. "-users +bob" or "-users +nobody".

                       The latter (i.e. switching immediately to user
                       "nobody") is the only obvious use of the -users option
                       that increases security.

                       Use the following notation to associate a group with
                       a user: user1.group1,user2.group2,...  Note that
                       initgroups(2) will still be called first to try to
                       switch to ALL of a user's groups (primary and additional
                       groups).  Only if that fails or it is not available
                       then the single group specified as above (or the user's
                       primary group if not specified) is switched to with
                       setgid(2).  Use -env X11VNC_SINGLE_GROUP=1 to prevent
                       trying initgroups(2) and only switch to the single
                       group.  This sort of setting is only really needed to
                       make the ultra or tight filetransfer permissions work
                       properly. This format applies to any comma separated list
                       of users, even the special "=" modes described below.

                       In -unixpw mode, if "-users unixpw=" is supplied
                       then after a user authenticates himself via the
                       -unixpw mechanism, x11vnc will try to switch to that
                       user as though "-users +username" had been supplied.
                       If you want to limit which users this will be done for,
                       provide them as a comma separated list after "unixpw="
                       Groups can also be specified as described above.

                       Similarly, in -ssl mode, if "-users sslpeer=" is
                       supplied then after an SSL client authenticates with his
                       cert (the -sslverify option is required for this) x11vnc
                       will extract a UNIX username from the "emailAddress"
                       field (username@hostname.com) of the "Subject" of the
                       x509 SSL cert and then try to switch to that user as
                       though "-users +username" had been supplied.  If you
                       want to limit which users this will be done for, provide
                       them as a comma separated list after "sslpeer=".
                       Set the env. var X11VNC_SSLPEER_CN to use the Common
                       Name (normally a hostname) instead of the Email field.

                       NOTE: for sslpeer= mode the x11vnc administrator must
                       take care that any client certs he adds to -sslverify
                       have the intended UNIX username in the "emailAddress"
                       field of the cert.  Otherwise a user may be able to
                       log in as another.  This command can be of use in
                       checking: "openssl x509 -text -in file.crt", see the
                       "Subject:" line.  Also, along with the normal RFB_*
                       env. vars. (see -accept) passed to external cmd=
                       commands, RFB_SSL_CLIENT_CERT will be set to the
                       client's x509 certificate string.

                       The sslpeer= mode can aid finding X sessions via the
                       FINDDISPLAY and FINDCREATEDISPLAY mechanisms.

                       To immediately switch to a user *before* connections
                       to the X display are made or any files opened use the
                       "=" character: "-users =bob".  That user needs to
                       be able to open the X display and any files of course.

                       The special user "guess=" means to examine the utmpx
                       database (see who(1)) looking for a user attached to
                       the display number (from DISPLAY or -display option)
                       and try him/her.  To limit the list of guesses, use:
                       "-users guess=bob,betty".

                       Even more sinister is the special user "lurk="
                       that means to try to guess the DISPLAY from the utmpx
                       login database as well.  So it "lurks" waiting for
                       anyone to log into an X session and then connects to it.
                       Specify a list of users after the = to limit which users
                       will be tried.  To enable a different searching mode, if
                       the first user in the list is something like ":0" or
                       ":0-2" that indicates a range of DISPLAY numbers that
                       will be tried (regardless of whether they are in the
                       utmpx database) for all users that are logged in.  Also
                       see the "-display WAIT:..." functionality.  Examples:
                       "-users lurk=" and also "-users lurk=:0-1,bob,mary"

                       Be especially careful using the "guess=" and "lurk="
                       modes.  They are not recommended for use on machines
                       with untrustworthy local users.

<a name="opt-noshm"></a>-noshm                 Do not use the MIT-SHM extension for the polling.
                       Remote displays can be polled this way: be careful this
                       can use large amounts of network bandwidth.  This is
                       also of use if the local machine has a limited number
                       of shm segments and -onetile is not sufficient.
<a name="opt-flipbyteorder"></a>-flipbyteorder         Sometimes needed if remotely polled host has different
                       endianness.  Ignored unless -noshm is set.
<a name="opt-onetile"></a>-onetile               Do not use the new copy_tiles() framebuffer mechanism,
                       just use 1 shm tile for polling.  Limits shm segments
                       used to 3.

                       To disable any automatic shm reduction set the
                       env. var. X11VNC_NO_LIMIT_SHM.

<a name="opt-solid"></a>-solid [color]         To improve performance, when VNC clients are connected
                       try to change the desktop background to a solid color.
                       The [color] is optional: the default color is "cyan4".
                       For a different one specify the X color (rgb.txt name,
                       e.g. "darkblue" or numerical "#RRGGBB").

                       Currently this option only works on GNOME, KDE, CDE,
                       XFCE, and classic X (i.e. with the background image
                       on the root window).  The "gconftool-2", "dcop"
                       and "xfconf-query" external commands are run for
                       GNOME, KDE, and XFCE respectively.  This also works
                       on native MacOSX.  (There is no color selection for
                       MacOSX or XFCE.)  Other desktops won't work, (send
                       us the corresponding commands if you find them).
                       If x11vnc is running as root (inetd(8) or gdm(1)),
                       the -users option may be needed for GNOME, KDE, XFCE.
                       If x11vnc guesses your desktop incorrectly, you can
                       force it by prefixing color with "gnome:", "kde:",
                       "cde:", "xfce:", or "root:".

                       Update: -solid no longer works on KDE4.

                       This mode works in a limited way on the Mac OS X Console
                       with one color ('kelp') using the screensaver writing
                       to the background.  Look in "~/Library/Screen Savers"
                       for VncSolidColor.png to change the color.

<a name="opt-blackout"></a>-blackout string       Black out rectangles on the screen. "string" is a
                       comma separated list of WxH+X+Y type geometries for
                       each rectangle.  If one of the items on the list is the
                       string "noptr" the mouse pointer will not be allowed
                       to go into a blacked out region.
<a name="opt-xinerama"></a>-xinerama              If your screen is composed of multiple monitors
<a name="opt-noxinerama"></a>-noxinerama            glued together via XINERAMA, and that screen is
                       not a rectangle this option will try to guess the
                       areas to black out (if your system has libXinerama).
                       default: -xinerama

                       In general, we have noticed on XINERAMA displays you may
                       need to use the "-xwarppointer" option if the mouse
                       pointer misbehaves and it is enabled by default. Use
                       "-noxwarppointer" if you do not want this.

<a name="opt-xtrap"></a>-xtrap                 Use the DEC-XTRAP extension for keystroke and mouse
                       input insertion.  For use on legacy systems, e.g. X11R5,
                       running an incomplete or missing XTEST extension.
                       By default DEC-XTRAP will be used if XTEST server grab
                       control is missing, use -xtrap to do the keystroke and
                       mouse insertion via DEC-XTRAP as well.

<a name="opt-xrandr"></a>-xrandr [mode]         If the display supports the XRANDR (X Resize, Rotate
                       and Reflection) extension, and you expect XRANDR events
                       to occur to the display while x11vnc is running, this
                       options indicates x11vnc should try to respond to
                       them (as opposed to simply crashing by assuming the
                       old screen size).  See the xrandr(1) manpage and run
                       'xrandr -q' for more info.  [mode] is optional and
                       described below.

                       Since watching for XRANDR events and trapping errors
                       increases polling overhead, only use this option if
                       XRANDR changes are expected.  For example on a rotatable
                       screen PDA or laptop, or using a XRANDR-aware Desktop
                       where you resize often.  It is best to be viewing with a
                       vncviewer that supports the NewFBSize encoding, since it
                       knows how to react to screen size changes.  Otherwise,
                       LibVNCServer tries to do so something reasonable for
                       viewers that cannot do this (portions of the screen
                       may be clipped, unused, etc).

                       Note: the default now is to check for XRANDR events, but
                       do not trap every X call that may fail due to resize.
                       If a resize event is received, the full -xrandr mode
                       is enabled.  To disable even checking for events supply:
                       -noxrandr.

                       "mode" defaults to "resize", which means create a
                       new, resized, framebuffer and hope all viewers can cope
                       with the change.  "newfbsize" means first disconnect
                       all viewers that do not support the NewFBSize VNC
                       encoding, and then resize the framebuffer.  "exit"
                       means disconnect all viewer clients, and then terminate
                       x11vnc.

<a name="opt-rotate"></a>-rotate string         Rotate and/or flip the framebuffer view exported by VNC.
                       This transformation is independent of XRANDR and is
                       done in software in main memory and so may be slower.
                       This mode could be useful on a handheld with portrait or
                       landscape modes that do not correspond to the scanline
                       order of the actual framebuffer.  "string" can be:

                             x     flip along x-axis
                             y     flip along y-axis
                            xy     flip along x- and y-axes
                           +90     rotate 90 degrees clockwise
                           -90     rotate 90 degrees counter-clockwise
                          +90x     rotate 90 degrees CW, then flip along x
                          +90y     rotate 90 degrees CW, then flip along y

                       these give all possible rotations and reflections.

                       Aliases: same as xy:  yx, +180, -180, 180
                                same as -90: +270, 270
                                same as +90: 90, (ditto for 90x, 90y)

                       Like -scale, this transformation is applied at the very
                       end of any chain of framebuffer transformations and so
                       any options with geometries, e.g. -blackout, -clip, etc.
                       are relative to the original X (or -rawfb) framebuffer,
                       not the final one sent to VNC viewers.

                       If you do not want the cursor shape to be rotated
                       prefix "string" with "nc:", e.g. "nc:+90",
                       "nc:xy", etc.

<a name="opt-padgeom"></a>-padgeom WxH           Whenever a new vncviewer connects, the framebuffer is
                       replaced with a fake, solid black one of geometry WxH.
                       Shortly afterwards the framebuffer is replaced with the
                       real one.  This is intended for use with vncviewers
                       that do not support NewFBSize and one wants to make
                       sure the initial viewer geometry will be big enough
                       to handle all subsequent resizes (e.g. under -xrandr,
                       -remote id:windowid, rescaling, etc.)

                       In -unixpw mode this sets the size of the login screen.
                       Use "once:WxH" it ignore padgeom after the login
                       screen is set up.

<a name="opt-o"></a>-o logfile             Write stderr messages to file "logfile" instead of to
                       the terminal.  Same as "-logfile file".  To append
                       to the file use "-oa file" or "-logappend file".
                       If "logfile" contains the string "%VNCDISPLAY"
                       it is expanded to the vnc display (the name may need
                       to be guessed at.)  "%HOME" works too.

<a name="opt-flag"></a>-flag file             Write the "PORT=NNNN" (e.g. PORT=5900) string to
                       "file" in addition to stdout.  This option could be
                       useful by wrapper script to detect when x11vnc is ready.

<a name="opt-rmflag"></a>-rmflag file           Remove "file" at exit to signal when x11vnc is done.
                       The file is created at startup if it does not already
                       exist or if "file" is prefixed with "create:".
                       If the file is created, the x11vnc PID is placed in
                       the file.  Otherwise the files contents is not changed.
                       Use prefix "nocreate:" to prevent creation.

<a name="opt-rc"></a>-rc filename           Use "filename" instead of $HOME/.x11vncrc for rc file.
<a name="opt-norc"></a>-norc                  Do not process any .x11vncrc file for options.

<a name="opt-env"></a>-env VAR=VALUE         Set the environment variable 'VAR' to value 'VALUE'
                       at x11vnc startup.  This is a convenience utility to
                       avoid shell script wrappers, etc. to set the env. var.
                       You may specify as many of these as needed on the
                       command line.
<a name="opt-prog"></a>-prog /path/to/x11vnc  Set the full path to the x11vnc program for cases when
                       it cannot be determined from argv[0] (e.g. tcpd/inetd)

<a name="opt-h,"></a>-h, -help              Print this help text.
<a name="opt-?,"></a>-?, -opts              Only list the x11vnc options.
<a name="opt-V,"></a>-V, -version           Print program version and last modification date.
<a name="opt-license"></a>-license               Print out license information.  Same as -copying and
                       -warranty.

<a name="opt-dbg"></a>-dbg                   Instead of exiting after cleaning up, run a simple
                       "debug crash shell" when fatal errors are trapped.

<a name="opt-q,"></a>-q, -quiet             Be quiet by printing less informational output to
                       stderr. (use -noquiet to undo an earlier -quiet.)

                       The -quiet option does not eliminate all informational
                       output, it only reduces it.  It is ignored in most
                       auxiliary usage modes, e.g. -storepasswd.  To eliminate
                       all output use: 2>/dev/null 1>&2, etc.

<a name="opt-v,"></a>-v, -verbose           Print out more information to stderr.

<a name="opt-bg"></a>-bg                    Go into the background after screen setup.  Messages to
                       stderr are lost unless -o logfile is used.  Something
                       like this could be useful in a script:
                        port=`ssh -t $host "x11vnc -display :0 -bg" | grep PORT`
                        port=`echo "$port" | sed -e 's/PORT=//'`
                        port=`expr $port - 5900`
                        vncviewer $host:$port

<a name="opt-modtweak"></a>-modtweak              Option -modtweak automatically tries to adjust the AltGr
<a name="opt-nomodtweak"></a>-nomodtweak            and Shift modifiers for differing language keyboards
                       between client and host.  Otherwise, only a single key
                       press/release of a Keycode is simulated (i.e. ignoring
                       the state of the modifiers: this usually works for
                       identical keyboards).  Also useful in resolving cases
                       where a Keysym is bound to multiple keys (e.g. "<" + ">"
                       and "," + "<" keys).  Default: -modtweak

                       If you are having trouble with with keys and -xkb or
                       -noxkb, and similar things don't help, try -nomodtweak.

                       On some HP-UX systems it is been noted that they have
                       an odd keymapping where a single keycode will have a
                       keysym, e.g. "#", up to three times.  You can check
                       via "xmodmap -pk" or the -dk option.  The failure
                       is when you try to type "#" it yields "3".  If you
                       see this problem try setting the environment variable
                       MODTWEAK_LOWEST=1 to see if it helps.

<a name="opt-xkb"></a>-xkb                   When in modtweak mode, use the XKEYBOARD extension (if
<a name="opt-noxkb"></a>-noxkb                 the X display supports it) to do the modifier tweaking.
                       This is powerful and should be tried if there are still
                       keymapping problems when using -modtweak by itself.
                       The default is to check whether some common keysyms,
                       e.g. !, @, [, are only accessible via -xkb mode and if
                       so then automatically enable the mode.  To disable this
                       automatic detection use -noxkb.

                       When -xkb mode is active you can set these env. vars.
                       They apply only when there is ambiguity as to which
                       key to choose (i.e the mapping is not one-to-one).
                       NOKEYHINTS=1: for up ascii keystrokes do not use score
                       hints saved when the key was pressed down. NOANYDOWN=1:
                       for up keystrokes do not resort to searching through
                       keys that are currently pressed down.  KEYSDOWN=N:
                       remember the last N keys press down for tie-breaking
                       when an up keystroke comes in.

<a name="opt-capslock"></a>-capslock              When in -modtweak (the default) or -xkb mode,
                       if a keysym in the range A-Z comes in check the X
                       server to see if the Caps_Lock is set.  If it is do
                       not artificially press Shift to generate the keysym.
                       This will enable the CapsLock key to behave correctly
                       in some circumstances: namely *both* the VNC viewer
                       machine and the x11vnc X server are in the CapsLock
                       on state.  If one side has CapsLock on and the other
                       off and the keyboard is not behaving as you think it
                       should you should correct the CapsLock states (hint:
                       pressing CapsLock inside and outside of the viewer can
                       help toggle them both to the correct state).  However,
                       for best results do not use this option, but rather
                       *only* enable CapsLock on the VNC viewer side (i.e. by
                       pressing CapsLock outside of the viewer window, also
                       -skip_lockkeys below).  Also try -nomodtweak for a
                       possible workaround.

<a name="opt-skip_lockkeys"></a>-skip_lockkeys         Have x11vnc ignore all Caps_Lock, Shift_Lock, Num_Lock,
<a name="opt-noskip_lockkeys"></a>-noskip_lockkeys       Scroll_Lock keysyms received from viewers.  The idea is
                       you press Caps_Lock on the VNC Viewer side but that does
                       not change the lock state in the x11vnc-side X server.
                       Nevertheless your capitalized letters come in over
                       the wire and are applied correctly to the x11vnc-side
                       X server.  Note this mode probably won't do what you
                       want in -nomodtweak mode.  Also, a kludge for KP_n
                       digits is always done in this mode: they are mapped to
                       regular digit keysyms.  See also -capslock above.
                       The default is -noskip_lockkeys.

<a name="opt-skip_keycodes"></a>-skip_keycodes string  Ignore the comma separated list of decimal keycodes.
                       Perhaps these are keycodes not on your keyboard but
                       your X server thinks exist.  Currently only applies
                       to -xkb mode.  Use this option to help x11vnc in the
                       reverse problem it tries to solve: Keysym -> Keycode(s)
                       when ambiguities exist (more than one Keycode per
                       Keysym).  Run 'xmodmap -pk' to see your keymapping.
                       Example: "-skip_keycodes 94,114"
<a name="opt-sloppy_keys"></a>-sloppy_keys           Experimental option that tries to correct some
                       "sloppy" key behavior.  E.g. if at the viewer you
                       press Shift+Key but then release the Shift before
                       Key that could give rise to extra unwanted characters
                       (usually only between keyboards of different languages).
                       Only use this option if you observe problems with
                       some keystrokes.
<a name="opt-skip_dups"></a>-skip_dups             Some VNC viewers send impossible repeated key events,
<a name="opt-noskip_dups"></a>-noskip_dups           e.g. key-down, key-down, key-up, key-up all for the same
                       key, or 20 downs in a row for the same modifier key!
                       Setting -skip_dups means to skip these duplicates and
                       just process the first event. Note: some VNC viewers
                       assume they can send down's without the corresponding
                       up's and so you should not set this option for
                       these viewers (symptom: some keys do not autorepeat)
                       Default: -noskip_dups
<a name="opt-add_keysyms"></a>-add_keysyms           If a Keysym is received from a VNC viewer and that
<a name="opt-noadd_keysyms"></a>-noadd_keysyms         Keysym does not exist in the X server, then add the
                       Keysym to the X server's keyboard mapping on an unused
                       key.  Added Keysyms will be removed periodically and
                       also when x11vnc exits.  Default: -add_keysyms
<a name="opt-clear_mods"></a>-clear_mods            At startup and exit clear the modifier keys by sending
                       KeyRelease for each one. The Lock modifiers are skipped.
                       Used to clear the state if the display was accidentally
                       left with any pressed down.
<a name="opt-clear_keys"></a>-clear_keys            As -clear_mods, except try to release ANY pressed key.
                       Note that this option and -clear_mods can interfere
                       with a person typing at the physical keyboard.
<a name="opt-clear_all"></a>-clear_all             As -clear_keys, except try to release any CapsLock,
                       NumLock, etc. locks as well.

<a name="opt-remap"></a>-remap string          Read Keysym remappings from file named "string".
                       Format is one pair of Keysyms per line (can be name
                       or hex value) separated by a space.  If no file named
                       "string" exists, it is instead interpreted as this
                       form: key1-key2,key3-key4,...  See <X11/keysymdef.h>
                       header file for a list of Keysym names, or use xev(1).

                       To map a key to a button click, use the fake Keysyms
                       "Button1", ..., etc. E.g: "-remap Super_R-Button2"
                       (useful for pasting on a laptop)

                       I use these if the machine I am viewing from does not
                       have a scrollwheel or I don't like using the one it has:

                              -remap Super_R-Button4,Menu-Button5
                              -remap KP_Add-Button4,KP_Enter-Button5

                       the former would be used on a PC, the latter on a
                       MacBook.  This way those little used keys can be used
                       to generate bigger hops than the Up and Down arrows
                       provide.  One can scroll through text or web pages more
                       quickly this way (especially if x11vnc scroll detection
                       is active.)

                       Use Button44, Button12, etc. for multiple clicks.

                       To disable a keysym (i.e. make it so it will not be
                       injected), remap it to "NoSymbol" or "None".

                       Dead keys: "dead" (or silent, mute) keys are keys that
                       do not produce a character but must be followed by a 2nd
                       keystroke.  This is often used for accenting characters,
                       e.g. to put "`" on top of "a" by pressing the dead
                       key and then "a".  Note that this interpretation
                       is not part of core X11, it is up to the toolkit or
                       application to decide how to react to the sequence.
                       The X11 names for these keysyms are "dead_grave",
                       "dead_acute", etc.  However some VNC viewers send the
                       keysyms "grave", "acute" instead thereby disabling
                       the accenting.  To work around this -remap can be used.
                       For example "-remap grave-dead_grave,acute-dead_acute"
                       As a convenience, "-remap DEAD" applies these remaps:

                               g     grave-dead_grave
                               a     acute-dead_acute
                               c     asciicircum-dead_circumflex
                               t     asciitilde-dead_tilde
                               m     macron-dead_macron
                               b     breve-dead_breve
                               D     abovedot-dead_abovedot
                               d     diaeresis-dead_diaeresis
                               o     degree-dead_abovering
                               A     doubleacute-dead_doubleacute
                               r     caron-dead_caron
                               e     cedilla-dead_cedilla

                       If you just want a subset use the first letter
                       label, e.g. "-remap DEAD=ga" to get the first two.
                       Additional remaps may also be supplied via commas,
                       e.g.  "-remap DEAD=ga,Super_R-Button2".  Finally,
                       "DEAD=missing" means to apply all of the above as
                       long as the left hand member is not already in the
                       X11 keymap.

<a name="opt-norepeat"></a>-norepeat              Option -norepeat disables X server key auto repeat when
<a name="opt-repeat"></a>-repeat                VNC clients are connected and VNC keyboard input is
                       not idle for more than 5 minutes.  This works around a
                       repeating keystrokes bug (triggered by long processing
                       delays between key down and key up client events:
                       either from large screen changes or high latency).
                       Default: -norepeat

                       You can set the env. var. X11VNC_IDLE_TIMEOUT to the
                       number of idle seconds you want (5min = 300secs).

                       Note: your VNC viewer side will likely do autorepeating,
                       so this is no loss unless someone is simultaneously at
                       the real X display.

                       Use "-norepeat N" to set how many times norepeat will
                       be reset if something else (e.g. X session manager)
                       undoes it.  The default is 2\.  Use a negative value
                       for unlimited resets.

<a name="opt-nofb"></a>-nofb                  Ignore video framebuffer: only process keyboard and
                       pointer.  Intended for use with Win2VNC and x2vnc
                       dual-monitor setups.
<a name="opt-nobell"></a>-nobell                Do not watch for XBell events. (no beeps will be heard)
                       Note: XBell monitoring requires the XKEYBOARD extension.
<a name="opt-nosel"></a>-nosel                 Do not manage exchange of X selection/cutbuffer between
                       VNC viewers and the X server at all.
<a name="opt-noprimary"></a>-noprimary             Do not poll the PRIMARY selection for changes to send
                       back to clients.  (PRIMARY is still set on received
                       changes, however).
<a name="opt-nosetprimary"></a>-nosetprimary          Do not set the PRIMARY selection for changes received
                       from VNC clients.
<a name="opt-noclipboard"></a>-noclipboard           Do not poll the CLIPBOARD selection for changes to send
                       back to clients.  (CLIPBOARD is still set on received
                       changes, however).
<a name="opt-nosetclipboard"></a>-nosetclipboard        Do not set the CLIPBOARD selection for changes
                       received from VNC clients.
<a name="opt-seldir"></a>-seldir string         If direction string is "send", only send the selection
                       to viewers, and if it is "recv" only receive it from
                       viewers.  To work around apps setting the selection
                       too frequently and messing up the other end.  You can
                       actually supply a comma separated list of directions,
                       including "debug" to turn on debugging output.

<a name="opt-cursor"></a>-cursor [mode]         Sets how the pointer cursor shape (little icon at the
<a name="opt-nocursor"></a>-nocursor              mouse pointer) should be handled.  The "mode" string
                       is optional and is described below.  The default
                       is to show some sort of cursor shape(s).  How this
                       is done depends on the VNC viewer and the X server.
                       Use -nocursor to disable cursor shapes completely.

                       Some VNC viewers support the TightVNC CursorPosUpdates
                       and CursorShapeUpdates extensions (cuts down on
                       network traffic by not having to send the cursor image
                       every time the pointer is moved), in which case these
                       extensions are used (see -nocursorshape and -nocursorpos
                       below to disable).  For other viewers the cursor shape
                       is written directly to the framebuffer every time the
                       pointer is moved or changed and gets sent along with
                       the other framebuffer updates.  In this case, there
                       will be some lag between the vnc viewer pointer and
                       the remote cursor position.

                       If the X display supports retrieving the cursor shape
                       information from the X server, then the default is
                       to use that mode.  On Solaris this can be done with
                       the SUN_OVL extension using -overlay (see also the
                       -overlay_nocursor option).  A similar overlay scheme
                       is used on IRIX.  Xorg (e.g. Linux) and recent Solaris
                       Xsun servers support the XFIXES extension to retrieve
                       the exact cursor shape from the X server.  If XFIXES
                       is present it is preferred over Overlay and is used by
                       default (see -noxfixes below).  This can be disabled
                       with -nocursor, and also some values of the "mode"
                       option below.

                       Note that under XFIXES cursors with transparency (alpha
                       channel) will usually not be exactly represented and one
                       may find Overlay preferable.  See also the -alphacut
                       and -alphafrac options below as fudge factors to try
                       to improve the situation for cursors with transparency
                       for a given theme.

                       The "mode" string can be used to fine-tune the
                       displaying of cursor shapes.  It can be used the
                       following ways:

                       "-cursor arrow" - just show the standard arrow
                       nothing more or nothing less.

                       "-cursor none" - same as "-nocursor"

                       "-cursor X" - when the cursor appears to be on the
                       root window, draw the familiar X shape.  Some desktops
                       such as GNOME cover up the root window completely,
                       and so this will not work, try "X1", etc, to try to
                       shift the tree depth.  On high latency links or slow
                       machines there will be a time lag between expected and
                       the actual cursor shape.

                       "-cursor some" - like "X" but use additional
                       heuristics to try to guess if the window should have
                       a windowmanager-like resizer cursor or a text input
                       I-beam cursor.  This is a complete hack, but may be
                       useful in some situations because it provides a little
                       more feedback about the cursor shape.

                       "-cursor most" - try to show as many cursors as
                       possible.  Often this will only be the same as "some"
                       unless the display has overlay visuals or XFIXES
                       extensions available.  On Solaris and IRIX if XFIXES
                       is not available, -overlay mode will be attempted.

<a name="opt-cursor_drag"></a>-cursor_drag           Show cursor shape changes even when the mouse is being
                       dragged with a mouse button down.  This is useful if you
                       want to be able to see Drag-and-Drop cursor icons, etc.

<a name="opt-arrow"></a>-arrow n               Choose an alternate "arrow" cursor from a set of
                       some common ones.  n can be 1 to 6\.  Default is: 1
                       Ignored when in XFIXES cursor-grabbing mode.

<a name="opt-noxfixes"></a>-noxfixes              Do not use the XFIXES extension to draw the exact cursor
                       shape even if it is available.

                       Note: To work around a crash in Xorg 1.5 and later
                       some people needed to use -noxfixes.  The Xorg crash
                       occurred right after a Display Manager (e.g. GDM) login.
                       Starting with x11vnc 0.9.9 it tries to automatically
                       avoid using XFIXES until it is sure a window manager
                       is running.  See the -reopen option for more info and
                       how to use X11VNC_AVOID_WINDOWS=never to disable it.

<a name="opt-alphacut"></a>-alphacut n            When using the XFIXES extension for the cursor shape,
                       cursors with transparency will not usually be displayed
                       exactly (but opaque ones will).  This option sets n as
                       a cutoff for cursors that have transparency ("alpha
                       channel" with values ranging from 0 to 255) Any cursor
                       pixel with alpha value less than n becomes completely
                       transparent.  Otherwise the pixel is completely opaque.
                       Default 240

<a name="opt-alphafrac"></a>-alphafrac fraction    With the threshold in -alphacut some cursors will become
                       almost completely transparent because their alpha values
                       are not high enough.  For those cursors adjust the
                       alpha threshold until fraction of the non-zero alpha
                       channel pixels become opaque.  Default 0.33
<a name="opt-alpharemove"></a>-alpharemove           By default, XFIXES cursors pixels with transparency have
                       the alpha factor multiplied into the RGB color values
                       (i.e. that corresponding to blending the cursor with a
                       black background).  Specify this option to remove the
                       alpha factor. (useful for light colored semi-transparent
                       cursors).
<a name="opt-noalphablend"></a>-noalphablend          In XFIXES mode do not send cursor alpha channel data
                       to LibVNCServer.  The default is to send it.  The
                       alphablend effect will only be visible in -nocursorshape
                       mode or for clients with cursorshapeupdates turned
                       off. (However there is a hack for 32bpp with depth 24,
                       it uses the extra 8 bits to store cursor transparency
                       for use with a hacked vncviewer that applies the
                       transparency locally.  See the FAQ for more info).

<a name="opt-nocursorshape"></a>-nocursorshape         Do not use the TightVNC CursorShapeUpdates extension
                       even if clients support it.  See -cursor above.
<a name="opt-cursorpos"></a>-cursorpos             Option -cursorpos enables sending the X cursor position
<a name="opt-nocursorpos"></a>-nocursorpos           back to all vnc clients that support the TightVNC
                       CursorPosUpdates extension.  Other clients will be able
                       to see the pointer motions. Default: -cursorpos
<a name="opt-xwarppointer"></a>-xwarppointer          Move the pointer with XWarpPointer(3X) instead of
<a name="opt-noxwarppointer"></a>-noxwarppointer        the XTEST extension.  Use this as a workaround
                       if the pointer motion behaves incorrectly, e.g.
                       on touchscreens or other non-standard setups.

                       It is also sometimes needed on XINERAMA displays and is
                       enabled by default if XINERAMA is found to be active.
                       To prevent this, use -noxwarppointer.

                       Also since 2009 there is an Xorg bug where the pointer
                       cannot be moved properly on multiscreen displays.
                       If x11vnc detects a multiscreen display it activates
                       this option.  To prevent this, use -noxwarppointer.

<a name="opt-always_inject"></a>-always_inject         Even if there is no displacement (dx = dy = 0) for a
                       VNC mouse event force the pointer to the indicated x,y
                       position anyway.  Recent (2009) gui toolkits (gnome)
                       have problems with x11vnc's original mouse input
                       injection method.  So x11vnc's mouse input injection
                       method has been modified.  To regain the OLD behavior
                       use this option: -always_inject.  Then x11vnc will
                       always force positioning the mouse to the x,y position
                       even if that position has not changed since the previous
                       VNC input event.

                       The first place this problem was noticed was in gnome
                       terminal: if you pressed and released mouse button 3, a
                       menu was posted and then its first element 'New Terminal
                       Window' was activated.  This was because x11vnc injected
                       the mouse position twice: once on ButtonPress and again
                       on ButtonRelease.  The toolkit interpreted the 2nd one
                       as mouse motion even though the mouse hadn't moved.
                       So now by default x11vnc tries to avoid injecting the
                       2nd one.

                       Note that with the new default x11vnc will be oblivious
                       to applications moving the pointer (warping) or the
                       user at the physical display moving it.  So it might,
                       e.g., inject ButtonRelease at the wrong position.
                       If this (or similar scenarios) causes problems in your
                       environment, specify -always_inject for the old method.

<a name="opt-buttonmap"></a>-buttonmap string      String to remap mouse buttons.  Format: IJK-LMN, this
                       maps buttons I -> L, etc., e.g.  -buttonmap 13-31

                       Button presses can also be mapped to keystrokes: replace
                       a button digit on the right of the dash with :<sym>:
                       or :<sym1>+<sym2>: etc. for multiple keys. For example,
                       if the viewing machine has a mouse-wheel (buttons 4 5)
                       but the x11vnc side does not, these will do scrolls:
                              -buttonmap 12345-123:Prior::Next:
                              -buttonmap 12345-123:Up+Up+Up::Down+Down+Down:

                       See <X11/keysymdef.h> header file for a list of Keysyms,
                       or use the xev(1) program.  Note: mapping of button
                       clicks to Keysyms may not work if -modtweak or -xkb is
                       needed for the Keysym.

                       If you include a modifier like "Shift_L" the
                       modifier's up/down state is toggled, e.g. to send
                       "The" use :Shift_L+t+Shift_L+h+e: (the 1st one is
                       shift down and the 2nd one is shift up). (note: the
                       initial state of the modifier is ignored and not reset)
                       To include button events use "Button1", ... etc.

                       -buttonmap currently does not work on MacOSX console
                       or in -rawfb mode.

                       Workaround: use -buttonmap IJ...-LM...=n to limit the
                       number of mouse buttons to n, e.g. 123-123=3\.  This will
                       prevent x11vnc from crashing if the X server reports
                       there are 5 buttons (4/5 scroll wheel), but there are
                       only really 3.

<a name="opt-nodragging"></a>-nodragging            Do not update the display during mouse dragging events
                       (mouse button held down).  Greatly improves response on
                       slow setups, but you lose all visual feedback for drags,
                       text selection, and some menu traversals.  It overrides
                       any -pointer_mode setting.

<a name="opt-ncache"></a>-ncache n              Client-side caching scheme.  Framebuffer memory "n"
                       (an integer) times that of the full display is allocated
                       below the actual framebuffer to cache screen contents
                       for rapid retrieval.  So a W x H frambuffer is expanded
                       to a W x (n+1)*H one.  Use 0 to disable.

                       The "n" is actually optional, the default is 10.

                       For this and the other -ncache* options below you can
                       abbreviate "-ncache" with "-nc".  Also, "-nonc"
                       is the same as "-ncache 0"

                       This is an experimental option, currently implemented in
                       an awkward way in that in the VNC Viewer you can see the
                       pixel cache contents if you scroll down, etc.  So you
                       will have to set things up so you can't see that region.
                       If this method is successful, the changes required for
                       clients to do this less awkwardly will be investigated.

                       The SSVNC viewer does a good job at automatically hiding
                       the pixel cache region.  Or use SSVNC's -ycrop option
                       to explicitly hide the region.

                       Note that this mode consumes a huge amount of memory,
                       both on the x11vnc server side and on the VNC Viewer
                       side.  If n=2 then the amount of RAM used is roughly
                       tripled for both x11vnc and the VNC Viewer.  As a rule
                       of thumb, note that 1280x1024 at depth 24 is about 5MB
                       of pixel data.

                       For reasonable response when cycling through 4 to 6
                       large (e.g. web browser) windows a value n of 6 to 12
                       is recommended. (that's right: ~10X more memory...)

                       Because of the way window backingstore and saveunders
                       are implemented, n must be even.  It will be incremented
                       by 1 if it is not.

                       This mode also works for native MacOS X, but may not
                       be as effective as the X version.  This is due to a
                       number of things, one is the drop-shadow compositing
                       that leaves extra areas that need to be repaired (see
                       -ncache_pad).  Another is the window iconification
                       animations need to be avoided (see -macicontime).
                       It appears the that the 'Scale' animation mode gives
                       better results than the 'Genie' one.  Also, window event
                       detection not as accurate as the X version.

<a name="opt-ncache_cr"></a>-ncache_cr             In -ncache mode, try to do copyrect opaque window
                       moves/drags instead of wireframes (this can induce
                       painting errors).  The wireframe will still be used when
                       moving a window whose save-unders has not yet been set
                       or has been invalidated.

                       Some VNC Viewers provide better response than others
                       with this option.  On Unix, realvnc viewer gives
                       smoother drags than tightvnc viewer.  Response may also
                       be choppy if the server side machine is too slow.

                       Sometimes on very slow modem connections, this actually
                       gives an improvement because no pixel data at all
                       (not even the box animation) is sent during the drag.

<a name="opt-ncache_no_moveraise"></a>-ncache_no_moveraise   In -ncache mode, do not assume that moving a window
                       will cause the window manager to raise it to the top
                       of the stack.  The default is to assume it does, and
                       so at the beginning of any wireframe, etc, window moves
                       the window will be pushed to top in the VNC viewer.

<a name="opt-ncache_no_dtchange"></a>-ncache_no_dtchange    In -ncache mode, do not try to guess when the desktop
                       (viewport) changes to another one (i.e. another
                       workarea).  The default is to try to guess and when
                       detected try to make the transistion more smoothly.

<a name="opt-ncache_no_rootpixmap"></a>-ncache_no_rootpixmap  In -ncache mode, do not try to snapshot the desktop
                       background to use in guessing or reconstructing window
                       save-unders.

<a name="opt-ncache_keep_anims"></a>-ncache_keep_anims     In -ncache mode, do not try to disable window
                       manager animations and other effects (that usually
                       degrade ncache performance or cause painting errors).
                       The default is to try to disable them on KDE (but not
                       GNOME) when VNC clients are connected.

                       For other window managers or desktops that provide
                       animations, effects, compositing, translucency,
                       etc. that interfere with the -ncache method you will
                       have to disable them manually.

<a name="opt-ncache_old_wm"></a>-ncache_old_wm         In -ncache mode, enable some heuristics for old style
                       window managers such as fvwm and twm.

<a name="opt-ncache_pad"></a>-ncache_pad n          In -ncache mode, pad each window with n pixels for the
                       caching rectangles.  This can be used to try to improve
                       the situation with dropshadows or other compositing
                       (e.g. MacOS X window manager), although it could make
                       things worse.  The default is 0 on Unix and 24 on
                       MacOS X.
<a name="opt-debug_ncache"></a>-debug_ncache          Turn on debugging and profiling output under -ncache.

<a name="opt-wireframe"></a>-wireframe [str]       Try to detect window moves or resizes when a mouse
<a name="opt-nowireframe"></a>-nowireframe           button is held down and show a wireframe instead of
                       the full opaque window.  This is based completely on
                       heuristics and may not always work: it depends on your
                       window manager and even how you move things around.
                       See -pointer_mode below for discussion of the "bogging
                       down" problem this tries to avoid.
                       Default: -wireframe

                       Shorter aliases:  -wf [str]  and -nowf

                       The value "str" is optional and, of course, is
                       packed with many tunable parameters for this scheme:

                       Format: shade,linewidth,percent,T+B+L+R,mod,t1+t2+t3+t4
                       Default: 0xff,2,0,32+8+8+8,all,0.15+0.30+5.0+0.125

                       If you leave nothing between commas: ",," the default
                       value is used.  If you don't specify enough commas,
                       the trailing parameters are set to their defaults.

                       "shade" indicate the "color" for the wireframe,
                       usually a greyscale: 0-255, however for 16 and 32bpp you
                       can specify an rgb.txt X color (e.g. "dodgerblue") or
                       a value > 255 is treated as RGB (e.g. red is 0xff0000).
                       "linewidth" sets the width of the wireframe in pixels.
                       "percent" indicates to not apply the wireframe scheme
                       to windows with area less than this percent of the
                       full screen.

                       "T+B+L+R" indicates four integers for how close in
                       pixels the pointer has to be from the Top, Bottom, Left,
                       or Right edges of the window to consider wireframing.
                       This is a speedup to quickly exclude a window from being
                       wireframed: set them all to zero to not try the speedup
                       (scrolling and selecting text will likely be slower).

                       "mod" specifies if a button down event in the
                       interior of the window with a modifier key (Alt, Shift,
                       etc.) down should indicate a wireframe opportunity.
                       It can be "0" or "none" to skip it, "1" or "all"
                       to apply it to any modifier, or "Shift", "Alt",
                       "Control", "Meta", "Super", or "Hyper" to only
                       apply for that type of modifier key.

                       "t1+t2+t3+t4" specify four floating point times in
                       seconds: t1 is how long to wait for the pointer to move,
                       t2 is how long to wait for the window to start moving
                       or being resized (for some window managers this can be
                       rather long), t3 is how long to keep a wireframe moving
                       before repainting the window. t4 is the minimum time
                       between sending wireframe "animations".  If a slow
                       link is detected, these values may be automatically
                       changed to something better for a slow link.

<a name="opt-nowireframelocal"></a>-nowireframelocal      By default, mouse motion and button presses of a
                       user sitting at the LOCAL display are monitored for
                       wireframing opportunities (so that the changes will be
                       sent efficiently to the VNC clients).  Use this option
                       to disable this behavior.

<a name="opt-wirecopyrect"></a>-wirecopyrect mode     Since the -wireframe mechanism evidently tracks moving
<a name="opt-nowirecopyrect"></a>-nowirecopyrect        windows accurately, a speedup can be obtained by
                       telling the VNC viewers to locally copy the translated
                       window region.  This is the VNC CopyRect encoding:
                       the framebuffer update doesn't need to send the actual
                       new image data.

                       Shorter aliases:  -wcr [mode]  and -nowcr

                       "mode" can be "never" (same as -nowirecopyrect)
                       to never try the copyrect, "top" means only do it if
                       the window was not covered by any other windows, and
                       "always" means to translate the orginally unobscured
                       region (this may look odd as the remaining pieces come
                       in, but helps on a slow link).  Default: "always"

                       Note: there can be painting errors or slow response
                       when using -scale so you may want to disable CopyRect
                       in this case "-wirecopyrect never" on the command
                       line or by remote-control.  Or you can also use the
                       "-scale xxx:nocr" scale option.

<a name="opt-debug_wireframe"></a>-debug_wireframe       Turn on debugging info printout for the wireframe
                       heuristics.  "-dwf" is an alias.  Specify multiple
                       times for more output.

<a name="opt-scrollcopyrect"></a>-scrollcopyrect mode   Like -wirecopyrect, but use heuristics to try to guess
<a name="opt-noscrollcopyrect"></a>-noscrollcopyrect      if a window has scrolled its contents (either vertically
                       or horizontally).  This requires the RECORD X extension
                       to "snoop" on X applications (currently for certain
                       XCopyArea and XConfigureWindow X protocol requests).
                       Examples: Hitting <Return> in a terminal window when the
                       cursor was at the bottom, the text scrolls up one line.
                       Hitting <Down> arrow in a web browser window, the web
                       page scrolls up a small amount.  Or scrolling with a
                       scrollbar or mouse wheel.

                       Shorter aliases:  -scr [mode]  and -noscr

                       This scheme will not always detect scrolls, but when
                       it does there is a nice speedup from using the VNC
                       CopyRect encoding (see -wirecopyrect).  The speedup
                       is both in reduced network traffic and reduced X
                       framebuffer polling/copying.  On the other hand, it may
                       induce undesired transients (e.g. a terminal cursor
                       being scrolled up when it should not be) or other
                       painting errors (window tearing, bunching-up, etc).
                       These are automatically repaired in a short period
                       of time.  If this is unacceptable disable the feature
                       with -noscrollcopyrect.

                       Screen clearing kludges:  for testing at least, there
                       are some "magic key sequences" (must be done in less
                       than 1 second) to aid repairing painting errors that
                       may be seen when using this mode:

                       3 Alt_L's   in a row: resend whole screen,
                       4 Alt_L's   in a row: reread and resend whole screen,
                       3 Super_L's in a row: mark whole screen for polling,
                       4 Super_L's in a row: reset RECORD context,
                       5 Super_L's in a row: try to push a black screen

                       note: Alt_L is the Left "Alt" key (a single key)
                       Super_L is the Left "Super" key (Windows flag).
                       Both of these are modifier keys, and so should not
                       generate characters when pressed by themselves.  Also,
                       your VNC viewer may have its own refresh hot-key
                       or button.

                       "mode" can be "never" (same as -noscrollcopyrect)
                       to never try the copyrect, "keys" means to try it
                       in response to keystrokes only, "mouse" means to
                       try it in response to mouse events only, "always"
                       means to do both. Default: "always"

                       Note: there can be painting errors or slow response
                       when using -scale so you may want to disable CopyRect
                       in this case "-scrollcopyrect never" on the command
                       line or by remote-control.  Or you can also use the
                       "-scale xxx:nocr" scale option.

<a name="opt-scr_area"></a>-scr_area n            Set the minimum area in pixels for a rectangle
                       to be considered for the -scrollcopyrect detection
                       scheme.  This is to avoid wasting the effort on small
                       rectangles that would be quickly updated the normal way.
                       E.g. suppose an app updated the position of its skinny
                       scrollbar first and then shifted the large panel
                       it controlled.  We want to be sure to skip the small
                       scrollbar and get the large panel. Default: 60000

<a name="opt-scr_skip"></a>-scr_skip list         Skip scroll detection for applications matching
                       the comma separated list of strings in "list".
                       Some applications implement their scrolling in
                       strange ways where the XCopyArea, etc, also applies
                       to invisible portions of the window: if we CopyRect
                       those areas it looks awful during the scroll and
                       there may be painting errors left after the scroll.
                       Soffice.bin is the worst known offender.

                       Use "##" to denote the start of the application class
                       (e.g. "##XTerm") and "++" to denote the start
                       of the application instance name (e.g. "++xterm").
                       The string your list is matched against is of the form
                       "^^WM_NAME##Class++Instance<same-for-any-subwindows>"
                       The "xlsclients -la" command will provide this info.

                       If a pattern is prefixed with "KEY:" it only applies
                       to Keystroke generated scrolls (e.g. Up arrow).  If it
                       is prefixed with "MOUSE:" it only applies to Mouse
                       induced scrolls (e.g. dragging on a scrollbar).
                       Default: ##Soffice.bin,##StarOffice,##OpenOffice

<a name="opt-scr_inc"></a>-scr_inc list          Opposite of -scr_skip: this list is consulted first
                       and if there is a match the window will be monitored
                       via RECORD for scrolls irrespective of -scr_skip.
                       Use -scr_skip '*' to skip anything that does not match
                       your -scr_inc.  Use -scr_inc '*' to include everything.

<a name="opt-scr_keys"></a>-scr_keys list         For keystroke scroll detection, only apply the RECORD
                       heuristics to the comma separated list of keysyms in
                       "list".  You may find the RECORD overhead for every
                       one of your keystrokes disrupts typing too much, but you
                       don't want to turn it off completely with "-scr mouse"
                       and -scr_parms does not work or is too confusing.

                       The listed keysyms can be numeric or the keysym
                       names in the <X11/keysymdef.h> header file or from the
                       xev(1) program.  Example: "-scr_keys Up,Down,Return".
                       One probably wants to have application specific lists
                       (e.g. for terminals, etc) but that is too icky to think
                       about for now...

                       If "list" begins with the "-" character the list
                       is taken as an exclude list: all keysyms except those
                       list will be considered.  The special string "builtin"
                       expands to an internal list of keysyms that are likely
                       to cause scrolls.  BTW, by default modifier keys,
                       Shift_L, Control_R, etc, are skipped since they almost
                       never induce scrolling by themselves.

<a name="opt-scr_term"></a>-scr_term list         Yet another cosmetic kludge.  Apply shell/terminal
                       heuristics to applications matching comma separated
                       list (same as for -scr_skip/-scr_inc).  For example an
                       annoying transient under scroll detection is if you
                       hit Enter in a terminal shell with full text window,
                       the solid text cursor block will be scrolled up.
                       So for a short time there are two (or more) block
                       cursors on the screen.  There are similar scenarios,
                       (e.g. an output line is duplicated).

                       These transients are induced by the approximation of
                       scroll detection (e.g. it detects the scroll, but not
                       the fact that the block cursor was cleared just before
                       the scroll).  In nearly all cases these transient errors
                       are repaired when the true X framebuffer is consulted
                       by the normal polling.  But they are distracting, so
                       what this option provides is extra "padding" near the
                       bottom of the terminal window: a few extra lines near
                       the bottom will not be scrolled, but rather updated
                       from the actual X framebuffer.  This usually reduces
                       the annoying artifacts.  Use "none" to disable.
                       Default: "term"

<a name="opt-scr_keyrepeat"></a>-scr_keyrepeat lo-hi   If a key is held down (or otherwise repeats rapidly) and
                       this induces a rapid sequence of scrolls (e.g. holding
                       down an Arrow key) the "scrollcopyrect" detection
                       and overhead may not be able to keep up.  A time per
                       single scroll estimate is performed and if that estimate
                       predicts a sustainable scrollrate of keys per second
                       between "lo" and "hi" then repeated keys will be
                       DISCARDED to maintain the scrollrate. For example your
                       key autorepeat may be 25 keys/sec, but for a large
                       window or slow link only 8 scrolls per second can be
                       sustained, then roughly 2 out of every 3 repeated keys
                       will be discarded during this period. Default: "4-20"

<a name="opt-scr_parms"></a>-scr_parms string      Set various parameters for the scrollcopyrect mode.
                       The format is similar to that for -wireframe and packed
                       with lots of parameters:

                       Format: T+B+L+R,t1+t2+t3,s1+s2+s3+s4+s5
                       Default: 0+64+32+32,0.02+0.10+0.9,0.03+0.06+0.5+0.1+5.0

                       If you leave nothing between commas: ",," the default
                       value is used.  If you don't specify enough commas,
                       the trailing parameters are set to their defaults.

                       "T+B+L+R" indicates four integers for how close in
                       pixels the pointer has to be from the Top, Bottom, Left,
                       or Right edges of the window to consider scrollcopyrect.
                       If -wireframe overlaps it takes precedence.  This is a
                       speedup to quickly exclude a window from being watched
                       for scrollcopyrect: set them all to zero to not try
                       the speedup (things like selecting text will likely
                       be slower).

                       "t1+t2+t3" specify three floating point times in
                       seconds that apply to scrollcopyrect detection with
                       *Keystroke* input: t1 is how long to wait after a key
                       is pressed for the first scroll, t2 is how long to keep
                       looking after a Keystroke scroll for more scrolls.
                       t3 is how frequently to try to update surrounding
                       scrollbars outside of the scrolling area (0.0 to
                       disable)

                       "s1+s2+s3+s4+s5" specify five floating point times
                       in seconds that apply to scrollcopyrect detection with
                       *Mouse* input: s1 is how long to wait after a mouse
                       button is pressed for the first scroll, s2 is how long
                       to keep waiting for additional scrolls after the first
                       Mouse scroll was detected.  s3 is how frequently to
                       try to update surrounding scrollbars outside of the
                       scrolling area (0.0 to disable).  s4 is how long to
                       buffer pointer motion (to try to get fewer, bigger
                       mouse scrolls). s5 is the maximum time to spend just
                       updating the scroll window without updating the rest
                       of the screen.

<a name="opt-fixscreen"></a>-fixscreen string      Periodically "repair" the screen based on settings
                       in "string".  Hopefully you won't need this option,
                       it is intended for cases when the -scrollcopyrect or
                       -wirecopyrect features leave too many painting errors,
                       but it can be used for any scenario.  This option
                       periodically performs costly operations and so
                       interactive response may be reduced when it is on.
                       You can use 3 Alt_L's (the Left "Alt" key) taps in
                       a row (as described under -scrollcopyrect) instead to
                       manually request a screen repaint when it is needed.

                       "string" is a comma separated list of one or more of
                       the following: "V=t", "C=t", "X=t", and "8=t".
                       In these "t" stands for a time in seconds (it is
                       a floating point even though one should usually use
                       values > 2 to avoid wasting resources).  V sets how
                       frequently the entire screen should be sent to viewers
                       (it is like the 3 Alt_L's).  C sets how long to wait
                       after a CopyRect to repaint the full screen.  X sets
                       how frequently to reread the full X11 framebuffer from
                       the X server and push it out to connected viewers.
                       Use of X should be rare, please report a bug if you
                       find you need it. 8= applies only for -8to24 mode: it
                       sets how often the non-default visual regions of the
                       screen (e.g. 8bpp windows) are refreshed.  Examples:
                       -fixscreen V=10 -fixscreen C=10

<a name="opt-debug_scroll"></a>-debug_scroll          Turn on debugging info printout for the scroll
                       heuristics.  "-ds" is an alias.  Specify it multiple
                       times for more output.

<a name="opt-noxrecord"></a>-noxrecord             Disable any use of the RECORD extension.  This is
                       currently used by the -scrollcopyrect scheme and to
                       monitor X server grabs.

<a name="opt-grab_buster"></a>-grab_buster           Some of the use of the RECORD extension can leave a
<a name="opt-nograb_buster"></a>-nograb_buster         tiny window for XGrabServer deadlock.  This is only if
                       the whole-server grabbing application expects mouse or
                       keyboard input before releasing the grab.  It is usually
                       a window manager that does this.  x11vnc takes care to
                       avoid the problem, but if caught x11vnc will freeze.
                       Without -grab_buster, the only solution is to go the
                       physical display and give it some input to satisfy the
                       grabbing app.  Or manually kill and restart the window
                       manager if that is feasible.  With -grab_buster, x11vnc
                       will fork a helper thread and if x11vnc appears to be
                       stuck in a grab after a period of time (20-30 sec) then
                       it will inject some user input: button clicks, Escape,
                       mouse motion, etc to try to break the grab.  If you
                       experience a lot of grab deadlock, please report a bug.

<a name="opt-debug_grabs"></a>-debug_grabs           Turn on debugging info printout with respect to
                       XGrabServer() deadlock for -scrollcopyrect mode.

<a name="opt-debug_sel"></a>-debug_sel             Turn on debugging info printout with respect to
                       PRIMARY, CLIPBOARD, and CUTBUFFER0 selections.

<a name="opt-pointer_mode"></a>-pointer_mode n        Various pointer motion update schemes. "-pm" is
                       an alias.  The problem is pointer motion can cause
                       rapid changes on the screen: consider the rapid
                       changes when you drag a large window around opaquely.
                       Neither x11vnc's screen polling and vnc compression
                       routines nor the bandwidth to the vncviewers can keep
                       up these rapid screen changes: everything will bog down
                       when dragging or scrolling.  So a scheme has to be used
                       to "eat" much of that pointer input before re-polling
                       the screen and sending out framebuffer updates. The
                       mode number "n" can be 0 to 4 and selects one of
                       the schemes desribed below.

                       Note that the -wireframe and -scrollcopyrect modes
                       complement -pointer_mode by detecting (and improving)
                       certain periods of "rapid screen change".

                       n=0: does the same as -nodragging. (all screen polling
                       is suspended if a mouse button is pressed.)

                       n=1: was the original scheme used to about Jan 2004:
                       it basically just skips -input_skip keyboard or pointer
                       events before repolling the screen.

                       n=2 is an improved scheme: by watching the current rate
                       of input events it tries to detect if it should try to
                       "eat" additional pointer events before continuing.

                       n=3 is basically a dynamic -nodragging mode: it detects
                       when the mouse motion has paused and then refreshes
                       the display.

                       n=4 attempts to measures network rates and latency,
                       the video card read rate, and how many tiles have been
                       changed on the screen.  From this, it aggressively tries
                       to push screen "frames" when it decides it has enough
                       resources to do so.  NOT FINISHED.

                       The default n is 2\. Note that modes 2, 3, 4 will skip
                       -input_skip keyboard events (but it will not count
                       pointer events).  Also note that these modes are not
                       available in -threads mode which has its own pointer
                       event handling mechanism.

                       To try out the different pointer modes to see which
                       one gives the best response for your usage, it is
                       convenient to use the remote control function, for
                       example "x11vnc -R pm:4" or the tcl/tk gui (Tuning ->
                       pointer_mode -> n).

<a name="opt-input_skip"></a>-input_skip n          For the pointer handling when non-threaded: try to
                       read n user input events before scanning display. n < 0
                       means to act as though there is always user input.
                       Default: 10

<a name="opt-allinput"></a>-allinput              Have x11vnc read and process all available client input
                       before proceeding.

<a name="opt-input_eagerly"></a>-input_eagerly         Similar to -allinput but use the handleEventsEagerly
                       mechanism built into LibVNCServer.

<a name="opt-speeds"></a>-speeds rd,bw,lat      x11vnc tries to estimate some speed parameters that
                       are used to optimize scheduling (e.g. -pointer_mode
                       4, -wireframe, -scrollcopyrect) and other things.
                       Use the -speeds option to set these manually.
                       The triple "rd,bw,lat" corresponds to video h/w
                       read rate in MB/sec, network bandwidth to clients in
                       KB/sec, and network latency to clients in milliseconds,
                       respectively.  If a value is left blank, e.g. "-speeds
                       ,100,15", then the internal scheme is used to estimate
                       the empty value(s).

                       Typical PC video cards have read rates of 5-10 MB/sec.
                       If the framebuffer is in main memory instead of video
                       h/w (e.g. SunRay, shadowfb, dummy driver, Xvfb), the
                       read rate may be much faster.  "x11perf -getimage500"
                       can be used to get a lower bound (remember to factor
                       in the bytes per pixel).  It is up to you to estimate
                       the network bandwith and latency to clients.  For the
                       latency the ping(1) command can be used.

                       For convenience there are some aliases provided,
                       e.g. "-speeds modem".  The aliases are: "modem" for
                       6,4,200; "dsl" for 6,100,50; and "lan" for 6,5000,1

<a name="opt-wmdt"></a>-wmdt string           For some features, e.g. -wireframe and -scrollcopyrect,
                       x11vnc has to work around issues for certain window
                       managers or desktops (currently kde and xfce).
                       By default it tries to guess which one, but it can
                       guess incorrectly.  Use this option to indicate which
                       wm/dt.  "string" can be "gnome", "kde", "cde",
                       "xfce", or "root" (classic X wm).  Anything else
                       is interpreted as "root".

<a name="opt-debug_pointer"></a>-debug_pointer         Print debugging output for every pointer event.
<a name="opt-debug_keyboard"></a>-debug_keyboard        Print debugging output for every keyboard event.
                       Same as -dp and -dk, respectively.  Use multiple
                       times for more output.

<a name="opt-defer"></a>-defer time            Time in ms to delay sending updates to connected clients
                       (deferUpdateTime)  Default: 20

<a name="opt-wait"></a>-wait time             Time in ms to pause between screen polls.  Used to cut
                       down on load.  Default: 20

<a name="opt-extra_fbur"></a>-extra_fbur n          Perform extra FrameBufferUpdateRequests checks to
                       try to be in better sync with the client's requests.
                       What this does is perform extra polls of the client
                       socket at critical times (before '-defer' and '-wait'
                       calls.)  The default is n=1\.  Set to a larger number to
                       insert more checks or set to n=0 to disable.  A downside
                       of these extra calls is that more mouse input may be
                       processed than desired.

<a name="opt-wait_ui"></a>-wait_ui factor        Factor by which to cut the -wait time if there
                       has been recent user input (pointer or keyboard).
                       Improves response, but increases the load whenever you
                       are moving the mouse or typing.  Default: 2.00
<a name="opt-setdefer"></a>-setdefer n            When the -wait_ui mechanism cuts down the wait time ms,
                       set the defer time to the same ms value. n=1 to enable,
                       0 to disable, and -1 to set defer to 0 (no delay).
                       Similarly, 2 and -2 indicate 'urgent_update' mode should
                       be used to push the updates even sooner.  Default: 1
<a name="opt-nowait_bog"></a>-nowait_bog            Do not detect if the screen polling is "bogging down"
                       and sleep more.  Some activities with no user input can
                       slow things down a lot: consider a large terminal window
                       with a long build running in it continuously streaming
                       text output.  By default x11vnc will try to detect this
                       (3 screen polls in a row each longer than 0.25 sec with
                       no user input), and sleep up to 1.5 secs to let things
                       "catch up".  Use this option to disable that detection.
<a name="opt-slow_fb"></a>-slow_fb time          Floating point time in seconds to delay all screen
                       polling.  For special purpose usage where a low frame
                       rate is acceptable and desirable, but you want the
                       user input processed at the normal rate so you cannot
                       use -wait.
<a name="opt-xrefresh"></a>-xrefresh time         Floating point time in seconds to indicate how often to
                       do the equivalent of xrefresh(1) to force all windows
                       (in the viewable area if -id, -sid, or -clip is used)
                       to repaint themselves.  Use this only if applications
                       misbehave by not repainting themselves properly.
                       See also -noxdamage.
<a name="opt-nap"></a>-nap                   Monitor activity and if it is low take longer naps
<a name="opt-nonap"></a>-nonap                 between screen polls to really cut down load when idle.
                       Default: take naps
<a name="opt-sb"></a>-sb time               Time in seconds after NO activity (e.g. screen blank)
                       to really throttle down the screen polls (i.e. sleep
                       for about 1.5 secs). Use 0 to disable.  Default: 60
                       Set the env. var. X11VNC_SB_FACTOR to scale it.

<a name="opt-readtimeout"></a>-readtimeout n         Set LibVNCServer rfbMaxClientWait to n seconds. On
                       slow links that take a long time to paint the first
                       screen LibVNCServer may hit the timeout and drop the
                       connection.  Default: 20 seconds.
<a name="opt-ping"></a>-ping n                Send a 1x1 framebuffer update to all clients every n
                       seconds (e.g. to try to keep a network connection alive)

<a name="opt-nofbpm"></a>-nofbpm                If the system supports the FBPM (Frame Buffer Power
<a name="opt-fbpm"></a>-fbpm                  Management) extension (i.e. some Sun systems), then
                       prevent the video h/w from going into a reduced power
                       state when VNC clients are connected.

                       FBPM capable video h/w save energy when the workstation
                       is idle by going into low power states (similar to DPMS
                       for monitors).  This interferes with x11vnc's polling
                       of the framebuffer data.

                       "-nofbpm" means prevent FBPM low power states whenever
                       VNC clients are connected, while "-fbpm" means to not
                       monitor the FBPM state at all.  See the xset(1) manpage
                       for details.  -nofbpm is basically the same as running
                       "xset fbpm force on" periodically.  Default: -fbpm

<a name="opt-nodpms"></a>-nodpms                If the system supports the DPMS (Display Power Management
<a name="opt-dpms"></a>-dpms                  Signaling) extension, then prevent the monitor from
                       going into a reduced power state when VNC clients
                       are connected.

                       DPMS reduced power monitor states are a good thing
                       and you normally want the power down to take place
                       (usually x11vnc has no problem exporting the display in
                       this state).  You probably only want to use "-nodpms"
                       to work around problems with Screen Savers kicking
                       on in DPMS low power states.  There is known problem
                       with kdesktop_lock on KDE where the screen saver keeps
                       kicking in every time user input stops for a second
                       or two.  Specifying "-nodpms" works around it.

                       "-nodpms" means prevent DPMS low power states whenever
                       VNC clients are connected, while "-dpms" means to not
                       monitor the DPMS state at all.  See the xset(1) manpage
                       for details.  -nodpms is basically the same as running
                       "xset dpms force on" periodically.  Default: -dpms

<a name="opt-forcedpms"></a>-forcedpms             If the system supports the DPMS (Display Power
                       Management Signaling) extension, then try to keep the
                       monitor in a powered off state.  This is to prevent
                       nosey people at the physical display from viewing what
                       is on the screen.  Be sure to lock the screen before
                       disconnecting.

                       This method is far from bullet proof, e.g. suppose
                       someone attaches a non-DPMS monitor, or loads the
                       machine so that there is a gap of time before x11vnc
                       restores the powered off state?  On many machines if
                       he floods it with keyboard and mouse input he can see
                       flashes of what is on the screen before the DPMS off
                       state is reestablished.  For this to work securely
                       there would need to be support in the X server to do
                       this exactly rather than approximately with DPMS.

<a name="opt-clientdpms"></a>-clientdpms            As -forcedpms but only when VNC clients are connected.

<a name="opt-noserverdpms"></a>-noserverdpms          The UltraVNC ServerInput extension is supported.
                       This allows the VNC viewer to click a button that will
                       cause the server (x11vnc) to try to disable keyboard
                       and mouse input at the physical display and put the
                       monitor in dpms powered off state.  Use this option to
                       skip powering off the monitor.

<a name="opt-noultraext"></a>-noultraext            Disable the following UltraVNC extensions: SingleWindow
                       and ServerInput.  The others managed by LibVNCServer
                       (textchat, 1/n scaling, rfbEncodingUltra) are not.

<a name="opt-chatwindow"></a>-chatwindow            Place a local UltraVNC chat window on the X11 display
                       that x11vnc is polling.  That way the person on the VNC
                       viewer-side can chat with the person at the physical
                       X11 console. (e.g. helpdesk w/o telephone)

                       For this to work the SSVNC package (version 1.0.21 or
                       later) MUST BE installed on the system where x11vnc runs
                       and the 'ssvnc' command must be available in $PATH.
                       The ssvncviewer is used as a chat window helper.
                       See http://www.karlrunge.com/x11vnc/ssvnc.html

                       This option implies '-rfbversion 3.6' so as to trick
                       UltraVNC viewers, otherwise they assume chat is not
                       available.  To specify a different rfbversion, place
                       it after the -chatwindow option on the cmdline.

                       See also the remote control 'chaton' and 'chatoff'
                       actions.  These can also be set from the tkx11vnc GUI.

<a name="opt-noxdamage"></a>-noxdamage             Do not use the X DAMAGE extension to detect framebuffer
                       changes even if it is available.  Use -xdamage if your
                       default is to have it off.

                       x11vnc's use of the DAMAGE extension: 1) significantly
                       reduces the load when the screen is not changing much,
                       and 2) detects changed areas (small ones by default)
                       more quickly.

                       Currently the DAMAGE extension is overly conservative
                       and often reports large areas (e.g. a whole terminal
                       or browser window) as damaged even though the actual
                       changed region is much smaller (sometimes just a few
                       pixels).  So heuristics were introduced to skip large
                       areas and use the damage rectangles only as "hints"
                       for the traditional scanline polling.  The following
                       tuning parameters are introduced to adjust this
                       behavior:

<a name="opt-xd_area"></a>-xd_area A             Set the largest DAMAGE rectangle area "A" (in
                       pixels: width * height) to trust as truly damaged:
                       the rectangle will be copied from the framebuffer
                       (slow) no matter what.  Set to zero to trust *all*
                       rectangles. Default: 20000
<a name="opt-xd_mem"></a>-xd_mem f              Set how long DAMAGE rectangles should be "remembered",
                       "f" is a floating point number and is in units of the
                       scanline repeat cycle time (32 iterations).  The default
                       (1.0) should give no painting problems. Increase it if
                       there are problems or decrease it to live on the edge
                       (perhaps useful on a slow machine).

<a name="opt-sigpipe"></a>-sigpipe string        Broken pipe (SIGPIPE) handling.  "string" can be
                       "ignore" or "exit".  For "ignore" LibVNCServer
                       will handle the abrupt loss of a client and continue,
                       for "exit" x11vnc will cleanup and exit at the 1st
                       broken connection.

                       This option is not really needed since LibVNCServer
                       is doing the correct thing now for quite some time.
                       However, for convenience you can use it to ignore other
                       signals, e.g. "-sigpipe ignore:HUP,INT,TERM" in case
                       that would be useful for some sort of application.
                       You can also put "exit:.." in the list to have x11vnc
                       cleanup on the listed signals. "-sig" is an alias
                       for this option if you don't like the 'pipe'. Example:
                       -sig ignore:INT,TERM,exit:USR1

<a name="opt-threads"></a>-threads               Whether or not to use the threaded LibVNCServer
<a name="opt-nothreads"></a>-nothreads             algorithm [rfbRunEventLoop] if libpthread is available.
                       In this mode new threads (one for input and one
                       for output) are created to handle each new client.
                       Default: -nothreads.

                       Thread stability is much improved in version 0.9.8.

                       Multiple clients in threaded mode should be stable
                       for the ZRLE encoding on all platforms.  The Tight and
                       Zlib encodings are currently only stable on Linux for
                       multiple clients.  Compile with -DTLS=__thread if your
                       OS and compiler and linker support it.

                       For resizes (randr, etc.) set this env. var. to the number
                       of milliseconds to sleep: X11VNC_THREADS_NEW_FB_SLEEP
                       at various places in the do_new_fb() action.  This is to
                       let various activities settle.  Default is about 500ms.

                       Multiple clients in threaded mode could yield better
                       performance for 'class-room' broadcasting usage; also in
                       -appshare broadcast mode.  See also the -reflect option.

<a name="opt-fs"></a>-fs f                  If the fraction of changed tiles in a poll is greater
                       than f, the whole screen is updated.  Default: 0.75
<a name="opt-gaps"></a>-gaps n                Heuristic to fill in gaps in rows or cols of n or
                       less tiles.  Used to improve text paging.  Default: 4
<a name="opt-grow"></a>-grow n                Heuristic to grow islands of changed tiles n or wider
                       by checking the tile near the boundary.  Default: 3
<a name="opt-fuzz"></a>-fuzz n                Tolerance in pixels to mark a tiles edges as changed.
                       Default: 2
<a name="opt-debug_tiles"></a>-debug_tiles           Print debugging output for tiles, fb updates, etc.

<a name="opt-snapfb"></a>-snapfb                Instead of polling the X display framebuffer (fb)
                       for changes, periodically copy all of X display fb
                       into main memory and examine that copy for changes.
                       (This setting also applies for non-X -rawfb modes).
                       Under some circumstances this will improve interactive
                       response, or at least make things look smoother, but in
                       others (most!) it will make the response worse.  If the
                       video h/w fb is such that reading small tiles is very
                       slow this mode could help.  To keep the "framerate"
                       up the screen size x bpp cannot be too large.  Note that
                       this mode is very wasteful of memory I/O resources
                       (it makes full screen copies even if nothing changes).
                       It may be of use in video capture-like applications,
                       webcams, or where window tearing is a problem.

<a name="opt-rawfb"></a>-rawfb string          Instead of polling X, poll the memory object specified
                       in "string".

                       For file polling, to memory map mmap(2) a file use:
                       "map:/path/to/a/file@WxHxB", with framebuffer Width,
                       Height, and Bits per pixel.  "mmap:..." is the
                       same.

                       If there is trouble with mmap, use "file:/..."
                       for slower lseek(2) based reading.

                       Use "snap:..." to imply -snapfb mode and the "file:"
                       access (this is for unseekable devices that only provide
                       the fb all at once, e.g. a video camera provides the
                       whole frame).

                       For shared memory segments string is of the form:
                       "shm:N@WxHxB" which specifies a shmid N and with
                       WxHxB as above.  See shmat(1) and ipcs(1)

                       If you do not supply a type "map" is assumed if
                       the file exists (see the next paragraphs for some
                       exceptions to this.)

                       If string is "setup:cmd", then the command "cmd"
                       is run and the first line from it is read and used
                       as "string".  This allows initializing the device,
                       determining WxHxB, etc. These are often done as root
                       so take care.

                       If the string begins with "video", see the VIDEO4LINUX
                       discussion below where the device may be queried for
                       (and possibly set) the framebuffer parameters.

                       If the string begins with "console", "/dev/fb",
                       "fb", or "vt", see the LINUX CONSOLE discussion
                       below where the framebuffer device is opened and
                       keystrokes (and possibly mouse events) are inserted
                       into the console.

                       If the string begins with "vnc", see the VNC HOST
                       discussion below where the framebuffer is taken as that
                       of another remote VNC server.

                       Optional suffixes are ":R/G/B" and "+O" to specify
                       red, green, and blue masks (in hex) and an offset into
                       the memory object.  If the masks are not provided x11vnc
                       guesses them based on the bpp (if the colors look wrong,
                       you need to provide the masks.)

                       Another optional suffix is the Bytes Per Line which in
                       some cases is not WxB/8\.  Specify it as WxHxB-BPL
                       e.g. 800x600x16-2048\.  This could be a normal width
                       1024 at 16bpp fb, but only width 800 shows up.

                       So the full format is: mode:file@WxHxB:R/G/B+O-BPL

                       Examples:
                           -rawfb shm:210337933@800x600x32:ff/ff00/ff0000
                           -rawfb map:/dev/fb0@1024x768x32
                           -rawfb map:/tmp/Xvfb_screen0@640x480x8+3232
                           -rawfb file:/tmp/my.pnm@250x200x24+37
                           -rawfb file:/dev/urandom@128x128x8
                           -rawfb snap:/dev/video0@320x240x24 -24to32
                           -rawfb video0
                           -rawfb video -pipeinput VID
                           -rawfb console
                           -rawfb vt2
                           -rawfb vnc:somehost:0

                       (see ipcs(1) and fbset(1) for the first two examples)

                       In general all user input is discarded by default (see
                       the -pipeinput option for how to use a helper program
                       to insert).  Most of the X11 (screen, keyboard, mouse)
                       options do not make sense and many will cause this
                       mode to crash, so please think twice before setting or
                       changing them in a running x11vnc.

                       If you DO NOT want x11vnc to close the X DISPLAY in
                       rawfb mode, prepend a "+" e.g. +file:/dev/fb0...
                       Keeping the display open enables the default
                       remote-control channel, which could be useful.
                       Alternatively, if you specify -noviewonly, then the
                       mouse and keyboard input are STILL sent to the X
                       display, this usage should be very rare, i.e. doing
                       something strange with /dev/fb0.

                       If the device is not "seekable" (e.g. webcam) try
                       reading it all at once in full snaps via the "snap:"
                       mode (note: this is a resource hog).  If you are using
                       file: or map: AND the device needs to be reopened for
                       *every* snapfb snapshot, set the environment variable:
                       SNAPFB_RAWFB_RESET=1 as well.

                       If you want x11vnc to dynamically transform a 24bpp
                       rawfb to 32bpp (note that this will be slower) also
                       supply the -24to32 option.  This would be useful for,
                       say, a video camera that delivers the pixel data as
                       24bpp packed RGB.  This is the default under "video"
                       mode if the bpp is 24.

                       Normally the bits per pixel, B, is 8, 16, or 32 (or
                       rarely 24), however there is also some support for
                       B < 8 (e.g. old graphics displays 4 bpp or 1 bpp).
                       In this case you certainly must supply the masks as
                       well: WxHxB:R/G/B.  The pixels will be padded out to
                       8 bpp using depth 8 truecolor.  The scheme currently
                       does not work with snap fb (ask if interested.) B=1
                       monochrome example: file:/dev/urandom@128x128x1:1/1/1
                       Some other like this are 128x128x2:3/3/3 128x128x4:7/7/7

                       For B < 8 framebuffers you can also set the env. var
                       RAWFB_CGA=1 to try a CGA mapping for B=4 (e.g. linux
                       vga16fb driver.)  Note with low bpp and/or resolution
                       VGA and VGA16 modes on the Linux console one's attempt
                       to export them via x11vnc can often be thwarted due to
                       special color palettes, pixel packings, and even video
                       painting buffering.  OTOH, often experimenting with the
                       RGB masks can yield something recognizable.

                       VIDEO4LINUX: on Linux some attempt is made to handle
                       video devices (webcams or TV tuners) automatically.
                       The idea is the WxHxB will be extracted from the
                       device itself.  So if you do not supply "@WxHxB...
                       parameters x11vnc will try to determine them.  It first
                       tries the v4l API if that support has been compiled in.
                       Otherwise it will run the v4l-info(1) external program
                       if it is available.

                       The simplest examples are "-rawfb video" and "-rawfb
                       video1" which imply the device file /dev/video and
                       /dev/video1, respectively.  You can also supply the
                       /dev if you like, e.g. "-rawfb /dev/video0"

                       Since the video capture device framebuffer usually
                       changes continuously (e.g. brightness fluctuations),
                       you may want to use the -wait, -slow_fb, or -defer
                       options to lower the "framerate" to cut down on
                       network VNC traffic.

                       A more sophisticated video device scheme allows
                       initializing the device's settings using:

                           -rawfb video:<settings>

                       The prefix could also be, as above, e.g. "video1:" to
                       specify the device file.  The v4l API must be available
                       for this to work.  Otherwise, you will need to try
                       to initialize the device with an external program,
                       e.g. xawtv, spcaview, and hope they persist when x11vnc
                       re-opens the device.

                       <settings> is a comma separated list of key=value pairs.
                       The device's brightness, color, contrast, and hue can
                       be set to percentages, e.g. br=80,co=50,cn=44,hu=60.

                       The device filename can be set too if needed (if it
                       does not start with "video"), e.g. fn=/dev/qcam.

                       The width, height and bpp of the framebuffer can be
                       set via, e.g., w=160,h=120,bpp=16.

                       Related to the bpp above, the pixel format can be set
                       via the fmt=XXX, where XXX can be one of: GREY, HI240,
                       RGB555, RGB565, RGB24, and RGB32 (with bpp 8, 8, 16, 16,
                       24, and 32 respectively).  See http://www.linuxtv.org
                       for more info (V4L api).

                       For TV/rf tuner cards one can set the tuning mode
                       via tun=XXX where XXX can be one of PAL, NTSC, SECAM,
                       or AUTO.

                       One can switch the input channel by the inp=XXX setting,
                       where XXX is the name of the input channel (Television,
                       Composite1, S-Video, etc).  Use the name that is in the
                       information about the device that is printed at startup.

                       For input channels with tuners (e.g. Television) one
                       can change which station is selected by the sta=XXX
                       setting.  XXX is the station number.  Currently only
                       the ntsc-cable-us (US cable) channels are built into
                       x11vnc.  See the -freqtab option below to supply one
                       from xawtv. If XXX is greater than 500, then it is
                       interpreted as a raw frequency in KHz.

                       Example:

                       -rawfb video:br=80,w=320,h=240,fmt=RGB32,tun=NTSC,sta=47

                       one might need to add inp=Television too for the input
                       channel to be TV if the card doesn't come up by default
                       in that one.

                       Note that not all video capture devices will support
                       all of the above settings.

                       See the -pipeinput VID option below for a way to control
                       the settings through the VNC Viewer via keystrokes.
                       As a shortcut, if the string begins "Video.." instead
                       of "video.." then -pipeinput VID is implied.

                       As above, if you specify a "@WxHxB..." after the
                       <settings> string they are used verbatim: the device
                       is not queried for the current values.  Otherwise the
                       device will be queried.

                       LINUX CONSOLE:  The following describes some ways to
                       view and possibly interact with the Linux text/graphics
                       console (i.e. not X11 XFree86/Xorg)

                       Note: If the LibVNCServer LinuxVNC program is on your
                       system you may want to use that instead of the following
                       method because it will be faster and more accurate
                       for the Linux text console and includes mouse support.
                       There is, however, the basic LinuxVNC functionality in
                       x11vnc if you replace "console" with "vt" in the
                       examples below.

                       If the rawfb string begins with "console" the
                       framebuffer device /dev/fb0 is opened and /dev/tty0 is
                       opened too.  The latter is used to inject keystrokes
                       (not all are supported, but the basic ones are).
                       You will need to be root to inject keystrokes, but
                       not necessarily to open /dev/fb0\.  /dev/tty0 refers to
                       the active VT, to indicate one explicitly, use, e.g.,
                       "console2" for /dev/tty2, etc. by indicating the
                       specific VT number.

                       For the Linux framebuffer device, /dev/fb0, (fb1,
                       etc) to be enabled the appropriate kernel drivers must
                       be loaded.  E.g. vesafb or vga16fb and also by setting
                       the boot parameter vga=0x301 (or 0x314, 0x317, etc.)
                       (The vga=... method is the preferred way; set your
                       machines up that way.)  Otherwise there will be a
                       'No such device' error.  You can also load a Linux
                       framebuffer driver specific to your make of video card
                       for more functionality.  Once the machine is booted one
                       can often 'modprobe' the fb driver as root to obtain
                       a framebuffer device.

                       If you cannot get /dev/fb0 working on Linux, try
                       using the LinuxVNC emulation mode by "-rawfb vtN"
                       where N = 1, ... 6 is the Linux Virtual Terminal (aka
                       virtual console) you wish to view, e.g. "-rawfb vt2".
                       Unlike /dev/fb mode, it need not be the active Virtual
                       Terminal.  Note that this mode can only show text and
                       not graphics.  x11vnc polls the text in /dev/vcsaN

                       Set the env. var. RAWFB_VCSA_BW=1 to disable colors in
                       the "vtN" mode (i.e. black and white only.)  If you
                       do not prefer the default 16bpp set RAWFB_VCSA_BPP to
                       8 or 32\.  If you need to tweak the rawfb parameters by
                       using the 'console_guess' string printed at startup,
                       be sure to indicate the snap: method.

                       uinput: If the Linux version appears to be 2.6
                       or later and the "uinput" module appears to be
                       present (modprobe uinput), then the uinput method
                       will be used instead of /dev/ttyN.  uinput allows
                       insertion of BOTH keystrokes and mouse input and so it
                       preferred when accessing graphical (e.g. QT-embedded)
                       linux console apps.  It also provides more accurate
                       keystroke insertion.  See -pipeinput UINPUT below for
                       more information on this mode; you will have to use
                       -pipeinput if you want to tweak any UINPUT parameters.
                       You may also want to also use the -nodragging and
                       -cursor none options.  Use "console0", etc  or
                       -pipeinput CONSOLE to force the /dev/ttyN method.

                       Note you can change the Linux VT remotely using the
                       chvt(1) command to make the one you want be the active
                       one (e.g. 'chvt 3').  Sometimes switching out and back
                       corrects the framebuffer's graphics state.  For the
                       "-rawfb vtN" mode there is no need to switch the VT's.

                       To skip input injecting entirely use "consolex"
                       or "vtx".

                       The string "/dev/fb0" (1, etc.) can be used instead
                       of "console".  This can be used to specify a different
                       framebuffer device, e.g. /dev/fb1\.  As a shortcut the
                       "/dev/" can be dropped.  If the name is something
                       nonstandard, use "console:/dev/foofb"

                       If you do not want x11vnc to guess the framebuffer's
                       WxHxB and masks automatically (sometimes the kernel
                       gives incorrect information), specify them with a @WxHxB
                       (and optional :R/G/B masks) at the end of the string.

                       Examples:
                           -rawfb console
                           -rawfb /dev/fb0           (same)
                           -rawfb console3           (force /dev/tty3)
                           -rawfb consolex           (no keystrokes or mouse)
                           -rawfb console:/dev/nonstd
                           -rawfb console -pipeinput UINPUT:accel=4.0
                           -rawfb vt3                (/dev/tty3 w/o /dev/fb0)

                       VNC HOST: if the -rawfb string is of the form
                       "vnc:host:N" then the VNC display "N" on the remote
                       VNC server "host" is connected to (i.e. x11vnc acts as
                       a VNC client itself) and that framebuffer is exported.
                       This is the same as the option "-reflect host:N".

                       This mode is really only of use if you are trying
                       to improve performance in the case of many (e.g. >10)
                       simultaneous VNC viewers, and you try a divide
                       and conquer scheme to reduce bandwidth and improve
                       responsiveness.  However, another user found this mode
                       useful to export a demo display through a slow link:
                       then multiple demo viewers connected to the reflecting
                       x11vnc on the fast side of the link, and so avoided
                       all of the demo viewers going through the slow link.
                       Other users have found this mode useful to be able
                       to take advantage of some of x11vnc's many features
                       that other VNC servers do not have, for example SSL
                       encryption, single port http and https, unix usernames
                       and passwords, and -allow, -zeroconf, -clip, and -scale
                       options and others.

                       For the classroom broadcast example, if there will be
                       64 simultaneous VNC viewers this can lead to a lot of
                       redundant VNC traffic to and from the server host:N,
                       extra CPU usage, and all viewers response can be reduced
                       by having to wait for writes to the slowest client to
                       finish.  However, if you set up 8 reflectors/repeaters
                       started with option -rawfb vnc:host:N, then there are
                       only 8 connections to host:N.  Each repeater then
                       handles 8 vnc viewer connections thereby spreading
                       the load around.  In classroom broadcast usage, try
                       to put the repeaters on different switches.  This mode
                       is the same as -reflect host:N.  Replace "host:N" by
                       "listen" or "listen:port" for a reverse connection.
                       Use "listennofork:port" to use the LibVNCServer non
                       forking client listen interface (if your LibVNCServer
                       has it), same as setting X11VNC_REFLECT_NO_FORK=1.

                       Overall performance will not be as good as a single
                       direct connection because, among other things,
                       there is an additional level of framebuffer polling
                       and pointer motion can still induce many changes per
                       second that must be propagated.  Tip: if the remote VNC
                       is x11vnc doing wireframing, or an X display that does
                       wireframing that gives much better response than opaque
                       window dragging.  Consider the -nodragging option if
                       the problem is severe.

                       The env. var. X11VNC_REFLECT_PASSWORD can be set to
                       the password needed to log into the vnc host server, or
                       to "file:path_to_file" to indicate a file containing
                       the password as its first line.

                       To set the pixel format that x11vnc requests as a VNC
                       CLIENT set the env. vars: X11VNC_REFLECT_bitsPerSample
                       X11VNC_REFLECT_samplesPerPixel, and
                       X11VNC_REFLECT_bytesPerPixel; the defaults are 8, 3, 4.
                       2, 3, 1 would give a low color mode.  See the function
                       rfbGetClient() in libvncclient for more info.

                       The VNC HOST mode implies -shared.  Use -noshared as
                       a subsequent cmdline option to disable sharing.

<a name="opt-freqtab"></a>-freqtab file          For use with "-rawfb video" for TV tuner devices to
                       specify station frequencies.  Instead of using the built
                       in ntsc-cable-us mapping of station number to frequency,
                       use the data in file.  For stations that are not
                       numeric, e.g. SE20, they are placed above the highest
                       numbered station in the order they are found.  Example:
                       "-freqtab /usr/X11R6/share/xawtv/europe-west.list"
                       You can make your own freqtab by copying the xawtv
                       format.

<a name="opt-pipeinput"></a>-pipeinput cmd         This option lets you supply an external command in
                       "cmd" that x11vnc will pipe all of the user input
                       events to in a simple format.  In -pipeinput mode by
                       default x11vnc will not process any of the user input
                       events.  If you prefix "cmd" with "tee:" it will
                       both send them to the pipe command and process them.
                       For a description of the format run "-pipeinput
                       tee:/bin/cat".  Another prefix is "reopen" which
                       means to reopen pipe if it exits.  Separate multiple
                       prefixes with commas.

                       In combination with -rawfb one might be able to
                       do amusing things (e.g. control non-X devices).
                       To facilitate this, if -rawfb is in effect then the
                       value is stored in X11VNC_RAWFB_STR for the pipe command
                       to use if it wants. Do 'env | grep X11VNC' for more.

                       Built-in pipeinput modes (no external program required):

                       If cmd is "VID" and you are using the -rawfb for a
                       video capture device, then an internal list of keyboard
                       mappings is used to set parameters of the video.
                       The mappings are:

                         "B" and "b" adjust the brightness up and down.
                         "H" and "h" adjust the hue.
                         "C" and "c" adjust the colour.
                         "N" and "n" adjust the contrast.
                         "S" and "s" adjust the size of the capture screen.
                         "I" and "i" cycle through input channels.
                         Up and Down arrows adjust the station (if a tuner)
                         F1, F2, ..., F6 will switch the video capture pixel
                         format to HI240, RGB565, RGB24, RGB32, RGB555, and
                         GREY respectively.  See -rawfb video for details.

                       If cmd is "CONSOLE" or "CONSOLEn" where n
                       is a Linux console number, then the linux console
                       keystroke insertion to /dev/ttyN (see -rawfb console)
                       is performed.

                       If cmd begins with "UINPUT" then the Linux uinput
                       module is used to insert both keystroke and mouse events
                       to the Linux console (see -rawfb above).  This usually
                       is the /dev/input/uinput device file (you may need to
                       create it with "mknod /dev/input/uinput c 10 223"
                       and insert the module with "modprobe uinput".

                       The UINPUT mode currently only does US keyboards (a
                       scan code option may be added), and not all keysyms
                       are supported.  But it is probably more accurate than
                       the "CONSOLE" method.

                       You may want to use the options -cursor none and
                       -nodragging in this mode.

                       Additional tuning options may be supplied via:
                       UINPUT:opt1,opt2,... (a comma separated list). If an
                       option begins with "/" it is taken as the uinput
                       device file.

                       Which uinput is injected can be controlled by an option
                       string made of the characters "K", "M", and "B"
                       (see the -input option), e.g. "KM" allows keystroke
                       and motion but not button clicks.

                       A UINPUT option of the form: accel=f, or accel=fx+fy
                       sets the mouse motion "acceleration".  This is used
                       to correct raw mouse relative motion into how much the
                       application cursor moves (x11vnc has no control over,
                       or knowledge of how the windowing application interprets
                       the raw mouse motions).  Typically the acceleration
                       for an X display is 2 (see xset "m" option).  "f"
                       is a floating point number, e.g. 3.0\.  Use "fx+fy"
                       if you need to supply different corrections for x and y.

                       Note: the default acceleration is 2.0 since it seems
                       both X and qt-embedded often (but not always) use
                       this value.

                       Even with a correct accel setting the mouse position
                       will get out of sync (probably due to a mouse
                       "threshold" setting where the acceleration doe not
                       apply, set xset(1)).  The option reset=N sets the
                       number of ms (default 150) after which the cursor is
                       attempted to be reset (by forcing the mouse to (0,
                       0) via small increments and then back out to (x, y)
                       in 1 jump), This correction seems to be needed but can
                       cause jerkiness or unexpected behavior with menus, etc.
                       Use reset=0 to disable.

                       If you set the env. var X11VNC_UINPUT_THRESHOLDS then
                       the thresh=n mode will be enabled.  It is currently
                       not working well.  If |dx| <= thresh and |dy| < thresh
                       no acceleration is applied.  Use "thresh=+n" |dx| +
                       |dy| < thresh to be used instead (X11?)

                       Example:
                           -pipeinput UINPUT:accel=4.0 -cursor none

                       If the uinput device has an absolute pointer (as opposed
                       to a normal mouse that is a relative pointer) you can
                       specify the option "abs".  Note that a touchpad
                       on a laptop is an absolute device to some degree.
                       This (usually) avoids all the problems with mouse
                       acceleration.  If x11vnc has trouble deducing the
                       size of the device, use "abs=WxH".  Furthermore,
                       if the device is a touchscreen (assumed to have an
                       absolute pointer) use "touch" or "touch=WxH".
                       For touchscreens, when a mouse button is pressed,
                       a pressure increase is injected, and when the button
                       is released a pressure of zero is injected.

                       If touch has been set, use "touch_always=1" to
                       indicate whenever the mouse moves with no button
                       pressed, a touch event of zero pressure should be
                       sent anyway.  Also use "btn_touch=1" to indicate a
                       BTN_TOUCH keystroke press or release should be sent
                       instead of a pressure change.  Set "dragskip=n" to
                       skip n dragged mouse touches (with pressure applied)
                       before injecting one.  To indicate the pressure that
                       should be sent when there is a button click for a
                       touchscreen device, specify pressure=n, e.g. n=5\. The
                       default is n=1.

                       If a touch screen is being used ("touch" above)
                       and it is having its input processed by tslib, you can
                       specify the tslib calibration file via tslib_cal=<file>.
                       For example, tslib_cal=/etc/pointercal.  To get accurate
                       or even usable positioning this is required when tslib
                       is in use.

                       The Linux uinput mechanism can be bypassed and one can
                       write input events DIRECTLY to the devices instead.
                       To do this, specify one or more of the following
                       for the input classes: direct_rel=<device>
                       direct_abs=<device> direct_btn=<device> or
                       direct_key=<device>.  The <device> file is usually
                       something like /dev/input/event1 but you can specify
                       any device file or pipe.  You must specify each one
                       of the above classes even if they correspond to the
                       same device file (rel/abs and btn are often the same.)
                       Look at the file /proc/bus/input/devices to get an idea
                       what is available and the device filenames.  Note:
                       The /dev/input/mouse* devices do not seem to work,
                       use the corresponding /dev/input/event* file instead.
                       Any input class not directly specified as above will be
                       handled via the uinput mechanism.  To disable creating a
                       uinput device (and thereby discarding unhandled input),
                       specify "nouinput".

                       Examples:

                         -pipeinput UINPUT:direct_abs=/dev/input/event1

                       this was used on a qtmoko Neo freerunner (armel):

                         -pipeinput UINPUT:touch,tslib_cal=/etc/pointercal,
                          direct_abs=/dev/input/event1,nouinput,dragskip=4

                       (where the long line has been split into two.)

                       You can set the env. var X11VNC_UINPUT_DEBUG=1 or higher
                       to get debugging output for UINPUT mode.

<a name="opt-macnodim"></a>-macnodim              For the native MacOSX server, disable dimming. 
<a name="opt-macnosleep"></a>-macnosleep            For the native MacOSX server, disable display sleep.
<a name="opt-macnosaver"></a>-macnosaver            For the native MacOSX server, disable screensaver.
<a name="opt-macnowait"></a>-macnowait             For the native MacOSX server, do not wait for the
                       user to switch back to his display.
<a name="opt-macwheel"></a>-macwheel n            For the native MacOSX server, set the mouse wheel
                       speed to n (default 5).
<a name="opt-macnoswap"></a>-macnoswap             For the native MacOSX server, do not swap mouse
                       buttons 2 and 3.
<a name="opt-macnoresize"></a>-macnoresize           For the native MacOSX server, do not resize or reset
                       the framebuffer even if it is detected that the screen
                       resolution or depth has changed.
<a name="opt-maciconanim"></a>-maciconanim n         For the native MacOSX server, set n to the number
                       of milliseconds that the window iconify/deiconify
                       animation takes.  In -ncache mode this value will be
                       used to skip the animation if possible. (default 400)
<a name="opt-macmenu"></a>-macmenu               For the native MacOSX server, in -ncache client-side
                       caching mode, try to cache pull down menus (not perfect
                       because they have animated fades, etc.)
<a name="opt-macuskbd"></a>-macuskbd              For the native MacOSX server, use the original
                       keystroke insertion code based on a US keyboard.
<a name="opt-macnocglion"></a>-macnocglion           For the native MacOSX server, do not use CG interfaces
                       added for MacOSX Lion for screen capture.
<a name="opt-macnoopengl"></a>-macnoopengl           For the native MacOSX server, do not use OpenGL for
                       screen capture.
<a name="opt-macnorawfb"></a>-macnorawfb            For the native MacOSX server, disable the raw memory
                       address screen capture method.
<a name="opt-macdisplay"></a>-macdisplay n          For the native MacOSX server, use display 'n' as the
                       screen to export.  A macosx display is a distinct
                       monitor or builtin screen.  The main display is always
                       n=0 and is the default screen to export.  For an extra
                       attached monitor use n=1, etc.  A list of all Available
                       Displays is printed out at startup so that you can find
                       the n you want.  Notes: Currently there seem to be
                       refresh problems with anything but the main display.
                       Not all of the pointer behavior is correct in the
                       non-main displays.  Usually only the main display has
                       the menu bar (so you may need to run a more than one
                       x11vnc for complete control of an application.)

                       MORE MACOSX NOTES: There are some deprecated MacOSX
                       interfaces to inject keyboard and mouse events and
                       the raw memory access method is deprecated as well
                       (however, OpenGL will be preferred if available
                       because it is faster.)  One can force not using any
                       deprecated interfaces at compile time by setting
                       -DX11VNC_MACOSX_NO_DEPRECATED=1 in CPPFLAGS.  Or to
                       turn them off one by one:
                       -DX11VNC_MACOSX_NO_DEPRECATED_LOCALEVENTS=1,
                       -DX11VNC_MACOSX_NO_DEPRECATED_POSTEVENTS=1 or
                       -DX11VNC_MACOSX_NO_DEPRECATED_FRAMEBUFFER=1
                       At run time, for testing and workarounds, one can
                       disable them by using:
                       -env X11VNC_MACOSX_NO_DEPRECATED=1
                       -env X11VNC_MACOSX_NO_DEPRECATED_LOCALEVENTS=1
                       -env X11VNC_MACOSX_NO_DEPRECATED_POSTEVENTS=1 or
                       -env X11VNC_MACOSX_NO_DEPRECATED_FRAMEBUFFER=1
                       Note: When doing either of these for the mouse input
                       not everything works currently, e.g. double clicks and
                       wireframing.  Also, screen resolution and pixel depth
                       changes will not be automatically detected unless the
                       deprecated framebuffer interfaces are allowed.

                       Conversely, if you are compiling on an
                       older machine that does not have some of
                       the newer interfaces, you may need to specify
                       -DX11VNC_MACOSX_NO_CGEVENTCREATESCROLLWHEELEVENT
                       -DX11VNC_MACOSX_NO_CGEVENTCREATEMOUSEEVENT or
                       -DX11VNC_MACOSX_NO_CGEVENTCREATEKEYBOARDEVENT.  Use
                       -DX11VNC_MACOSX_USE_GETMAINDEVICE to regain the very
                       old QuickDraw GetMainDevice() interface (rare...)
                       End of MACOSX NOTES.

<a name="opt-gui"></a>-gui [gui-opts]        Start up a simple tcl/tk gui based on the remote
                       control options -remote/-query described below.
                       Requires the "wish" program to be installed on the
                       machine.  "gui-opts" is not required: the default
                       is to start up both the full gui and x11vnc with the
                       gui showing up on the X display in the environment
                       variable DISPLAY.

                       "gui-opts" can be a comma separated list of items.
                       Currently there are these types of items: 1) a gui
                       mode, a 2) gui "simplicity", 3) the X display the
                       gui should display on, 4) a "tray" or "icon" mode,
                       and 5) a gui geometry.

                       1) The gui mode can be "start", "conn", or "wait"
                       "start" is the default mode above and is not required.
                       "conn" means do not automatically start up x11vnc,
                       but instead just try to connect to an existing x11vnc
                       process.  "wait" means just start the gui and nothing
                       else (you will later instruct the gui to start x11vnc
                       or connect to an existing one.)

                       2) The gui simplicity is off by default (a power-user
                       gui with all options is presented) To start with
                       something less daunting supply the string "simple"
                       ("ez" is an alias for this).  Once the gui is
                       started you can toggle between the two with "Misc ->
                       simple_gui".

                       3) Note the possible confusion regarding the potentially
                       two different X displays: x11vnc polls one, but you
                       may want the gui to appear on another.  For example, if
                       you ssh in and x11vnc is not running yet you may want
                       the gui to come back to you via your ssh redirected X
                       display (e.g. localhost:10).

                       If you do not specify a gui X display in "gui-opts"
                       then the DISPLAY environment variable and -display
                       option are tried (in that order).  Regarding the x11vnc
                       X display the gui will try to communication with, it
                       first tries -display and then DISPLAY.  For example,
                       "x11vnc -display :0 -gui otherhost:0", will remote
                       control an x11vnc polling :0 and display the gui on
                       otherhost:0 The "tray/icon" mode below reverses this
                       preference, preferring to display on the x11vnc display.

                       4) When "tray" or "icon" is specified, the gui
                       presents itself as a small icon with behavior typical
                       of a "system tray" or "dock applet".  The color
                       of the icon indicates status (connected clients) and
                       there is also a balloon status.  Clicking on the icon
                       gives a menu from which properties, etc, can be set and
                       the full gui is available under "Advanced".  To be
                       fully functional, the gui mode should be "start"
                       (the default).

                       Note that tray or icon mode will imply the -forever
                       x11vnc option (if the x11vnc server is started along
                       with the gui) unless -connect or -connect_or_exit has
                       been specified.  So x11vnc (and the tray/icon gui)
                       will wait for more connections after the first client
                       disconnects.  If you want only one viewer connection
                       include the -once option.

                       For "icon" the gui just a small standalone window.
                       For "tray" it will attempt to embed itself in the
                       "system tray" if possible. If "=setpass" is appended then
                       at startup the X11 user will be prompted to set the
                       VNC session password.  If =<hexnumber> is appended
                       that icon will attempt to embed itself in the window
                       given by hexnumber.  Use =noadvanced to disable the
                       full gui. (To supply more than one, use "+" sign).
                       E.g. -gui tray=setpass and -gui icon=0x3600028

                       Other modes: "full", the default and need not be
                       specified.  "-gui none", do not show a gui, useful
                       to override a ~/.x11vncrc setting, etc.

                       5) When "geom=+X+Y" is specified, that geometry
                       is passed to the gui toplevel.  This is the icon in
                       icon/tray mode, or the full gui otherwise.  You can
                       also specify width and height, i.e. WxH+X+Y, but it
                       is not recommended.  In "tray" mode the geometry is
                       ignored unless the system tray manager does not seem
                       to be running.  One could imagine using something like
                       "-gui tray,geom=+4000+4000" with a display manager
                       to keep the gui invisible until someone logs in...

                       More icon tricks, "icon=minimal" gives an icon just
                       with the VNC display number.  You can also set the font
                       with "iconfont=...".  The following could be useful:
                       "-gui icon=minimal,iconfont=5x8,geom=24x10+0-0"

                       General examples of the -gui option: "x11vnc -gui",
                       "x11vnc -gui ez" "x11vnc -gui localhost:10",
                       "x11vnc -gui conn,host:0", "x11vnc -gui tray,ez"
                       "x11vnc -gui tray=setpass"

                       If you do not intend to start x11vnc from the gui
                       (i.e. just remote control an existing one), then the
                       gui process can run on a different machine from the
                       x11vnc server as long as X permissions, etc. permit
                       communication between the two.

                       FONTS: On some systems the tk fonts can be too small,
                       jagged, or otherwise unreadable.  There are 4 env vars
                       you can set to be the tk font you prefer:

                       X11VNC_FONT_BOLD   main font for menus and buttons.
                       X11VNC_FONT_FIXED  font for fixed width text.

                       X11VNC_FONT_BOLD_SMALL  tray icon font.
                       X11VNC_FONT_REG_SMALL   tray icon menu font.

                       The last two only apply for the tray icon mode.

                       Here are some examples:

                       -env X11VNC_FONT_BOLD='Helvetica -16 bold'
                       -env X11VNC_FONT_FIXED='Courier -14'
                       -env X11VNC_FONT_REG_SMALL='Helvetica -12'

                       You can put the lines like the above (without the
                       quotes) in your ~/.x11vncrc file to avoid having to
                       specify them on the x11vnc command line.

                       Sometimes there are problems when the gui asks x11vnc
                       to use the identd (port 113) service to try to get the
                       names of attached users. To disable trying to connect
                       to the viewer machines to identify the user's names,
                       set -env X11VNC_NO_IDENT_USERNAME=1

<a name="opt-remote"></a>-remote command        Remotely control some aspects of an already running
                       x11vnc server.  "-R" and "-r" are aliases for
                       "-remote".  After the remote control command is
                       sent to the running server the 'x11vnc -remote ...'
                       x11vnc command exits.  You can often use the -query
                       command (see below) to see if the x11vnc server
                       processed your -remote command.

                       The default communication channel is that of X
                       properties (specifically X11VNC_REMOTE), and so this
                       command must be run with correct settings for DISPLAY
                       and possibly XAUTHORITY to connect to the X server
                       and set the property.  Alternatively, use the -display
                       and -auth options to set them to the correct values.
                       The running server cannot use the -novncconnect option
                       because that disables the communication channel.
                       See below for alternate channels.

                       For example: 'x11vnc -remote stop' (which is the same as
                       'x11vnc -R stop') will close down the x11vnc server.
                       'x11vnc -R shared' will enable shared connections, and
                       'x11vnc -R scale:3/4' will rescale the desktop.

                       To use a different name for the X11 property (e.g. to
                       have separate communication channels for multiple
                       x11vnc's on the same display) set the X11VNC_REMOTE
                       environment variable to the string you want, for
                       example: -env X11VNC_REMOTE=X11VNC_REMOTE_12345
                       Both sides of the channel must use the same unique name.

                       To run a bunch of commands in a sequence use something
                       like: x11vnc -R 'script:firstcmd;secondcmd;...'

                       Use x11vnc -R script:file=/path/to/file to read commands
                       from a file (can be multi-line and use the comment '#'
                       character in the normal way.  The ';' separator must
                       still be used to separate each command.)

                       To not try to contact another x11vnc process and instead
                       just run the command (or query) directly, prefix the
                       command with the string "DIRECT:"

                       The following -remote/-R commands are supported:

                       stop            terminate the server, same as "quit"
                                       "exit" or "shutdown".
                       ping            see if the x11vnc server responds.
                                       return is: ans=ping:<display>
                       ping:mystring   as above, but use your own unique string.
                                       return is: ans=ping:mystring:<xdisplay>
                       blacken         try to push a black fb update to all
                                       clients (due to timings a client
                                       could miss it). Same as "zero", also
                                       "zero:x1,y1,x2,y2" for a rectangle.
                       refresh         send the entire fb to all clients.
                       reset           recreate the fb, polling memory, etc.
                       id:windowid     set -id window to "windowid". empty
                                       or "root" to go back to root window
                       sid:windowid    set -sid window to "windowid"
                       id_cmd:cmd      cmds: raise, lower, map, unmap, iconify,
                                       move:dXdY, resize:dWdH, geom:WxH+X+Y. dX
                                       dY, dW, and dH must have a leading "+"
                                       or "-" e.g.: move:-30+10 resize:+20+35
                                       also: wm_delete, wm_name:string and
                                       icon_name:string. Also id_cmd:win=N:cmd
                       waitmapped      wait until subwin is mapped.
                       nowaitmapped    do not wait until subwin is mapped.
                       clip:WxH+X+Y    set -clip mode to "WxH+X+Y"
                       flashcmap       enable  -flashcmap mode.
                       noflashcmap     disable -flashcmap mode.
                       shiftcmap:n     set -shiftcmap to n.
                       notruecolor     enable  -notruecolor mode.
                       truecolor       disable -notruecolor mode.
                       overlay         enable  -overlay mode (if applicable).
                       nooverlay       disable -overlay mode.
                       overlay_cursor  in -overlay mode, enable cursor drawing.
                       overlay_nocursor disable cursor drawing. same as
                                        nooverlay_cursor.
                       8to24           enable  -8to24 mode (if applicable).
                       no8to24         disable -8to24 mode.
                       8to24_opts:str  set the -8to24 opts to "str".
                       24to32          enable  -24to32 mode (if applicable).
                       no24to32        disable -24to32 mode.
                       visual:vis      set -visual to "vis"
                       scale:frac      set -scale to "frac"
                       scale_cursor:f  set -scale_cursor to "f"
                       viewonly        enable  -viewonly mode.
                       noviewonly      disable -viewonly mode.
                       shared          enable  -shared mode.
                       noshared        disable -shared mode.
                       forever         enable  -forever mode.
                       noforever       disable -forever mode.
                       timeout:n       reset -timeout to n, if there are
                                       currently no clients, exit unless one
                                       connects in the next n secs.
                       tightfilexfer   enable  filetransfer for NEW clients.
                       notightfilexfer disable filetransfer for NEW clients.
                       ultrafilexfer   enable  filetransfer for clients.
                       noultrafilexfer disable filetransfer for clients.
                       rfbversion:n.m  set -rfbversion for new clients.
                       http            enable  http client connections.
                       nohttp          disable http client connections.
                       deny            deny any new connections, same as "lock"
                       nodeny          allow new connections, same as "unlock"
                       avahi           enable  avahi service advertising.
                       noavahi         disable avahi service advertising.
                       mdns            enable  avahi service advertising.
                       nomdns          disable avahi service advertising.
                       zeroconf        enable  avahi service advertising.
                       nozeroconf      disable avahi service advertising.
                       connect:host    do reverse connection to host, "host"
                                       may be a comma separated list of hosts
                                       or host:ports.  See -connect.  Passwords
                                       required as with fwd connections.
                                       See X11VNC_REVERSE_CONNECTION_NO_AUTH=1
                       disconnect:host disconnect any clients from "host"
                                       same as "close:host".  Use host
                                       "all" to close all current clients.
                                       If you know the client internal hex ID,
                                       e.g. 0x3 (returned by "-query clients"
                                       and RFB_CLIENT_ID) you can use that too.
                       proxy:host:port set reverse connection proxy (empty to
                                       disable).
                       allowonce:host  For the next connection only, allow
                                       connection from "host". In -ssl mode
                                       two connections are allowed (i.e. Fetch
                                       Cert) unless X11VNC_NO_SSL_ALLOW_TWICE=1
                       allow:hostlist  set -allow list to (comma separated)
                                       "hostlist". See -allow and -localhost.
                                       Do not use with -allow /path/to/file
                                       Use "+host" to add a single host, and
                                       use "-host" to delete a single host
                       localhost       enable  -localhost mode
                       nolocalhost     disable -localhost mode
                       listen:str      set -listen to str, empty to disable.
                       noipv6          enable  -noipv6 mode.
                       ipv6            disable -noipv6 mode.
                       noipv4          enable  -noipv4 mode.
                       ipv4            disable -noipv4 mode.
                       6               enable  -6 IPv6 listening mode.
                       no6             disable -6 IPv6 listening mode.
                       lookup          disable -nolookup mode.
                       nolookup        enable  -nolookup mode.
                       lookup          disable -nolookup mode.
                       input:str       set -input to "str", empty to disable.
                       grabkbd         enable  -grabkbd mode.
                       nograbkbd       disable -grabkbd mode.
                       grabptr         enable  -grabptr mode.
                       nograbptr       disable -grabptr mode.
                       grabalways      enable  -grabalways mode.
                       nograbalways    disable -grabalways mode.
                       grablocal:n     set -grablocal to n.
                       client_input:str set the K, M, B -input on a per-client
                                       basis.  select which client as for
                                       disconnect, e.g. client_input:host:MB
                                       or client_input:0x2:K
                       accept:cmd      set -accept "cmd" (empty to disable).
                       afteraccept:cmd set -afteraccept (empty to disable).
                       gone:cmd        set -gone "cmd" (empty to disable).
                       noshm           enable  -noshm mode.
                       shm             disable -noshm mode (i.e. use shm).
                       flipbyteorder   enable -flipbyteorder mode, you may need
                                       to set noshm for this to do something.
                       noflipbyteorder disable -flipbyteorder mode.
                       onetile         enable  -onetile mode. (you may need to
                                       set shm for this to do something)
                       noonetile       disable -onetile mode.
                       solid           enable  -solid mode
                       nosolid         disable -solid mode.
                       solid_color:color set -solid color (and apply it).
                       blackout:str    set -blackout "str" (empty to disable).
                                       See -blackout for the form of "str"
                                       (basically: WxH+X+Y,...)
                                       Use "+WxH+X+Y" to append a single
                                       rectangle use "-WxH+X+Y" to delete one
                       xinerama        enable  -xinerama mode. (if applicable)
                       noxinerama      disable -xinerama mode.
                       xtrap           enable  -xtrap input mode(if applicable)
                       noxtrap         disable -xtrap input mode.
                       xrandr          enable  -xrandr mode. (if applicable)
                       noxrandr        disable -xrandr mode.
                       xrandr_mode:mode set the -xrandr mode to "mode".
                       rotate:mode     set the -rotate mode to "mode".
                       padgeom:WxH     set -padgeom to WxH (empty to disable)
                                       If WxH is "force" or "do" the padded
                                       geometry fb is immediately applied.
                       quiet           enable  -quiet mode.
                       noquiet         disable -quiet mode.
                       modtweak        enable  -modtweak mode.
                       nomodtweak      enable  -nomodtweak mode.
                       xkb             enable  -xkb modtweak mode.
                       noxkb           disable -xkb modtweak mode.
                       capslock        enable  -capslock mode.
                       nocapslock      disable -capslock mode.
                       skip_lockkeys   enable  -skip_lockkeys mode.
                       noskip_lockkeys disable -skip_lockkeys mode.
                       skip_keycodes:str enable -xkb -skip_keycodes "str".
                       sloppy_keys     enable  -sloppy_keys mode.
                       nosloppy_keys   disable -sloppy_keys mode.
                       skip_dups       enable  -skip_dups mode.
                       noskip_dups     disable -skip_dups mode.
                       add_keysyms     enable -add_keysyms mode.
                       noadd_keysyms   stop adding keysyms. those added will
                                       still be removed at exit.
                       clear_mods      enable  -clear_mods mode and clear them.
                       noclear_mods    disable -clear_mods mode.
                       clear_keys      enable  -clear_keys mode and clear them.
                       noclear_keys    disable -clear_keys mode.
                       clear_locks     do the clear_locks action.
                       clear_all       do the clear_all action.
                       keystate        have x11vnc print current keystate.
                       remap:str       set -remap "str" (empty to disable).
                                       See -remap for the form of "str"
                                       (basically: key1-key2,key3-key4,...)
                                       Use "+key1-key2" to append a single
                                       keymapping, use "-key1-key2" to delete.
                       norepeat        enable  -norepeat mode.
                       repeat          disable -norepeat mode.
                       nofb            enable  -nofb mode.
                       fb              disable -nofb mode.
                       bell            enable  bell (if supported).
                       nobell          disable bell.
                       sendbell        ring the bell now.
                       nosel           enable  -nosel mode.
                       sel             disable -nosel mode.
                       noprimary       enable  -noprimary mode.
                       primary         disable -noprimary mode.
                       nosetprimary    enable  -nosetprimary mode.
                       setprimary      disable -nosetprimary mode.
                       noclipboard     enable  -noclipboard mode.
                       clipboard       disable -noclipboard mode.
                       nosetclipboard  enable  -nosetclipboard mode.
                       setclipboard    disable -nosetclipboard mode.
                       seldir:str      set -seldir to "str"
                       resend_cutbuffer resend the most recent CUTBUFFER0 copy
                       resend_clipboard resend the most recent CLIPBOARD copy
                       resend_primary   resend the most recent PRIMARY copy
                       cursor:mode     enable  -cursor "mode".
                       show_cursor     enable  showing a cursor.
                       noshow_cursor   disable showing a cursor. (same as
                                       "nocursor")
                       cursor_drag     enable  cursor changes during drag.
                       nocursor_drag   disable cursor changes during drag.
                       arrow:n         set -arrow to alternate n.
                       xfixes          enable  xfixes cursor shape mode.
                       noxfixes        disable xfixes cursor shape mode.
                       alphacut:n      set -alphacut to n.
                       alphafrac:f     set -alphafrac to f.
                       alpharemove     enable  -alpharemove mode.
                       noalpharemove   disable -alpharemove mode.
                       alphablend      disable -noalphablend mode.
                       noalphablend    enable  -noalphablend mode.
                       cursorshape     disable -nocursorshape mode.
                       nocursorshape   enable  -nocursorshape mode.
                       cursorpos       disable -nocursorpos mode.
                       nocursorpos     enable  -nocursorpos mode.
                       xwarp           enable  -xwarppointer mode.
                       noxwarp         disable -xwarppointer mode.
                       always_inject   enable  -always_inject mode.
                       noalways_inject disable -always_inject mode.
                       buttonmap:str   set -buttonmap "str", empty to disable
                       dragging        disable -nodragging mode.
                       nodragging      enable  -nodragging mode.
                       ncache          reenable -ncache mode.
                       noncache        disable  -ncache mode.
                       ncache_size:n   set -ncache size to n.
                       ncache_cr       enable  -ncache_cr mode.
                       noncache_cr     disable -ncache_cr mode.
                       ncache_no_moveraise     enable  no_moveraise mode.
                       noncache_no_moveraise   disable no_moveraise mode.
                       ncache_no_dtchange      enable  ncache_no_dtchange mode.
                       noncache_no_dtchange    disable ncache_no_dtchange mode.
                       ncache_old_wm           enable  ncache_old_wm mode.
                       noncache_old_wm         disable ncache_old_wm mode.
                       ncache_no_rootpixmap    enable  ncache_no_rootpixmap.
                       noncache_no_rootpixmap  disable ncache_no_rootpixmap.
                       ncache_reset_rootpixmap recheck the root pixmap, ncrp
                       ncache_keep_anims       enable  ncache_keep_anims.
                       noncache_keep_anims     disable ncache_keep_anims.
                       ncache_pad:n    set -ncache_pad to n.
                       wireframe       enable  -wireframe mode. same as "wf"
                       nowireframe     disable -wireframe mode. same as "nowf"
                       wireframe:str   enable  -wireframe mode string.
                       wireframe_mode:str enable  -wireframe mode string.
                       wireframelocal  enable  wireframelocal. same as "wfl"
                       nowireframe     disable wireframelocal. same as "nowfl"
                       wirecopyrect:str set -wirecopyrect string. same as "wcr:"
                       scrollcopyrect:str set -scrollcopyrect string. same "scr"
                       noscrollcopyrect disable -scrollcopyrect mode. "noscr"
                       scr_area:n      set -scr_area to n
                       scr_skip:list   set -scr_skip to "list"
                       scr_inc:list    set -scr_inc to "list"
                       scr_keys:list   set -scr_keys to "list"
                       scr_term:list   set -scr_term to "list"
                       scr_keyrepeat:str set -scr_keyrepeat to "str"
                       scr_parms:str   set -scr_parms parameters.
                       fixscreen:str   set -fixscreen to "str".
                       noxrecord       disable all use of RECORD extension.
                       xrecord         enable  use of RECORD extension.
                       reset_record    reset RECORD extension (if avail.)
                       pointer_mode:n  set -pointer_mode to n. same as "pm"
                       input_skip:n    set -input_skip to n.
                       allinput        enable  use of -allinput mode.
                       noallinput      disable use of -allinput mode.
                       input_eagerly   enable  use of -input_eagerly mode.
                       noinput_eagerly disable use of -input_eagerly mode.
                       ssltimeout:n    set -ssltimeout to n.
                       speeds:str      set -speeds to str.
                       wmdt:str        set -wmdt to str.
                       debug_pointer   enable  -debug_pointer, same as "dp"
                       nodebug_pointer disable -debug_pointer, same as "nodp"
                       debug_keyboard   enable  -debug_keyboard, same as "dk"
                       nodebug_keyboard disable -debug_keyboard, same as "nodk"
                       keycode:n       inject keystroke 'keycode' (xmodmap -pk)
                       keycode:n,down  inject 'keycode' (down=0,1)
                       keysym:str      inject keystroke 'keysym' (number/name)
                       keysym:str,down inject 'keysym' (down=0,1)
                       ptr:x,y,mask    inject pointer event x, y, button-mask
                       fakebuttonevent:button,down direct XTestFakeButtonEvent.
                       sleep:t         sleep floating point time t.
                       get_xprop:p     get X property named 'p'.
                       set_xprop:p:val set X property named 'p' to 'val'.
                                       p -> id=NNN:p for hex/dec window id.
                       wininfo:id      get info about X window id.  use 'root'
                                       for root window, use +id for children.
                       grab_state      get state of pointer and keyboard grab.
                       pointer_pos     print XQueryPointer x,y cursor position.
                       pointer_x       print XQueryPointer x cursor position.
                       pointer_y       print XQueryPointer y cursor position.
                       pointer_same    print XQueryPointer ptr on same screen.
                       pointer_root    print XQueryPointer curr ptr rootwin.
                       pointer_mask    print XQueryPointer button and mods mask
                       mouse_x         print x11vnc's idea of cursor position.
                       mouse_y         print x11vnc's idea of cursor position.
                       noop            do nothing.
                       defer:n         set -defer to n ms,same as deferupdate:n
                       wait:n          set -wait to n ms.
                       extra_fbur:n    set -extra_fbur to n.
                       wait_ui:f       set -wait_ui factor to f.
                       setdefer:n      set -setdefer to -2,-1,0,1, or 2.
                       wait_bog        disable -nowait_bog mode.
                       nowait_bog      enable  -nowait_bog mode.
                       slow_fb:f       set -slow_fb to f seconds.
                       xrefresh:f      set -xrefresh to f seconds.
                       readtimeout:n   set read timeout to n seconds.
                       nap             enable  -nap mode.
                       nonap           disable -nap mode.
                       sb:n            set -sb to n s, same as screen_blank:n
                       fbpm            disable -nofbpm mode.
                       nofbpm          enable  -nofbpm mode.
                       dpms            disable -nodpms mode.
                       nodpms          enable  -nodpms mode.
                       forcedpms       enable  -forcedpms mode.
                       noforcedpms     disable -forcedpms mode.
                       clientdpms      enable  -clientdpms mode.
                       noclientdpms    disable -clientdpms mode.
                       noserverdpms    enable  -noserverdpms mode.
                       serverdpms      disable -noserverdpms mode.
                       noultraext      enable  -noultraext mode.
                       ultraext        disable -noultraext mode.
                       chatwindow      enable  local chatwindow mode.
                       nochatwindow    disable local chatwindow mode.
                       chaton          begin chat using local window.
                       chatoff         end   chat using local window.
                       xdamage         enable  xdamage polling hints.
                       noxdamage       disable xdamage polling hints.
                       xd_area:A       set -xd_area max pixel area to "A"
                       xd_mem:f        set -xd_mem remembrance to "f"
                       fs:frac         set -fs fraction to "frac", e.g. 0.5
                       gaps:n          set -gaps to n.
                       grow:n          set -grow to n.
                       fuzz:n          set -fuzz to n.
                       snapfb          enable  -snapfb mode.
                       nosnapfb        disable -snapfb mode.
                       rawfb:str       set -rawfb mode to "str".
                       uinput_accel:f  set uinput_accel to f.
                       uinput_thresh:n set uinput_thresh to n.
                       uinput_reset:n  set uinput_reset to n ms.
                       uinput_always:n set uinput_always to 1/0.
                       progressive:n   set LibVNCServer -progressive slice
                                       height parameter to n.
                       desktop:str     set -desktop name to str for new clients.
                       rfbport:n       set -rfbport to n.
                       macnosaver      enable  -macnosaver mode.
                       macsaver        disable -macnosaver mode.
                       macnowait       enable  -macnowait  mode.
                       macwait         disable -macnowait  mode.
                       macwheel:n      set -macwheel to n.
                       macnoswap       enable  -macnoswap mouse button mode.
                       macswap         disable -macnoswap mouse button mode.
                       macnoresize     enable  -macnoresize mode.
                       macresize       disable -macnoresize mode.
                       maciconanim:n   set -maciconanim to n.
                       macmenu         enable  -macmenu  mode.
                       macnomenu       disable -macmenu  mode.
                       macuskbd        enable  -macuskbd mode.
                       macnouskbd      disable -macuskbd mode.
                       httpport:n      set -httpport to n.
                       httpdir:dir     set -httpdir to dir (and enable http).
                       enablehttpproxy   enable  -enablehttpproxy mode.
                       noenablehttpproxy disable -enablehttpproxy mode.
                       alwaysshared     enable  -alwaysshared mode.
                       noalwaysshared   disable -alwaysshared mode.
                                        (may interfere with other options)
                       nevershared      enable  -nevershared mode.
                       nonevershared    disable -nevershared mode.
                                        (may interfere with other options)
                       dontdisconnect   enable  -dontdisconnect mode.
                       nodontdisconnect disable -dontdisconnect mode.
                                        (may interfere with other options)
                       debug_xevents   enable  debugging X events.
                       nodebug_xevents disable debugging X events.
                       debug_xdamage   enable  debugging X DAMAGE mechanism.
                       nodebug_xdamage disable debugging X DAMAGE mechanism.
                       debug_wireframe enable   debugging wireframe mechanism.
                       nodebug_wireframe disable debugging wireframe mechanism.
                       debug_scroll    enable  debugging scrollcopy mechanism.
                       nodebug_scroll  disable debugging scrollcopy mechanism.
                       debug_tiles     enable  -debug_tiles
                       nodebug_tiles   disable -debug_tiles
                       debug_grabs     enable  -debug_grabs
                       nodebug_grabs   disable -debug_grabs
                       debug_sel       enable  -debug_sel
                       nodebug_sel     disable -debug_sel
                       debug_ncache    enable  -debug_ncache
                       nodebug_ncache  disable -debug_ncache
                       dbg             enable  -dbg crash shell
                       nodbg           disable -dbg crash shell

                       noremote        disable the -remote command processing,
                                       it cannot be turned back on.

                       bcx_xattach:str  This remote control command is for
                       use with the BARCO xattach program or the x2x program.
                       Both of these programs are for 'pointer and keyboard'
                       sharing between separate X displays.  In general the
                       two displays are usually nearby, e.g. on the same desk,
                       and this allows the user to share a single pointer and
                       keyboard between them.  The user moves the mouse to
                       an edge and then the mouse pointer appears to 'jump'
                       to the other display screen.  Thus it emulates what a
                       single X server would do for two screens (e.g. :0.0 and
                       :0.1) The illusion of a single Xserver with multiple
                       screens is achieved by forwarding events to the 2nd
                       one via the XTEST extension.

                       What the x11vnc bcx_xattach command does is to perform
                       some pointer movements to try to INDUCE xattach/x2x
                       to 'jump' to the other display.  In what follows the
                       'master' display refers to the one that when it has
                       'focus' it is basically doing nothing besides watching
                       for the mouse to go over an edge.  The 'slave'
                       display refers to the one to which the mouse and
                       keyboard is redirected to once an edge in the master
                       has been crossed.  Note that the x11vnc executing the
                       bcx_xattach command MUST be the one connected to the
                       *master* display.

                       Also note that when input is being redirected (via
                       XTEST) from the master display to the slave display,
                       the master display's pointer and keyboard are *grabbed*
                       by xattach/x2x.  x11vnc can use this info to verify that
                       the master/slave mode change has taken place correctly.
                       If you specify the "ifneeded" option (see below)
                       and the initial grab state is that of the desired
                       final state, then no pointer movements are injected
                       and "DONE,GRAB_OK" is returned.

                       "str" must contain one of "up", "down", "left",
                       or "right" to indicate the direction of the 'jump'.
                       "str" must also contain one of "master_to_slave"
                       or "slave_to_master" to indicate the type of mode
                       change induced by the jump.  Use "M2S" and "S2M"
                       as shorter aliases.

                       "str" may be a "+" separated list of additional
                       tuning options.  The "shift=n" option indicates an
                       offset shift position away from (0,0) (default 20).
                       "final=x+y" specifies the final position of the cursor
                       at the end of the normal move sequence; default 30+30.
                       "extra_move=x+y" means to do one more pointer move
                       after "final" to x+y.  "dt=n" sets the sleep time
                       in milliseconds between pointer moves (default: 40ms)
                       "retry=n" specifies the maximum number of retries if
                       the grab state change fails. "ifneeded" means to not
                       apply the pointer movements if the initial grab state is
                       that of the desired final state. "nograbcheck" means
                       to not check if the grab state changed as expected and
                       only apply the pointer movements (default is to check
                       the grab states.)

                       If you do not specify "up", etc., to bcx_xattach
                       nothing will be attempted and the command returns
                       the string FAIL,NO_DIRECTION_SPECIFIED.  If you do
                       not specify "master_to_slave" or "M2S", etc., to
                       bcx_xattach nothing will be attempted and the command
                       returns the string FAIL,NO_MODE_CHANGE_SPECIFIED.

                       Otherwise, the returned string will contain "DONE".
                       It will be "DONE,GRAB_OK" if the grab state changed
                       as expected (or if "ifneeded" was supplied and
                       the initial grab state was already the desired
                       one.)  If the initial grab state was incorrect,
                       but the final grab state was correct then it is
                       "DONE,GRAB_FAIL_INIT".  If the initial grab state
                       was correct, but the final grab state was incorrect
                       then it is "DONE,GRAB_FAIL_FINAL".  If both are
                       incorrect it will be "DONE,GRAB_FAIL".  Under grab
                       failure the string will be followed by ":p1,k1-p2,k2"
                       where  p1,k1 indicates the initial pointer and keyboard
                       grab states and p2,k2 the final ones. If GRAB_FAIL or
                       GRAB_FAIL_FINAL occurs, the action will be retried up
                       to 3 times; trying to reset the state and sleeping a
                       bit between each try.  Set retry=n to adjust the number
                       of retries, zero to disable retries.

                       Examples:
                           -R bcx_xattach:down+M2S
                           -R bcx_xattach:up+S2M
                           -R bcx_xattach:up+S2M+nograbcheck+dt=30
                           -R bcx_xattach:down+M2S+extra_move=100+100

                       or use -Q instead of -R to retrieve the result text.

                       End of the bcx_xattach:str description.

                       The vncconnect(1) command from standard VNC
                       distributions may also be used if string is prefixed
                       with "cmd=" E.g. 'vncconnect cmd=stop'.  Under some
                       circumstances xprop(1) can used if it supports -set
                       (see the FAQ).

                       If "-connect /path/to/file" has been supplied to the
                       running x11vnc server then that file can be used as a
                       communication channel (this is the only way to remote
                       control one of many x11vnc's polling the same X display)
                       Simply run: 'x11vnc -connect /path/to/file -remote ...'
                       or you can directly write to the file via something
                       like: "echo cmd=stop > /path/to/file", etc.

<a name="opt-query"></a>-query variable        Like -remote, except just query the value of
                       "variable".  "-Q" is an alias for "-query".
                       Multiple queries can be done by separating variables
                       by commas, e.g. -query var1,var2\. The results come
                       back in the form ans=var1:value1,ans=var2:value2,...
                       to the standard output.  If a variable is read-only,
                       it comes back with prefix "aro=" instead of "ans=".

                       Some -remote commands are pure actions that do not make
                       sense as variables, e.g. "stop" or "disconnect", in
                       these cases the value returned is "N/A".  To direct a
                       query straight to the X11VNC_REMOTE property or connect
                       file use "qry=..." instead of "cmd=..."

                       ans= stop quit exit shutdown ping resend_cutbuffer
                       resend_clipboard resend_primary blacken zero refresh
                       reset close disconnect id_cmd id sid waitmapped
                       nowaitmapped clip flashcmap noflashcmap shiftcmap
                       truecolor notruecolor overlay nooverlay overlay_cursor
                       overlay_yescursor nooverlay_nocursor nooverlay_cursor
                       nooverlay_yescursor overlay_nocursor 8to24 no8to24
                       8to24_opts 24to32 no24to32 visual scale scale_cursor
                       viewonly noviewonly shared noshared forever noforever
                       once timeout tightfilexfer notightfilexfer ultrafilexfer
                       noultrafilexfer rfbversion deny lock nodeny unlock avahi
                       mdns zeroconf noavahi nomdns nozeroconf connect proxy
                       allowonce allow noipv6 ipv6 noipv4 ipv4 no6 6 localhost
                       nolocalhost listen lookup nolookup accept afteraccept
                       gone shm noshm flipbyteorder noflipbyteorder onetile
                       noonetile solid_color solid nosolid blackout xinerama
                       noxinerama xtrap noxtrap xrandr noxrandr xrandr_mode
                       rotate padgeom quiet q noquiet modtweak nomodtweak xkb
                       noxkb capslock nocapslock skip_lockkeys noskip_lockkeys
                       skip_keycodes sloppy_keys nosloppy_keys skip_dups
                       noskip_dups add_keysyms noadd_keysyms clear_mods
                       noclear_mods clear_keys noclear_keys clear_all
                       clear_locks keystate remap repeat norepeat fb nofb bell
                       nobell sendbell sel nosel primary noprimary setprimary
                       nosetprimary clipboard noclipboard setclipboard
                       nosetclipboard seldir cursorshape nocursorshape
                       cursorpos nocursorpos cursor_drag nocursor_drag cursor
                       show_cursor noshow_cursor nocursor arrow xfixes noxfixes
                       xdamage noxdamage xd_area xd_mem alphacut alphafrac
                       alpharemove noalpharemove alphablend noalphablend
                       xwarppointer xwarp noxwarppointer noxwarp always_inject
                       noalways_inject buttonmap dragging nodragging ncache_cr
                       noncache_cr ncache_no_moveraise noncache_no_moveraise
                       ncache_no_dtchange noncache_no_dtchange
                       ncache_no_rootpixmap noncache_no_rootpixmap
                       ncache_reset_rootpixmap ncrp ncache_keep_anims
                       noncache_keep_anims ncache_old_wm noncache_old_wm
                       ncache_pad ncache noncache ncache_size debug_ncache
                       nodebug_ncache wireframe_mode wireframe wf nowireframe
                       nowf wireframelocal wfl nowireframelocal nowfl
                       wirecopyrect wcr nowirecopyrect nowcr scr_area
                       scr_skip scr_inc scr_keys scr_term scr_keyrepeat
                       scr_parms scrollcopyrect scr noscrollcopyrect
                       noscr fixscreen noxrecord xrecord reset_record
                       pointer_mode pm input_skip allinput noallinput
                       input_eagerly noinput_eagerly input grabkbd nograbkbd
                       grabptr nograbptr grabalways nograbalways grablocal
                       client_input ssltimeout speeds wmdt debug_pointer dp
                       nodebug_pointer nodp debug_keyboard dk nodebug_keyboard
                       nodk keycode keysym ptr fakebuttonevent sleep get_xprop
                       set_xprop wininfo bcx_xattach deferupdate defer
                       setdefer extra_fbur wait_ui wait_bog nowait_bog
                       slow_fb xrefresh wait readtimeout nap nonap sb
                       screen_blank fbpm nofbpm dpms nodpms clientdpms
                       noclientdpms forcedpms noforcedpms noserverdpms
                       serverdpms noultraext ultraext chatwindow nochatwindow
                       chaton chatoff fs gaps grow fuzz snapfb nosnapfb
                       rawfb uinput_accel uinput_thresh uinput_reset
                       uinput_always progressive rfbport http nohttp httpport
                       httpdir enablehttpproxy noenablehttpproxy alwaysshared
                       noalwaysshared nevershared noalwaysshared dontdisconnect
                       nodontdisconnect desktop debug_xevents nodebug_xevents
                       debug_xevents debug_xdamage nodebug_xdamage
                       debug_xdamage debug_wireframe nodebug_wireframe
                       debug_wireframe debug_scroll nodebug_scroll debug_scroll
                       debug_tiles dbt nodebug_tiles nodbt debug_tiles
                       debug_grabs nodebug_grabs debug_sel nodebug_sel dbg
                       nodbg macnosaver macsaver nomacnosaver macnowait macwait
                       nomacnowait macwheel macnoswap macswap nomacnoswap
                       macnoresize macresize nomacnoresize maciconanim macmenu
                       macnomenu nomacmenu macuskbd nomacuskbd noremote

                       aro=  noop display vncdisplay icon_mode autoport
                       loop loopbg desktopname guess_desktop guess_dbus
                       http_url auth xauth users rootshift clipshift scale_str
                       scaled_x scaled_y scale_numer scale_denom scale_fac_x
                       scale_fac_y scaling_blend scaling_nomult4 scaling_pad
                       scaling_interpolate inetd privremote unsafe safer nocmds
                       passwdfile unixpw unixpw_nis unixpw_list ssl ssl_pem
                       sslverify stunnel stunnel_pem https httpsredir usepw
                       using_shm logfile o flag rmflag rc norc h help V version
                       lastmod bg sigpipe threads readrate netrate netlatency
                       pipeinput clients client_count pid ext_xtest ext_xtrap
                       ext_xrecord ext_xkb ext_xshm ext_xinerama ext_overlay
                       ext_xfixes ext_xdamage ext_xrandr rootwin num_buttons
                       button_mask mouse_x mouse_y grab_state pointer_pos
                       pointer_x pointer_y pointer_same pointer_root
                       pointer_mask bpp depth indexed_color dpy_x dpy_y wdpy_x
                       wdpy_y off_x off_y cdpy_x cdpy_y coff_x coff_y rfbauth
                       passwd viewpasswd

<a name="opt-QD"></a>-QD variable           Just like -query variable, but returns the default
                       value for that parameter (no running x11vnc server
                       is consulted)

<a name="opt-sync"></a>-sync                  By default -remote commands are run asynchronously, that
                       is, the request is posted and the program immediately
                       exits.  Use -sync to have the program wait for an
                       acknowledgement from the x11vnc server that command was
                       processed (somehow).  On the other hand -query requests
                       are always processed synchronously because they have
                       to wait for the answer.

                       Also note that if both -remote and -query requests are
                       supplied on the command line, the -remote is processed
                       first (synchronously: no need for -sync), and then
                       the -query request is processed in the normal way.
                       This allows for a reliable way to see if the -remote
                       command was processed by querying for any new settings.
                       Note however that there is timeout of a few seconds
                       (see the next paragraph) so if the x11vnc takes longer
                       than that to process the requests the requester will
                       think that a failure has taken place.

                       The default is to wait 3.5 seconds.  Or if cmd=stop
                       only 1.0 seconds.  If cmd matches 'script:' then it
                       will wait up to 10.0 seconds.  Set X11VNC_SYNC_TIMEOUT
                       to the number of seconds you want it to wait.

<a name="opt-query_retries"></a>-query_retries str     If a query fails to get a response from an x11vnc
                       server, retry up to n times.  "str" is specified as
                       n[:t][/match]  Optionally the delay between tries may
                       be specified by "t" a floating point time (default
                       0.5 seconds.)  Note: the response is not checked for
                       validity or whether it corresponds to the query sent.
                       The query "ping:mystring" may be used to help uniquely
                       identify the query.  Optionally, a matching string after
                       a "/" will be used to check the result text.  Up to
                       n retries will take place until the matching string is
                       found in the output text.  If the match string is never
                       found the program's exit code is 1; if the match is
                       found it exits with 0\.  Note that there may be stdout
                       printed for each retry (i.e. multiple lines printed
                       out to stdout.)
                       Example: -query_retries 4:1.5/grab_state

<a name="opt-remote_prefix"></a>-remote_prefix str     Enable a remote-control communication channel for
                       connected VNC clients.  str is a non-empty string. If a
                       VNC client sends rfbCutText having the prefix "str"
                       then the part after it is processed as though it were
                       sent via 'x11vnc -remote ...'.  If it begins with
                       neither 'cmd=' nor 'qry=' then 'qry=' is assumed.
                       Any corresponding output text for that remote control
                       command is sent back to all client as rfbCutText.
                       The returned output is also prefixed with "str".
                       Example: -remote_prefix DO_THIS:

                       Note that enabling -remote_prefix allows the remote
                       VNC viewers to run x11vnc -remote commands.  Do not
                       use this option if they are not to be trusted.

<a name="opt-noremote"></a>-noremote              Do not process any remote control commands or queries.
<a name="opt-yesremote"></a>-yesremote             Do process remote control commands or queries.
                       Default: -yesremote

                       A note about security wrt remote control commands.
                       If someone can connect to the X display and change
                       the property X11VNC_REMOTE, then they can remotely
                       control x11vnc.  Normally access to the X display is
                       protected.  Note that if they can modify X11VNC_REMOTE
                       on the X server, they have enough permissions to also
                       run their own x11vnc and thus have complete control
                       of the desktop.  If the  "-connect /path/to/file"
                       channel is being used, obviously anyone who can write
                       to /path/to/file can remotely control x11vnc.  So be
                       sure to protect the X display and that file's write
                       permissions.  See -privremote below.

                       If you are paranoid and do not think -noremote is
                       enough, to disable the X11VNC_REMOTE property channel
                       completely use -novncconnect, or use the -safer option
                       that shuts many things off.

<a name="opt-unsafe"></a>-unsafe                A few remote commands are disabled by default
                       (currently: id:pick, accept:<cmd>, gone:<cmd>, and
                       rawfb:setup:<cmd>) because they are associated with
                       running external programs.  If you specify -unsafe, then
                       these remote-control commands are allowed.  Note that
                       you can still specify these parameters on the command
                       line, they just cannot be invoked via remote-control.
<a name="opt-safer"></a>-safer                 Equivalent to: -novncconnect -noremote and prohibiting
                       -gui and the -connect file. Shuts off communcation
                       channels.
<a name="opt-privremote"></a>-privremote            Perform some sanity checks and disable remote-control
                       commands if it appears that the X DISPLAY and/or
                       connectfile can be accessed by other users.  Once
                       remote-control is disabled it cannot be turned back on.
<a name="opt-nocmds"></a>-nocmds                No external commands (e.g. system(3), popen(3), exec(3))
                       will be run at all.
<a name="opt-allowedcmds"></a>-allowedcmds list      "list" contains a comma separated list of the only
                       external commands that can be run.  The full list of
                       associated options is:

                        stunnel, ssl, unixpw, WAIT, zeroconf, id, accept,
                        afteraccept, gone, pipeinput, v4l-info, rawfb-setup,
                        dt, gui, ssh, storepasswd, passwdfile, custom_passwd,
                        findauth, crash.

                       See each option's help to learn the associated external
                       command.  Note that the -nocmds option takes precedence
                       and disables all external commands.

<a name="opt-deny_all"></a>-deny_all              For use with -remote nodeny: start out denying all
                       incoming clients until "-remote nodeny" is used to
                       let them in.

These options are passed to LibVNCServer:

<a name="opt-rfbport"></a>-rfbport port          TCP port for RFB protocol
<a name="opt-rfbwait"></a>-rfbwait time          max time in ms to wait for RFB client
<a name="opt-rfbauth"></a>-rfbauth passwd-file   use authentication on RFB protocol
                       (use 'storepasswd' to create a password file)
<a name="opt-rfbversion"></a>-rfbversion 3.x        Set the version of the RFB we choose to advertise
<a name="opt-permitfiletransfer"></a>-permitfiletransfer    permit file transfer support
<a name="opt-passwd"></a>-passwd plain-password use authentication 
                       (use plain-password as password, USE AT YOUR RISK)
<a name="opt-deferupdate"></a>-deferupdate time      time in ms to defer updates (default 40)
<a name="opt-deferptrupdate"></a>-deferptrupdate time   time in ms to defer pointer updates (default none)
<a name="opt-desktop"></a>-desktop name          VNC desktop name (default "LibVNCServer")
<a name="opt-alwaysshared"></a>-alwaysshared          always treat new clients as shared
<a name="opt-nevershared"></a>-nevershared           never treat new clients as shared
<a name="opt-dontdisconnect"></a>-dontdisconnect        don't disconnect existing clients when a new non-shared
                       connection comes in (refuse new connection instead)
<a name="opt-httpdir"></a>-httpdir dir-path      enable http server using dir-path home
<a name="opt-httpport"></a>-httpport portnum      use portnum for http connection
<a name="opt-enablehttpproxy"></a>-enablehttpproxy       enable http proxy support
<a name="opt-progressive"></a>-progressive height    enable progressive updating for slow links
<a name="opt-listen"></a>-listen ipaddr         listen for connections only on network interface with
                       addr ipaddr. '-listen localhost' and hostname work too.

libvncserver-tight-extension options:
<a name="opt-disablefiletransfer"></a>-disablefiletransfer   disable file transfer
<a name="opt-ftproot"></a>-ftproot string        set ftp root

</pre>

Pretty wild huh? Contact me if you have any questions or problems.

Personally, I use:

<pre>x11vnc -rfbauth $HOME/.vnc/passwd -solid
</pre>
